*------------------------------------------------------------*
User:                ali
Date:                December 19, 2019
Time:                14:17:11
Site:                12601940
Platform:            W32_8PRO
Maintenance Release: 9.04.01M3P062415
EM Version:          14.1
* 
*------------------------------------------------------------*
* Training Log
Date:                December 19, 2019
Time:                14:17:09
*------------------------------------------------------------*
14718  proc freq data=EMWS5.TSDP3_VariableSet noprint;
14719  table ROLE*LEVEL/out=WORK.TSDP3META;
14720  run;
 
NOTE: There were 6 observations read from the data set EMWS5.TSDP3_VARIABLESET.
NOTE: The data set WORK.TSDP3META has 3 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
14721  proc print data=WORK.TSDP3META label noobs;
14722  var ROLE LEVEL COUNT;
14723  label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
14724  title9 ' ';
14725  title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
14726  run;
 
NOTE: There were 3 observations read from the data set WORK.TSDP3META.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
14727  title10;
 
14728  %let EMEXCEPTIONSTRING=;
PERFORMANCE  DETAILS
15090  *------------------------------------------------------------*;
15091  * TSDP3: Generation of macros and macro variables;
15092  * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
15093  *------------------------------------------------------------*;
 
15094  %let EMEXCEPTIONSTRING=;
15095  *------------------------------------------------------------*;
15096  * TRAIN: TSDP3;
15097  *------------------------------------------------------------*;
15098  %let EM_ACTION = TRAIN;
15099  %let syscc = 0;
15100
15101  %macro EM_TSDP_MAIN;
15102
15103     filename temp catalog 'sashelp.emtsdm.tsdp_macros.source';
15104     %include temp;
15105     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
15106     %include temp;
15107     filename temp;
15108
15109     %if %upcase(&EM_ACTION) = CREATE %then %do;
15110         filename temp catalog 'sashelp.emtsdm.tsdp_create.source';
15111         %include temp;
15112         filename temp;
15113         %EM_TSDP_CREATE;
15114     %end;
15115     %else
15116     %if %upcase(&EM_ACTION) = TRAIN %then %do;
15117          filename temp catalog 'sashelp.emtsdm.tsdp_train.source';
15118             %include temp;
15119             filename temp;
15120         %EM_TSDP_TRAIN;
15121     %end;
15122     %else
15123     %if %upcase(&EM_ACTION) = SCORE %then %do;
15124          filename temp catalog 'sashelp.emtsdm.tsdp_score.source';
15125             %include temp;
15126             filename temp;
15127         %EM_TSDP_SCORE;
15128     %end;
15129     %else
15130     %if %upcase(&EM_ACTION) = REPORT %then %do;
15131             filename temp catalog 'sashelp.emtsdm.tsdp_report.source';
15132             %include temp;
15133             filename temp;
15134          %EM_TSDP_REPORT;
15135     %end;
15136     %else
15137       %if %upcase(&EM_ACTION) = OPENTIMETABLEACTION  %then %do;
15138             filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
15139             %include temp;
15140             filename temp;
15141          %EM_TSDP_OpenTimeTable ;
15142     %end;
15143     %else
15144     %if %upcase(&EM_ACTION) = CLOSETABLEACTION  %then %do;
15145            filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
15146             %include temp;
15147             filename temp;
15148          %EM_TSDP_closeTimeTable ;
15149     %end;
15150
15151  %mend EM_TSDP_MAIN;
15152  %EM_TSDP_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_MACROS.SOURCE.
15153 +/*----------------------------------------------------------------------------------+
15154 + |
15155 + |   Title :
15156 + |   TS Data Preparation Node for Time Series Data Mining
15157 + |
15158 + |   Support : Taiyeong Lee( Taiyeong.Lee@sas.com)
15159 + |
15160 + |   Notes:
15161 + |
15162 + |----------------------------------------------------------------------------------*/
15165 +%Macro EM_TSDP_Timeseries(
15166 +    /*--- input data set and variables ----*/
15167 +    inds            = ,
15168 +    crossid         = ,
15169 +    timeid          = ,
15171 +      /*--- time ID variable ----------------*/
15172 +    interval        = ,
15173 +    accumulation    = ,
15174 +    timeidfmttype   = ,
15175 +    timeidformat    = ,
15176 +    start           = ,
15177 +    end             = ,
15178 +    seasonlength    = ,
15180 +      /*--- transformation ------------------*/
15181 +    transform       = ,
15182 +    boxcoxpara      = ,
15184 +      /*--- differencing --------------------*/
15185 +    applydif        = ,
15186 +    dif             = ,
15187 +    applysdif       = ,
15188 +    sdif            = ,
15190 +      /*--- missing intepretation------------*/
15191 +    missing         = ,
15192 +    missingconstant = ,
15193 +    zeromiss        = ,
15195 +      /*--- output data sets ----------------*/
15196 +    outds           = ,
15197 +    outsum          = ,
15198 +    outseason       =
15199 +);
15201 +/*%if &interval eq Hour or &interval eq Minute or &interval eq Second
15202 +    or &EM_PROPERTY_TIMEOFDAY eq Y or &timeidfmttype eq DATETIME   */
15203 +%if &timeidfmttype eq DATETIME
15204 +%then %do;
15205 +    %let _dtTag=DT;
15206 +%end;
15207 +%else %if &timeidfmttype eq TIME
15208 +%then %do;
15209 +    %let _dtTag=T;
15210 +%end;
15211 +%else %do;
15212 +    %let _dtTag=D;
15213 +%end;
15215 +proc sort data=&inds(keep = &crossid &timeid %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED)
15216 +     out=_tmpinds;
15217 +     by &crossid &timeid;
15218 +run;
15220 +proc timeseries data=_tmpinds out=&outds
15221 +    %if "&crossid" eq " "
15222 +        %then %do; outsum=&outsum(rename=(_NAME_=_NAMEID_)) %end;
15223 +        %else %do; outsum=&outsum %end;
15224 +    %if &seasonlength gt 1
15225 +    %then %do;
15226 +        outseason = &outseason seasonality= &seasonlength
15227 +    %end;
15228 +    ;
15230 +    %if &seasonlength gt 1
15231 +    %then %do;
15232 +        season SUM MEAN MIN MAX MEDIAN;
15233 +    %end;
15235 +    %if &crossid ne  %then %do;
15236 +        by &crossid;
15237 +    %end;
15239 +    id &timeid
15240 +        interval   = &interval
15241 +        accumulate = &accumulation
15242 +        %if &missing eq CONSTANT %then %do;
15243 +            setmissing = &missingconstant
15244 +        %end;
15245 +        %else %do;
15246 +            setmissing = &missing
15247 +        %end;
15248 +        %if &zeromiss ne NONE  %then %do;
15249 +            zeromiss = &zeromiss
15250 +        %end;
15251 +        %if &start ne  %then %do;
15252 +            %let  _start = "&start" ;
15253 +            start = &_start.&_dtTag
15254 +        %end;
15255 +        %if &end ne  %then %do;
15256 +            %let  _end = "&end";
15257 +            end = &_end.&_dtTag
15258 +        %end;
15259 +    ;
15261 +    var %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /
15262 +        %if &zeromiss ne NONE  %then %do;
15263 +            zeromiss = &zeromiss
15264 +        %end;
15265 +        %if &transform ne NONE  %then %do;
15266 +            %if &transform eq BOXCOX  %then %do;
15267 +                transform = BOXCOX(&boxcoxpara)
15268 +            %end;
15269 +            %else %do;
15270 +                transform = &transform
15271 +            %end;
15272 +        %end;
15273 +        %if &applydif eq Y  %then %do;
15274 +            dif = (&dif)
15275 +        %end;
15276 +        %if &applysdif eq Y %then %do;
15277 +            sdif = (&sdif)
15278 +        %end;
15279 +    ;
15280 +run;
15281 +quit;
15283 +%mend EM_TSDP_TimeSeries;
15286 +/*-----------------------------------------------------------------
15288 +    MERGE AFTER CLUSTERING
15290 ++------------------------------------------------------------------*/
15292 +%macro EM_TSDP_MergeAfterClustering();
15294 +/*--- need to fix the code based on data Role (train or transaction) ---*/
15296 +%EM_REGISTER(KEY=CLUSTS, TYPE=DATA);
15297 +%EM_GETNAME(KEY=CLUSTS, TYPE=DATA);
15299 +%let _train = ;
15300 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
15301 +%if &dsid > 0 %then %do;
15302 + %let vn_data =%sysfunc(varnum(&dsid, DATA));
15303 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
15304 +%do %while(^ %sysfunc(fetch(&dsid)));
15305 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
15306 +     %if &_key eq TSDRTRAIN %then %do;
15307 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
15308 +     %end;
15309 +     %else %if &_key eq TSDCTRAIN %then %do;
15310 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
15311 +     %end;
15312 +     %else %if &_key eq TSDPTRAINDS %then %do;
15313 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
15314 +     %end;
15315 +%end;
15316 +%end;
15317 +%let dsid = %sysfunc(close(&dsid));
15319 +proc sort data =&_train out=_inds;
15320 +     by %EM_CROSSID;
15321 +run;
15322 +proc sort data=&EM_IMPORT_DATA out=_outclus(KEEP= %EM_CROSSID _SEGMENT_);
15323 +      by %EM_CROSSID;
15324 +run;
15325 +data &EM_USER_CLUSTS;
15326 +     merge _inds _outclus;
15327 +     by %EM_CROSSID;
15328 +run;
15330 +proc sort data =&EM_USER_TSIDMAP;
15331 +     by %EM_CROSSID;
15332 +run;
15334 +data &EM_USER_TSIDMAP;
15335 +     merge &EM_USER_TSIDMAP _outclus;
15336 +     by %EM_CROSSID;
15337 +run;
15339 +data &EM_USER_CLUSTS ;
15340 +    merge  &EM_USER_TSIDMAP &EM_USER_CLUSTS;
15341 +     by %EM_CROSSID;
15342 +run;
15343 +quit;
15345 +%mend EM_TSDP_MergeAfterClustering;
15347 +%macro EM_TSDP_MergeTSID(inds=, tsidds=, byvar=, outds=);
15349 +    proc sort data =&inds out=_tmp_inds;
15350 +        by &byvar;
15351 +    proc sort data=&tsidds out=_tmp_tsidds;
15352 +        by &byvar;
15353 +    run;
15354 +    %if &outds eq %then %do;
15355 +        data &inds;
15356 +    %end;
15357 +    %else %do;
15358 +        data &outds;
15359 +    %end;
15360 +            merge _tmp_tsidds _tmp_inds;
15361 +            by &byvar;
15362 +        run;
15364 +    %EM_TS_DELETE_DATA(dsname=_tmp_inds);
15365 +    %EM_TS_DELETE_DATA(dsname=_tmp_tsidds);
15367 +%mend EM_TSDP_MergeTSID;
15369 +%macro EM_TS_SummaryDS(inDS=, crossid=);
15370 +    %let j=1;
15371 +    %do %while(%scan(&crossid, &j) ne );
15372 +        %let _csvar=%scan(&crossid, &j);
15373 +        %EM_REGISTER(KEY=OUTSUM&j, TYPE=DATA);
15374 +        %EM_GETNAME(KEY=OUTSUM&j, TYPE=DATA);
15375 +        %EM_TS_SummaryByCSID(inDS=&inDS, outDS=&EM_USER_OUTSUM&j,crossIDVar=&_csvar);
15376 +        %let j=%eval(&j+1);
15377 +    %end;
15378 +%mend EM_TS_SummaryDS;
15381 +%macro EM_TS_SummaryByCSID(inDS=, outDS=, RoleVar=_role_, TSVar=_varname_, crossIDVar=);
15382 +    proc sql noprint;
15383 +        create table &outDS as
15384 +            select distinct &RoleVar, &TSVar, &crossIDVAr,
15385 +                mean(mean1)  as mean      label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmean, noquote))",
15386 +                std(mean1)   as std_mean  label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smean, noquote))",
15387 +                mean(sum1)   as sum       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_msum, noquote))",
15388 +                std(sum1)    as std_sum   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_ssum, noquote))",
15389 +                mean(min1)   as min       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmin, noquote))",
15390 +                std(min1)    as std_min   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smin, noquote))",
15391 +                mean(max1)   as max       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmax, noquote))",
15392 +                std(max1)    as std_max   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smax, noquote))"
15393 +            from &inDS(rename=(mean=mean1 sum=sum1 min=min1 max=max1))
15394 +                group by &TSVar, &crossIDVar
15395 +                order by &TSVar, &crossIDVar
15396 +        ;
15397 +    quit;
15398 +%mend;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
15399 +/*
15400 +       MACRO: TS Utility macros
15402 +       PURPOSE: TS Utility macros
15403 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
15405 +       HISTORY:
15406 +       NOTE:
15408 +*/
15410 +/*
15411 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
15412 +                          timeid=, timeformat=, timeinformat=);
15413 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
15415 +    %do;
15416 +    %let m_data      = &data;
15417 +    %let m_decdata   = &decdata;
15418 +    %let m_decmeta   = &decmeta;
15419 +    %let m_cmeta     = &cmeta;
15420 +    %let m_outfile   = &outfile;
15421 +    %let m_crossid   = &crossid;
15422 +    %let m_timeid    = &timeid;
15423 +    %let m_timeformat    = &timeformat;
15424 +    %let m_timeinformat    = &timeinformat;
15425 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
15426 +  %end;
15427 +%mend EM_TS_CreateTsMetaDs;
15428 +*/
15429 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
15430 +proc sql;
15431 +      create table _tmp_inds
15432 +      as select distinct &timeid from  &indata;
15433 +quit;
15434 +run;
15435 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
15436 +  id &timeid
15437 +%if &timeinterval ne %then %do;
15438 +    %if &timeformattype eq DATE %then %do;
15439 +        interval=&timeinterval
15440 +    %end;
15441 +    %else %if &timeformattype eq DATETIME  %then %do;
15442 +        %let dttimeinterval= DT&timeinterval;
15443 +         interval=&dttimeinterval
15444 +    %end;
15445 +%end;
15446 +;
15447 +run;
15449 +data &outds;
15450 +     set _tmp_tsmeta;
15451 +     format START &timeformat;
15452 +     format END &timeformat;
15453 +     length APPLY_START_END $8;
15454 +     APPLY_START_END ="No";
15455 +     FORMAT = "&timeformat";
15456 +     ROLE ="TIMEID";
15457 +     rename TIMEID = NAME;
15458 +     rename SEASONALITY= LengthOfCycle;
15459 +     rename INTERVAL = TIMEINTERVAL ;
15460 +     rename FORMAT = TIMEFORMAT;
15461 +     output;
15462 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
15463 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
15464 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
15465 +run;
15467 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
15468 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
15470 +%mend EM_TS_CreateTSMetaData;
15474 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
15476 +/* if updated = Y it will pass the TSMETA created by just the previous node */
15478 +%let _tsmetads = ;
15480 +%if &updated = Y %then %do;
15481 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
15482 +%if %sysfunc(exist(&_tsmetads)) %then %do;
15483 +%goto endline;
15484 +%end;
15485 +%end;
15487 +%if &eminfodata eq %then %do;
15488 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
15489 +    data &EM_DATA_EMINFO;
15490 +         set &EM_IMPORT_DATA_EMINFO;
15491 +    run;
15492 +%end;
15493 +%else %do;
15494 +    %let dsid=%sysfunc(open(&eminfodata));
15495 +    data &EM_DATA_EMINFO;
15496 +         set &eminfodata;
15497 +    run;
15498 +%end;
15499 +%if &dsid > 0 %then %do;
15500 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
15501 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
15502 +    %do %while(^ %sysfunc(fetch(&dsid)));
15503 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
15504 +         %if &_key eq TSMETA %then %do;
15505 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
15506 +         %end;
15507 +    %end;
15508 +    %let dsid = %sysfunc(close(&dsid));
15509 +%end; /* the end of %if &dsid > 0 %then %do; */
15511 +%endline:
15513 +%if &_tsmetads ne %then %do;
15514 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
15515 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
15516 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
15517 +         data &EM_USER_TSMETA;
15518 +                   set &_tsmetads;
15519 +         run;
15520 +    %end;
15521 +%end;
15523 +*proc print data=&EM_DATA_EMINFO;
15524 +*proc print data=&EM_IMPORT_DATA_EMINFO;
15525 +*run;
15526 +%MEND EM_TS_GETTSMETA;
15529 +/*
15530 +%macro EM_GETTSMETAVARS(TimeInterval=);
15531 +%global &TimeInterval;
15532 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
15533 +%if &dsid > 0 %then %do;
15534 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
15535 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
15536 +%do %while(^ %sysfunc(fetch(&dsid)));
15537 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15538 +     %if &_role eq TIMEID %then %do;
15539 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
15540 +     %end;
15541 +%end;
15542 +%let dsid = %sysfunc(close(&dsid));
15543 +%end;
15544 +%MEND EM_GETTSMETAVARS;
15545 +*/
15546 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
15547 +%global &TimeInterval;
15548 +%global &TimeId;
15549 +%global &EndTime;
15550 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
15551 +proc print data=&EM_USER_TSMETA;
15552 +run;
15553 +%if &dsid > 0 %then %do;
15554 +%if &TimeInterval ne %then %do;
15555 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
15556 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
15557 +    %do %while(^ %sysfunc(fetch(&dsid)));
15558 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15559 +        %if &_role eq TIMEID %then %do;
15560 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
15561 +        %end;
15562 +     %end;
15563 +%end;
15564 +%if &TimeId ne %then %do;
15565 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
15566 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
15567 +    %do %while(^ %sysfunc(fetch(&dsid)));
15568 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15569 +        %if &_role eq TIMEID %then %do;
15570 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
15571 +        %end;
15572 +    %end;
15573 +%end;
15575 +%if &EndTime ne %then %do;
15576 +    %let vn_end =%sysfunc(varnum(&dsid, END));
15577 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
15578 +    %do %while(^ %sysfunc(fetch(&dsid)));
15579 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15580 +        %if &_role eq TIMEID %then %do;
15581 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
15582 +        %end;
15583 +     %end;
15584 +%end;
15585 +%let dsid = %sysfunc(close(&dsid));
15586 +%end;
15587 +%MEND EM_TS_GETTSMETAVARS;
15591 +/*------------------------------------------------------------------
15593 +      Macro EM_GETTSIDMAP
15595 +------------------------------------------------------------------+*/
15598 +%macro EM_TS_GETTSIDMAP(updated=);
15600 +%let _tsidmap = ;
15602 +%if &updated = Y %then %do;
15603 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
15604 +%if %sysfunc(exist(&_tsidmap)) %then %do;
15605 +%goto endline;
15606 +%end;
15607 +%end;
15609 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
15610 +%if &dsid > 0 %then %do;
15611 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
15612 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
15613 +%do %while(^ %sysfunc(fetch(&dsid)));
15614 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
15615 +     %if &_key eq TSIDMAP %then %do;
15616 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
15617 +     %end;
15618 +%end;
15620 +%let dsid = %sysfunc(close(&dsid));
15621 +%end;
15623 +%endline:
15625 +%if &_tsidmap ne %then %do;
15627 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
15628 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
15630 +%if %sysfunc(exist(&_tsidmap)) %then %do;
15631 +         data &EM_USER_TSIDMAP;
15632 +               set &_tsidmap;
15633 +         run;
15634 +    %end;
15635 +%end;
15636 +%MEND EM_TS_GETTSIDMAP;
15638 +/*------------------------------------------------------------------*/
15643 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
15644 +%global &value;
15647 +%let dsid = %sysfunc(open(&data));
15648 +%if &dsid > 0 %then %do;
15649 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
15650 +    %if &vn_var < 1 %then %do;
15651 +        %let &value = 0;
15652 +        %let dsid = %sysfunc(close(&dsid));
15653 +        %goto endline;
15654 +    %end;
15655 +%let dsid = %sysfunc(close(&dsid));
15656 +%end;
15658 +%let _tmp=_tmpDS;
15659 +proc means data=&data &stat;
15660 +     var &var;
15661 +     output out=&_tmp;
15662 +run;
15664 +%let dsid = %sysfunc(open(&_tmp));
15665 +%if &dsid > 0 %then %do;
15666 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
15667 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
15668 +     %do %while(^%sysfunc(fetch(&dsid)));
15669 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
15670 +         %if &_stat eq &stat %then %do;
15671 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
15672 +          %end;
15673 +      %end;
15674 +%let dsid = %sysfunc(close(&dsid));
15675 +%end;
15676 +proc datasets lib=work nolist;
15677 + delete &_tmp;
15678 +run;
15679 +%endline:
15680 +%MEND EM_TS_GET_STAT;
15683 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
15684 +%global &format;
15685 +%global &informat;
15686 +%let dsid = %sysfunc(open(&data));
15687 +%if &dsid > 0 %then %do;
15688 +%let vn_var =%sysfunc(varnum(&dsid, &var));
15689 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
15690 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
15691 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
15692 +%end;
15693 +%let dsid = %sysfunc(close(&dsid));
15694 +%end;
15695 +%MEND EM_TS_GET_VAR_FORMAT;
15697 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
15698 +      %if &lib eq %then %let lib=work;
15699 +       proc datasets lib=&lib nolist;
15700 +              delete &dsname;
15701 +       run;
15702 +%Mend  EM_TS_DELETE_DATA;
15705 +%macro EM_TS_GetNObs(inds=, nobs=);
15706 +    %global &nobs;
15707 +    %let &nobs=0;
15708 +    data _null_;
15709 +        set &inds end=eof;
15710 +        if eof then call symput("&nobs", _N_);
15711 +    run;
15712 +    quit;
15714 +    /*
15715 +    %let dsid=%sysfunc(open(&outdata));
15716 +    %if dsid > 0 %then %do;
15717 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
15718 +        %let dsid = %sysfunc(close(&dsid));
15719 +     %end;
15720 +    */
15721 +%mend  EM_TS_GetNObs;
15724 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
15725 +%global &time1;
15726 +%global &time2;
15727 +%if &default = Y %then %do;
15728 +   data _null_;
15729 +        set &data end=eof;
15730 +        if _N_ = 1 then  call symput("&time1", DATE);
15731 +        if eof then call symput("&time2", DATE);
15732 +    run;%end;
15733 +%else %do;
15734 +    %let dsid = %sysfunc(open(&data));
15735 +    %if &dsid > 0 %then %do;
15736 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
15737 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
15738 +        %do %while(^%sysfunc(fetch(&dsid)));
15739 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
15740 +             %if &_index eq 1 %then %do;
15741 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
15742 +             %end;
15743 +             %if &_index eq 2 %then %do;
15744 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
15745 +             %end;
15746 +        %end;
15747 +    %let dsid = %sysfunc(close(&dsid));
15748 +    %end;
15749 +%end;
15751 +%MEND EM_TS_GET_TIME_VALUES;
15753 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
15754 +%global &exist;
15755 + %let &exist = N;
15756 +%let dsid = %sysfunc(open(&data));
15757 +%if &dsid > 0 %then %do;
15758 +%let vn_var =%sysfunc(varnum(&dsid, &var));
15759 +%if &vn_var > 0 %then %do;
15760 +    %let &exist = Y;
15761 +%end;
15762 +%let dsid = %sysfunc(close(&dsid));
15763 +%end;
15764 +%MEND EM_TS_GET_VAR_EXIST;
15767 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
15768 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
15769 +      set &intreedata;
15770 +        LENGTH NodeType $32;
15771 +      if _PARENT_ eq " " then delete;
15772 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
15773 +        else NodeType = "CLUSTER";
15774 +        LinkID = _N_;
15775 +run;
15776 +%Mend EM_TS_MakeConstellPlotData;
15781 +%macro EM_TS_CreateIDMap(
15782 +/*-------------------------------------------------------------------------*/
15783 +/*---   Written by Xiangxiang Meng                                         */
15784 +/*-------------------------------------------------------------------------*/
15785 +inDS          =,      /* imported data set in TS data mining               */
15786 +outIDMap      =,      /* output data set of TS ID map                      */
15787 +outDS         =,      /* output data set of TS and TS ID merged            */
15788 +variableSet   =,      /* EM variable set                                   */
15789 +TSIDbyCrossID =Y,
15790 +inEM          =Y
15791 +/*-------------------------------------------------------------------------*/
15792 +);
15794 +%global EM_TS_ERR;
15795 +%let EM_TS_ERR = 0;
15797 +%if &inEM eq Y %then %do;
15798 +    %let num_crossIDVar = &EM_NUM_CROSSID;
15799 +    proc sql noprint;
15800 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
15801 +    quit;
15802 +%end;
15803 +%else %do;
15804 +    proc sql noprint;
15805 +         select count(*) into :num_crossIDVar from &variableSet
15806 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
15807 +         ;
15808 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
15809 +         ;
15810 +    quit;
15811 +    %let num_crossIDVar=&num_crossIDVar;
15812 +%end;
15814 +* see if _TSID_ exists;
15816 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
15817 +run;
15819 +proc sql noprint;
15820 +    select count(*) into :has_TSID
15821 +        from _emtscm_contents
15822 +        where upcase(strip(name)) eq '_TSID_'
15823 +    ;
15824 +quit;
15826 +/*-------------------------------------------------------------------------*/
15827 +* Creating TSID map..;
15828 +/*-------------------------------------------------------------------------*/
15830 +%if (&num_crossIDVar gt 0) %then %do;
15832 +    data _emtscm_tmpIDMap;
15833 +        set &variableSet;
15834 +        where  (upcase(strip(level)) eq 'INTERVAL')
15835 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
15836 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
15837 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
15838 +          );
15839 +        _emts_dummy=1;
15840 +        keep name label role _emts_dummy;
15841 +    run;
15843 +    proc sql noprint;
15844 +        * create a string of crossID variable like A,B,C,D..;
15845 +        select distinct name into :crossIDVar separated by ','
15846 +            from &variableSet
15847 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
15848 +            order by name
15849 +        ;
15850 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
15851 +            from &variableSet
15852 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
15853 +            order by name
15854 +        ;
15855 +        * create the TSID map data set;
15856 +        create table _emtscm_tmp1 as
15857 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
15858 +        ;
15859 +        * create a level list of cross ID variables and time series variables;
15860 +        create table &outIDMap as
15861 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
15862 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
15863 +            where a._emts_dummy eq b._emts_dummy
15864 +            order by a.name, &crossIDVar
15865 +        ;
15866 +    quit;
15868 +    %if &TSIDbyCrossID = Y %then %do;
15869 +        * create unique TSID only by Cross ID;
15870 +        data &outIDMap;
15871 +            length _TSID_ 8;
15872 +            set &outIDMap;
15873 +            by _NAMEID_;
15874 +            if first._NAMEID_
15875 +                then _TSID_=1;
15876 +                else _TSID_+1;
15877 +        run;
15878 +        %if "&outDS" ne "" %then %do;
15879 +            * merge TSID into &inDS;
15880 +            proc sql noprint;
15881 +                create table &outDS as
15882 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
15883 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
15884 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
15885 +                        where %do i = 1 %to &num_crossIDVar;
15886 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
15887 +                              %end;
15888 +                             b._TSID_ is not missing
15889 +                    order by b._TSID_, a.&timeIDVar
15890 +                ;
15891 +            quit;
15892 +        %end;
15893 +    %end;
15894 +    %else %do;
15895 +        * create unique TSID by Cross ID and _NAMEID_;
15896 +        data &outIDMap;
15897 +            length _TSID_ 8;
15898 +            set &outIDMap;
15899 +            _TSID_=_n_;
15900 +        run;
15901 +        %if "&outDS" ne "" %then %do;
15902 +            *no merge in this output;
15903 +            data &outDS;
15904 +                set &inDS;
15905 +            run;
15906 +        %end;
15907 +    %end;
15909 +    proc sort data=&outIDMap;
15910 +        by _NAMEID_ _TSID_;
15911 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
15912 +        format _TSID_ best12. _NAMEID2_ $40.;
15913 +        set &outIDMap;
15914 +        by _NAMEID_;
15915 +        if first._NAMEID_
15916 +            then _emts_ind=1;
15917 +            else _emts_ind+1;
15918 +        drop _emts_ind;
15919 +        rename _NAMEID_=_VARNAME_;
15920 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
15921 +        if _labelID_ eq ' '
15922 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
15923 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
15924 +    run;
15926 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
15928 +%end;
15929 +%else %do; /* if no crossid's the nameid needs to be created */
15931 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
15932 +        length _TSID_ 8;
15933 +        set &variableSet;
15934 +        where  (upcase(strip(level)) eq 'INTERVAL')
15935 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
15936 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
15937 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
15938 +          );
15939 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
15940 +        rename ROLE = _ROLE_;
15941 +        _NAMEID_=strip(name);
15942 +        _VARNAME_=strip(name);
15943 +        if label eq ' '
15944 +            then _LABELID_ = strip(name);
15945 +            else _LABELID_ = strip(label);
15946 +        _TSID_=_n_;
15947 +    run;
15949 +    %if "&outDS" ne "" %then %do;
15950 +        *no merge in this output;
15951 +        data &outDS;
15952 +            set &inDS;
15953 +        run;
15954 +    %end;
15955 +%end;
15957 +data &outIDMap;
15958 +    set &outIDMap;
15959 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
15960 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
15961 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
15962 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
15963 +run;
15965 +proc datasets lib=work nolist;
15966 +    delete _emtscm_:;
15967 +run; quit;
15969 +%mend EM_TS_createIDMap;
15971 +%macro EM_TS_CreateMetaData(
15972 +/*-------------------------------------------------------------------------*/
15973 +  inDS          =,      /* imported data set in TS data mining             */
15974 +  outDS         =,      /* output data set of TS metadata                  */
15975 +  variableSet   =,      /* EM variable set                                 */
15976 +  timeInterval  =,      /* time interval                                   */
15977 +  rc            =       /* return code                                     */
15978 +/*-------------------------------------------------------------------------*/
15979 +);
15981 +%if %eval(
15982 +      &EM_NUM_BINARY_INPUT   +
15983 +      &EM_NUM_ORDINAL_INPUT  +
15984 +      &EM_NUM_NOMINAL_INPUT  +
15985 +      &EM_NUM_BINARY_REJECTED   +
15986 +      &EM_NUM_ORDINAL_REJECTED  +
15987 +      &EM_NUM_NOMINAL_REJECTED  +
15988 +      &EM_NUM_ORDINAL_TARGET  +
15989 +      &EM_NUM_NOMINAL_TARGET +
15990 +      &EM_NUM_BINARY_TARGET
15991 +      ) > 0
15992 +%then %do;
15993 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
15994 +        %put &em_codebar;
15995 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
15996 +        %put &errormsg;
15997 +        %put &em_codebar;
15998 +        %goto ENDLINE;
15999 +%end;
16001 +%global EM_TS_ERR;
16002 +%let EM_TS_ERR = 0;
16004 +%if &timeInterval eq AUTO
16005 +    %then %let timeInterval  = ;
16006 +    %else %let timeInterval  = %upcase(&timeInterval);
16008 +/*-------------------------------------------------------------------------*/
16009 +* check time ID variable;
16010 +/*-------------------------------------------------------------------------*/
16012 +* number of variables in the Variableset with ROLE=TIMEID;
16013 +proc sql noprint;
16014 +    select count(*) into :num_timeID from &variableset
16015 +        where upcase(role) eq 'TIMEID';
16016 +quit;
16018 +/*-------------------------------------------------------------------------*/
16019 +* process only when there is one Time ID, otherwise exception message;
16020 +/*-------------------------------------------------------------------------*/
16022 +%if &num_timeID eq 0 %then %do;
16024 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
16025 +    %let EM_TS_ERR = 11;
16026 +    %put &em_codebar;
16027 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
16028 +    %put &errormsg;
16029 +    %put &em_codebar;
16030 +    %goto tscm_endline;
16032 +%end;
16033 +%else %if &num_timeID gt 1 %then %do;
16035 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
16036 +    %let EM_TS_ERR = 12;
16037 +    %put &em_codebar;
16038 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
16039 +    %put &errormsg;
16040 +    %put &em_codebar;
16041 +    %goto tscm_endline;
16043 +%end;
16044 +%else %do;
16045 +    *** proceed when there is one Time ID;
16047 +    data _null_;
16048 +        set &variableset(where=(upcase(role)='TIMEID'));
16049 +        call symput('timeIDFormat',     strip(format));
16050 +        call symput('timeID',           strip(upcase(name)      ));
16051 +        call symput('timeIDLevel',      strip(upcase(level))     );
16052 +        call symput('timeIDFormatType', strip(upcase(formattype)));
16053 +    run;
16055 +    *** exception message if the time ID is not an interval variable;
16056 +    %if &timeIDLevel ne INTERVAL %then %do;
16057 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
16058 +        %let EM_TS_ERR = 13;
16059 +        %put &em_codebar;
16060 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
16061 +        %put &errormsg;
16062 +        %put &em_codebar;
16063 +        %goto tscm_endline;
16064 +    %end;
16066 +    %if (&timeIDFormatType ne DATETIME) and
16067 +        (&timeIDFormatType ne DATE) and
16068 +        (&timeIDFormatType ne TIME) and
16069 +        (&timeIDFormatType ne USER)
16070 +    %then %do;
16071 +        *** sequential format-type of time ID;
16073 +        %let timeInterval = DAY;
16074 +        %let timeIDFormatType = SEQ;
16076 +        proc sql noprint;
16077 +            create table _emtscm_inds as
16078 +                 select distinct &timeID from &inDS(keep=&timeID)
16079 +                 where &timeID is not missing;
16080 +            select count(*) into :num_nonInteger from _emtscm_inds
16081 +                where &timeID ne int(&timeID);
16082 +        quit;
16084 +        %if &num_nonInteger gt 0 %then %do;
16085 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
16086 +            %let EM_TS_ERR = 14;
16087 +            %put &em_codebar;
16088 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
16089 +            %put &errormsg;
16090 +            %put &em_codebar;
16091 +            %goto tscm_endline;
16092 +        %end;
16093 +    %end;
16094 +    %else %do;
16095 +        *** date, datetime, time format-type of time ID;
16097 +        *** must have a format;
16098 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
16099 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
16100 +            %let EM_TS_ERR = 15;
16101 +            %put &em_codebar;
16102 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
16103 +            %put &errormsg;
16104 +            %put &em_codebar;
16105 +            %goto tscm_endline;
16106 +        %end;
16108 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
16109 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
16110 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
16111 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
16112 +                %let EM_TS_ERR = 16;
16113 +                %put &em_codebar;
16114 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
16115 +                %put &errormsg;
16116 +                %put &em_codebar;
16117 +                %goto tscm_endline;
16118 +            %end;
16119 +        %end;
16121 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
16122 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
16123 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
16124 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
16125 +                %let EM_TS_ERR = 17;
16126 +                %put &em_codebar;
16127 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
16128 +                %put &errormsg;
16129 +                %put &em_codebar;
16130 +                %goto tscm_endline;
16131 +            %end;
16132 +        %end;
16134 +        *** the AUTO function is currently turned off for TIME timeID variable;
16135 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
16136 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
16137 +            %let EM_TS_ERR = 18;
16138 +            %put &em_codebar;
16139 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
16140 +            %put &errormsg;
16141 +            %put &em_codebar;
16142 +            %goto tscm_endline;
16143 +        %end;
16145 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
16146 +            %then %let timeInterval =DT&timeInterval;
16148 +        proc sql noprint;
16149 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
16150 +                where &timeID is not missing;
16151 +        quit;
16152 +    %end;
16154 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
16155 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
16156 +    run;
16158 +    %let hasValidInterval = 0;
16159 +    %let hasLengthOne     = 0;
16161 +    proc sql noprint;
16162 +        create table _emtscm_label as
16163 +            select name,label
16164 +            from dictionary.columns
16165 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
16166 +        ;
16167 +        create table _emtscm_meta2 as
16168 +            select a.*, b.label
16169 +            from _emtscm_meta as a, _emtscm_label as b
16170 +            where upcase(a.timeID) eq upcase(b.name)
16171 +        ;
16172 +    quit;
16174 +    data &outDS;
16175 +        set _emtscm_meta2;
16176 +        format
16177 +            timeformat      $30.
16178 +            role            $10.
16179 +            start           &timeIDformat
16180 +            end             &timeIDformat
16181 +            apply_start_end $8.
16182 +        ;
16183 +        rename
16184 +            timeID      = name
16185 +            seasonality = lengthOfCycle
16186 +            interval    = timeinterval
16187 +        ;
16188 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
16190 +        role            = "TIMEID";
16191 +        apply_start_end = 'N';
16192 +        timeformat      = symget('timeIDformat');
16193 +        timeformattype  = symget('timeIDformatType');
16195 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
16196 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
16197 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
16198 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
16199 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
16200 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
16201 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
16202 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
16203 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
16204 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
16206 +        if timeformattype eq 'SEQ' then do;
16207 +            timeformat='BEST12.';
16208 +            seasonality=1;
16209 +        end;
16211 +        call symput('_tinterval',interval);
16213 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
16215 +        if upcase(timeformattype) eq 'DATE' and
16216 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
16217 +            then call symput('hasValidInterval',1);
16219 +        if upcase(timeformattype) eq 'DATETIME' and
16220 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
16221 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
16222 +            then call symput('hasValidInterval',1);
16224 +        if upcase(timeformattype) eq 'TIME' and
16225 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
16226 +            then call symput('hasValidInterval',1);
16228 +        if upcase(timeformattype) eq 'SEQ'
16229 +            then call symput('hasValidInterval',1);
16231 +        if upcase(timeformattype) eq 'USER'
16232 +            then call symput('hasValidInterval',1);
16234 +        if start eq end
16235 +            then call symput('hasLengthOne',1);
16236 +    run;
16238 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
16240 +    *** detect any missing time interval after running PROC TIMEID;
16241 +    %if &_tinterval eq %then %do;
16242 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
16243 +        %let EM_TS_ERR = 19;
16244 +        %put &em_codebar;
16245 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
16246 +        %put &errormsg;
16247 +        %put &em_codebar;
16248 +        %goto tscm_endline;
16249 +    %end;
16251 +    *** detect any missing time interval after running PROC TIMEID;
16252 +    %if &hasValidInterval eq 0 %then %do;
16253 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
16254 +        %let EM_TS_ERR = 20;
16255 +        %put &em_codebar;
16256 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
16257 +        %put &errormsg;
16258 +        %put &em_codebar;
16259 +        %goto tscm_endline;
16260 +    %end;
16262 +    %if &hasLengthOne eq 1 %then %do;
16263 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
16264 +        %let EM_TS_ERR = 21;
16265 +        %put &em_codebar;
16266 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
16267 +        %put &errormsg;
16268 +        %put &em_codebar;
16269 +        %goto tscm_endline;
16270 +    %end;
16272 +%end;
16274 +%tscm_endline:;
16276 +%mend EM_TS_CreateMetaData;
16279 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
16281 +data _null_;
16282 +    set &tsmeta;
16283 +    call symput('_timeidFormatType', timeformattype);
16284 +    call symput('_timeid', strip(name));
16285 +    call symput('_seqstartnum',strip(put(start,best12.)));
16286 +run;
16288 +proc contents data=&inDS noprint
16289 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
16290 +run; quit;
16292 +data _null_;
16293 +    set _emts_tmpp1;
16294 +    call symput('_timeIDlabel',label);
16295 +run;
16297 +%if &_timeidFormatType eq SEQ
16298 +%then %do;
16299 +    proc sql noprint;
16300 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
16301 +    quit;
16302 +    %let _dummystarttime=&_dummystarttime;
16304 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
16305 +        set &inDS;
16306 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
16307 +        drop &_timeid;
16308 +        label _tsdp_tmpID = "&_timeIDlabel";
16310 +    run;
16311 +%end;
16313 +%mend;
16315 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
16317 +data _null_;
16318 +    set &tsmeta;
16319 +    call symput('_timeidFormatType', timeformattype);
16320 +    call symput('_timeidFormat', timeformat);
16321 +    call symput('_timeid', strip(name));
16322 +    call symput('_timeinterval',strip(upcase(timeinterval)));
16323 +run;
16325 +/* manually change time ID format to a longer enough time format */
16326 +/* because proc timeid returns time5. for second time interval */
16327 +/* which is not long enough for transpose with time unit as seconds */
16328 +%if &_timeinterval eq SECOND
16329 +%then %do;
16330 +    %let _timeIDformat = %str(time8.);
16331 +%end;
16333 +proc contents data=&inDS noprint
16334 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
16335 +run; quit;
16337 +data _null_;
16338 +    set _emts_tmpp1;
16339 +    call symput('_timeIDlabel',label);
16340 +run;
16342 +%if &_timeidFormatType eq TIME
16343 +%then %do;
16344 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
16345 +        set &inDS;
16346 +        _tsdp_tmpID = timepart(&_timeID);
16347 +        format _tsdp_tmpID &_timeidFormat;
16348 +        label  _tsdp_tmpID = "&_timeIDlabel";
16349 +        drop &_timeid;
16350 +    run;
16351 +%end;
16353 +%mend;
16355 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
16357 + proc sql noprint;
16358 +     create table _tmptimetable as
16359 +         select distinct &timeidvar as DATE from &inDS
16360 +         where &timeIDVar is not missing
16361 +         order by &timeIDVar;
16362 + quit;
16364 +%if &compare eq Y %then %do;
16365 +    * compare with the existing time table;
16366 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
16367 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
16368 +    run;
16370 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
16372 +    %if &_diffobs > 0 %then %do; /* create it again */
16373 +        data &outDS(keep=DATE _INDEX_);
16374 +            set _tmptimetable end = _eof_;
16375 +            if _N_ = 1
16376 +                then _INDEX_ = 1;
16377 +                else _INDEX_ = 0;
16378 +            if _eof_ then _INDEX_= 2;
16379 +        run;
16380 +    %end;
16382 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
16383 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
16384 +%end;
16385 +%else %do;
16386 +    * create a new time table directly;
16387 +    data &outDS(keep=DATE _INDEX_);
16388 +        set _tmptimetable end = _eof_;
16389 +        if _N_ = 1
16390 +            then _INDEX_ = 1;
16391 +            else _INDEX_ = 0;
16392 +        if _eof_ then _INDEX_= 2;
16393 +    run;
16395 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
16396 +%end;
16398 +* assign a defult format BEST12. for sequential time ID;
16400 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
16402 +%let _nodatefmt=N;
16404 +data _null_;
16405 +    set _tmpcontents;
16406 +    where upcase(name) eq 'DATE';
16407 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
16408 +run;
16410 +%if "&_nodatefmt" eq "Y" %then %do;
16411 +    data &outDS;
16412 +        set &outDS;
16413 +        format date best12.;
16414 +    run;
16415 +%end;
16417 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
16419 +%mend;
16423 +%macro EM_TS_Transpose(
16424 +/*-------------------------------------------------------------------------*/
16425 +  inDS          =,      /* imported data set in TS data mining             */
16426 +  inIDMap       =,      /* input TS ID map                                 */
16427 +  variableSet   =,      /* variable set                                    */
16428 +  transposeBy   =,      /* byTSID or byTimeID                              */
16429 +  outDS         =,      /* output transposed data set                      */
16430 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
16431 +  inEM          =Y,
16432 +  timePrefix    =_T
16433 +/*-------------------------------------------------------------------------*/
16434 +);
16436 +%let timePrefix = &timePrefix;
16438 +%if  &EM_NUM_CROSSID > 0 %then %do;
16440 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
16441 +    set &inIDMap;
16442 +    drop _NAMEID_;
16443 +    run;
16444 +%let inIDMap=_emtstp_map0;
16446 +%end;
16448 +proc sql noprint;
16449 +    * number of TS Variables to be transposed;
16450 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
16451 +    ;
16452 +    * number of TS Variables to be transposed;
16453 +    select max(_TSID_) into :num_TSID from &inIDMap
16454 +    ;
16455 +    * name list of TS Variables;
16456 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
16457 +        from &inIDMap
16458 +        order by _NAMEID_
16459 +    ;
16460 +    * total number of time series =max(_TSID_)*&num_TSVar;
16461 +    * and the number of digits of this variable is &num_digits;
16462 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
16463 +        from &inIDMap
16464 +    ;
16465 +      * Time ID variable;
16466 +    select name into:timeIDVar from &variableset
16467 +        where upcase(role) eq 'TIMEID'
16468 +    ;
16469 +quit;
16470 +%let num_digits = &num_digits;
16471 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
16473 +/*-------------------------------------------------------------------------*/
16475 +* get number of cross IDs and also the TIME ID variable name;
16476 +%if &inEM eq Y %then %do;
16477 +    %let num_crossIDVar = &EM_NUM_CROSSID;
16478 +    %let crossIDVar     = %EM_CROSSID;
16479 +%end;
16480 +%else %do;
16481 +    proc sql noprint;
16482 +        * number of cross ID;
16483 +        select count(*) into :num_crossIDVar
16484 +            from &variableSet
16485 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16486 +        ;
16487 +        * create a string of crossID variable like A B C D..;
16488 +        select distinct name into :crossIDVar separated by ' '
16489 +            from &variableSet
16490 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16491 +            order by name
16492 +        ;
16493 +    quit;
16494 +    %let num_crossIDVar=&num_crossIDVar;
16495 +%end;
16497 +/*-------------------------------------------------------------------------*/
16499 +%if (&num_crossIDVar gt 0) %then %do;
16501 +    data _emtstp_tmpDat;
16502 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
16503 +        _NAMEID_ = cats("_TS_",_TSID_);
16504 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
16505 +    run;
16507 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
16509 +        * update the ID maps;
16510 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
16511 +            by _NAMEID_ _TSID_;
16512 +        data &outIDMap;
16513 +            set _emtstp_tmpmap;
16514 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
16515 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
16516 +        run;
16518 +        * get the names for the new variables;
16519 +        proc sql noprint;
16520 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
16521 +            ;
16522 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
16523 +            ;
16524 +        quit;
16526 +        * data must be sorted before transposed;
16527 +        proc sort data=_emtstp_tmpDat;
16528 +            by &timeIDvar;
16529 +        run;
16531 +        %do i = 1 %to &num_TSVar;
16532 +            %let i = &i;
16533 +            * transpose one cross-type time series data by TSID;
16534 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
16535 +                id _NAMEID_;
16536 +                by &timeIDVar;
16537 +                var &&&TSVar&i;
16538 +            run;
16539 +        %end;
16541 +        * merge all vertical time series, rename and label them;
16542 +        data &outDS;
16543 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
16544 +            by &timeIDVar;
16545 +            rename
16546 +                %do i = 1 %to &num_TSVar;
16547 +                    %do j = 1 %to &num_TSID;
16548 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
16549 +                        /* %put &i &j &num1 &num_TSID; */
16550 +                        _V_&i._TS_&j = &&&tsname&num1
16551 +                    %end;
16552 +                %end;
16553 +            ;
16554 +            label
16555 +                %do i = 1 %to &num_TSVar;
16556 +                    %do j = 1 %to &num_TSID;
16557 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
16558 +                        /* %put &i &j &num1 &num_TSID; */
16559 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
16560 +                    %end;
16561 +                %end;
16562 +            ;
16563 +        run;
16564 +    %end;
16565 +    %else %do;
16567 +        * update the ID maps;
16568 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
16569 +            by _NAMEID_ _TSID_;
16570 +        data &outIDMap;
16571 +            set _emtstp_tmpmap;
16572 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
16573 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
16574 +        run;
16576 +        proc sql noprint;
16577 +            * get the roles for the new variables;
16578 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
16579 +                from &inIDMap
16580 +                order by _NAMEID_
16581 +            ;
16582 +            * get the length of the time series;
16583 +            select count(distinct &timeIDvar) into :num_T
16584 +                from _emtstp_tmpDat
16585 +            ;
16586 +        quit;
16588 +        * data must be sorted before transposed;
16589 +        proc sort data=_emtstp_tmpDat;
16590 +            by _TSID_ &crossIDVar &timeIDvar;
16591 +        run;
16593 +        %do i = 1 %to &num_TSVar;
16594 +            %let i = &i;
16595 +            * transpose one cross-type time series data by TIMEID;
16596 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
16597 +                by _TSID_ &crossIDVar;
16598 +                var &&&TSVar&i;
16599 +            run;
16600 +        %end;
16602 +        * stack all horizontal time series;
16603 +        data &outDS;
16604 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
16605 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
16606 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
16607 +            %do i=1 %to &num_TSVar;
16608 +                if in&i then do;
16609 +                    _NAMEID_ ="&&&TSVar&i";
16610 +                    _ROLE_   ="&&&TSRole&i";
16611 +                end;
16612 +            %end;
16613 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
16614 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
16615 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
16616 +        run;
16617 +    %end;
16618 +%end;
16619 +%else %do;
16621 +    proc sql noprint;
16622 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
16623 +            order by _NAMEID_
16624 +        ;
16625 +    quit;
16627 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
16628 +        * transpose the panel-type time series data by TSID;
16629 +        proc sort data=&inDS out=_emtstp_tmpDat;
16630 +            by &timeIDvar;
16631 +        proc transpose data=_emtstp_tmpDat
16632 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
16633 +            by &timeIDVar;
16634 +            var &panelTSVar;
16635 +        run;
16636 +        proc datasets lib=work nolist;
16637 +            modify _emtstp_tmpDat2;
16638 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
16639 +            run; quit;
16640 +    %end;
16641 +    %else %do;
16642 +        * transpose the panel-type time series data by TIMEID;
16643 +        proc sort data=&inDS out=_emtstp_tmpDat;
16644 +            by &timeIDvar;
16645 +        data _emtstp_tmpDat;
16646 +            set _emtstp_tmpDat;
16647 +            _tmp_ind=_n_;
16648 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
16649 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
16650 +            ID _tmp_ind;
16651 +            var &panelTSVar;
16652 +        run;
16653 +    %end;
16655 +      * merge ID maps to the transpose data set;
16656 +      proc sql noprint;
16657 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
16658 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
16659 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
16660 +          ;
16661 +      quit;
16663 +      * update the TS ID map;
16664 +      data &outIDMap;
16665 +          set &inIDMap;
16666 +      run;
16667 +%end;
16669 +proc datasets lib=work nolist;
16670 +    delete _emtstp:;
16671 +run; quit;
16673 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_TRAIN.SOURCE.
16675 +/*-----------------------------------------------------------------------------------+
16676 + |
16677 + |   Title :
16678 + |   Data Preparation Node for Time Series Data Mining
16679 + |
16680 + |   support : Taiyeong Lee(Taiyeong.Lee@sas.com)
16681 +               Ruiwen Zhang(Ruiwen.Zhang@sas.com)
16682 + |
16683 + |   Notes:
16684 + +-----------------------------------------------------------------------------------*/
16687 +%Macro EM_TSDP_Train;
16689 +/*---------- Check and assign the input data set --------------------------*/
16691 +%let _IMPORT_DATA  = ;
16692 +%let _IMPORT_CMETA = ;
16693 +%let _DATA_EMINFO  = ;
16694 +%let _EXPORT_DATA  = ;
16695 +%let _FILE_CDELTA  = ;
16697 +%let _timeidvar    = %EM_TIMEID;
16699 +%global EM_TS_ERR _diffobs _tsdp_t1 _tsdp_t2;
16701 +* training data has higher priority than transaction;
16702 +%if &EM_IMPORT_DATA ne  %then %do;
16703 +    %let _IMPORT_DATA  = &EM_IMPORT_DATA;
16704 +    %let _IMPORT_CMETA = &EM_IMPORT_DATA_CMETA;
16705 +    %let _DATA_EMINFO  = &EM_IMPORT_DATA_EMINFO;
16706 +    %let _EXPORT_DATA  = &EM_EXPORT_TRAIN;
16707 +    %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
16708 +%end;
16709 +%else %if &EM_IMPORT_TRANSACTION ne  %then %do;
16710 +    %let _IMPORT_DATA  = &EM_IMPORT_TRANSACTION;
16711 +    %let _IMPORT_CMETA = &EM_IMPORT_TRANSACTION_CMETA;
16712 +    %let _DATA_EMINFO  = &EM_IMPORT_TRANSACTION_EMINFO;
16713 +    %let _EXPORT_DATA  = &EM_EXPORT_TRANSACTION;
16714 +    %let _FILE_CDELTA  = &EM_FILE_CDELTA_TRANSACTION;
16715 +%end;
16716 +%else %do;
16717 +    %let  EMEXCEPTIONSTRING = exception.server.tsdm.noinputdata;
16718 +    %goto ENDLINE;
16719 +%end;
16721 +/*-------------  check time id variable -----------------------------*/
16722 +%local _numTimeIDs;
16723 +%let _numTimeIDs=0;
16725 +proc sql noprint;
16726 +    select count(*) into :_numTimeIDs
16727 +    from &EM_DATA_VARIABLESET
16728 +    where upcase(role) eq 'TIMEID' and upcase(strip(level)) eq 'INTERVAL' and upcase(strip(use)) in ('Y' 'D');
16729 +quit;
16731 +%if &_numTimeIDs eq 0 %then %do;
16733 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
16734 +    %put &em_codebar;
16735 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
16736 +    %put &errormsg;
16737 +    %put &em_codebar;
16738 +    %goto ENDLINE;
16740 +%end;
16741 +%else %if &_numTimeIDs gt 1 %then %do;
16743 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
16744 +    %put &em_codebar;
16745 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
16746 +    %put &errormsg;
16747 +    %put &em_codebar;
16748 +    %goto ENDLINE;
16750 +%end;
16752 +/*---------- Get the names of EM-registered output data sets -------------*/
16754 +%EM_GETNAME(KEY=MAPDS,           TYPE=DATA);
16755 +%EM_GETNAME(KEY=MULTBARDS,       TYPE=DATA);
16756 +%EM_GETNAME(KEY=TSMETA,          TYPE=DATA);
16757 +%EM_GETNAME(KEY=TSIDMAP,         TYPE=DATA);
16758 +%EM_GETNAME(KEY=TIMESTARTANDEND, TYPE=DATA);
16759 +%EM_GETNAME(KEY=OUTSUMMARY,      TYPE=DATA);
16760 +%EM_GETNAME(KEY=OUTSEASON,       TYPE=DATA);
16761 +%EM_GETNAME(KEY=OUTDS,           TYPE=DATA);
16763 +data &EM_DATA_EMINFO;
16764 +    length TARGET KEY $32 DATA $43;
16765 +    TARGET = "TARGET";
16767 +    KEY = "TSMETA";         DATA = "&EM_USER_TSMETA";      output;
16768 +    KEY = "TSIDMAP";        DATA = "&EM_USER_TSIDMAP";     output;
16769 +    KEY = "TSDPTRAINDS";    DATA = "&_IMPORT_DATA";        output;
16770 +    KEY = "TSDPTRAINCMETA"; DATA = "&_IMPORT_CMETA";       output;
16771 +    KEY = "TSDPVARSET";     DATA = "&EM_DATA_VARIABLESET"; output;
16773 +    %if &EM_PROPERTY_TRANSBYVAR eq BYTIMEID %then %do;
16774 +        KEY = "TSDRTRAIN";      DATA = "&_IMPORT_DATA";    output;
16775 +        KEY = "TSDRTRAINCMETA"; DATA = "&_IMPORT_CMETA";   output;
16776 +    %end;
16777 +run;
16782 +/*----- Create time series metadata ---------------------------------------*/
16784 +%EM_TS_CreateMetadata(
16785 +   inDS         = &_IMPORT_DATA,
16786 +   outDS        = &EM_USER_TSMETA,
16787 +   variableSet  = &EM_DATA_VARIABLESET,
16788 +   timeInterval = &EM_PROPERTY_TIMEINTERVAL
16789 +);
16791 +%if &EM_TS_ERR gt 0 %then %do;
16792 +    %goto endline;
16793 +%end;
16794 +%let EM_TS_ERR = 0;
16797 +/*-- Get Start time and end time from the TIMESTARTANDEND table ---*/
16798 +%if ^%sysfunc(exist(&EM_USER_TIMESTARTANDEND)) %then %do;
16799 +    %EM_TS_CreateTimeStartAndEnd(inDS=&_IMPORT_DATA, outDS=&EM_USER_TIMESTARTANDEND, timeIDVar=&_timeidvar);
16800 +%end;
16801 +%else %do;
16802 +    %if &EM_METASOURCE_CHANGED eq Y %then %do;
16803 +        %EM_TS_CreateTimeStartAndEnd(inDS=&_IMPORT_DATA, outDS=&EM_USER_TIMESTARTANDEND, timeIDVar=&_timeidvar, compare=Y);
16804 +   %end;
16805 +%end;
16807 +%if  &EM_PROPERTY_STARTENDTIME = DEFAULT %then %do;
16808 +    %EM_TS_GET_TIME_VALUES(data=&EM_USER_TIMESTARTANDEND, time1=_tsdp_time1, time2=_tsdp_time2, default=Y);
16809 +%end;
16810 +%else %do;
16811 +    %EM_TS_GET_TIME_VALUES(data=&EM_USER_TIMESTARTANDEND, time1=_tsdp_time1, time2=_tsdp_time2);
16812 +%end;
16814 +%let _tinterval        = ;
16815 +%let _seasonlength     = ;
16816 +%let _timeidformat     = ;
16817 +%let _timeidformattype = ;
16819 +data &EM_USER_TSMETA;
16820 +    set &EM_USER_TSMETA;
16821 +    length userSeasonality 8;
16822 +    label userSeasonality = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_userlencycle, noquote))";
16824 +    * if user specifies a length for seasonlity;
16825 +    if "&EM_PROPERTY_LENGTHCYCLESEL" ne "DEFAULT"
16826 +        then userSeasonality = &EM_PROPERTY_USERLENGTHCYCLE;
16827 +        else userSeasonality = lengthofcycle;
16829 +    * if user specified start/end dates;
16830 +    if "&_tsdp_time1" ne " " and "&_tsdp_time2" ne " " /*and (timeformattype ne 'SEQ')*/
16831 +    then do;
16832 +        start = "&_tsdp_time1";
16833 +        end   = "&_tsdp_time2";
16834 +        apply_start_end = 'Yes';
16835 +    end;
16837 +    * retrieve information for ts metada;
16839 +    call symput('_seasonlength',     userSeasonality);
16840 +    call symput('_tinterval',        timeinterval);
16841 +    call symput('_timeidFormat',     timeformat);
16842 +    call symput('_timeidFormatType', timeformattype);
16844 +    if timeformattype eq 'DATETIME'
16845 +    then do;
16846 +        call symput('_starttime',strip(put(start,datetime.)));
16847 +        call symput('_endtime',  strip(put(end,  datetime.)));
16848 +    end;
16849 +    else if timeformattype eq 'TIME'
16850 +    then do;
16851 +        call symput('_starttime',strip(put(start,time.)));
16852 +        call symput('_endtime',  strip(put(end,  time.)));
16853 +    end;
16854 +    else do;
16855 +        call symput('_starttime',strip(put(start,date9.)));
16856 +        call symput('_endtime',  strip(put(end,  date9.)));
16857 +    end;
16858 +run;
16860 +%let EM_PROPERTY_START        = &_StartTime;
16861 +%let EM_PROPERTY_END          = &_EndTime;
16862 +%let EM_PROPERTY_TIMEINTERVAL = &_tinterval;
16865 +/*----- Run PROC Timeseries for data preparation---------------------------*/
16867 +%EM_TSDP_Timeseries(
16868 +    /*--- input data set and variables ----*/
16869 +    inds            = &_IMPORT_DATA,
16870 +    crossid         = %EM_CROSSID,
16871 +    timeid          = %EM_TIMEID,
16873 +    /*--- time ID variable ----------------*/
16874 +    interval        = &EM_PROPERTY_TIMEINTERVAL,
16875 +    accumulation    = &EM_PROPERTY_ACCUMULATION,
16876 +    timeidfmttype   = &_timeidFormattype,
16877 +    timeidformat    = &_timeidformat,
16878 +    start           = %nrbquote(&_startTime),
16879 +    end             = %nrbquote(&_endTime),
16880 +    seasonlength    = &_seasonlength,
16882 +    /*--- transformation ------------------*/
16883 +    transform       = &EM_PROPERTY_TRANSFORM,
16884 +    boxcoxpara      = &EM_PROPERTY_BOXCOXPARA,
16886 +    /*--- differencing --------------------*/
16887 +    applydif        = &EM_PROPERTY_APPLYDIF,
16888 +    dif             = &EM_PROPERTY_DIF,
16889 +    applysdif       = &EM_PROPERTY_APPLYSDIF,
16890 +    sdif            = 1,
16892 +    /*--- missing intepretation------------*/
16893 +    missing         = &EM_PROPERTY_MISSING,
16894 +    missingconstant = &EM_PROPERTY_MISSINGCONSTANT,
16895 +    zeromiss        = &EM_PROPERTY_ZEROMISS,
16897 +    /*--- output data sets ----------------*/
16898 +    outds           = &EM_USER_OUTDS,
16899 +    outsum          = &EM_USER_OUTSUMMARY,
16900 +    outseason       = &EM_USER_OUTSEASON
16901 +);
16904 +%EM_TS_Time2Seq(inDS=&EM_USER_OUTDS, tsmeta=&EM_USER_TSMETA);
16905 +%EM_TS_Datetime2Time(inDS=&EM_USER_OUTDS, tsmeta=&EM_USER_TSMETA);
16907 +/*----- Get TS IDMap and Merge it with summary and season outputs----------*/
16909 +%EM_TS_CreateIDMap(
16910 +    inDS          = &EM_USER_OUTDS,
16911 +    outIDMap      = &EM_USER_TSIDMAP,
16912 +    outDS         = &EM_USER_OUTDS,
16913 +    variableSet   = &EM_DATA_VARIABLESET,
16914 +    TSIDbyCrossID = Y
16915 +);
16917 +%if &EM_NUM_CROSSID gt 0 %then %do;
16919 +   %EM_TSDP_MergeTSID(inds=&EM_USER_OUTSUMMARY, tsidds=&EM_USER_TSIDMAP, byvar=%EM_CROSSID, outds=);
16920 +   %EM_TS_SummaryDS(inDS=&EM_USER_OUTSUMMARY, crossid=%EM_CROSSID);
16922 +   %if &_seasonlength gt 1 %then %do;
16923 +       data  &EM_USER_OUTSEASON;
16924 +           set &EM_USER_OUTSEASON;
16925 +           rename _NAME_ = _VARNAME_;
16926 +       run;
16927 +       %EM_TSDP_MergeTSID(inds=&EM_USER_OUTSEASON,  tsidds=&EM_USER_TSIDMAP, byvar=%EM_CROSSID _VARNAME_, outds=);
16928 +    %end;
16929 +%end;
16930 +%else %do;
16931 +    %if &_seasonlength gt 1 %then %do;
16932 +        data  &EM_USER_OUTSEASON;
16933 +            set &EM_USER_OUTSEASON;
16934 +            rename _NAME_ = _NAMEID_;
16935 +        run;
16936 +        %EM_TSDP_MergeTSID(inds=&EM_USER_OUTSEASON, tsidds=&EM_USER_TSIDMAP, byvar=_NAMEID_, outds=);
16937 +    %end;
16938 +%end;
16940 +/*----- Transpose the time series -----------------------------------------*/
16942 +%if &EM_PROPERTY_TRANSPOSE eq Y %then %do;
16944 +    %EM_REGISTER(KEY=TRANS_IMPORTDS, TYPE=DATA);
16946 +    data &EM_USER_TRANS_IMPORTDS;
16947 +        set &EM_USER_OUTDS;
16948 +    run;
16950 +    %EM_TS_Transpose(
16951 +        inDS        = &EM_USER_OUTDS,
16952 +        inIDMap     = &EM_USER_TSIDMAP,
16953 +        variableSet = &EM_DATA_VARIABLESET,
16954 +        transposeby = &EM_PROPERTY_TRANSBYVAR,
16955 +        outDS       = &EM_USER_OUTDS,
16956 +        outIDMap    = &EM_USER_TSIDMAP
16957 +    );
16958 +%end;
16960 +%ENDLINE:
16961 +quit;
16963 +%mend EM_TSDP_TRAIN;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set EMWS5.TSDP3_EMINFO has 5 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSDP3_VARIABLESET.
      WHERE UPCASE(role)='TIMEID';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
NOTE: View EMWS5.IDS3_DATA.VIEW used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
NOTE: There were 1060 observations read from the data set FINALIB.OIL_MYSQL.
NOTE: Table WORK._EMTSCM_INDS created, with 1060 rows and 1 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
 
 
 
WARNING: Duplicate ID values detected.
NOTE: Number of time vectors processed: 1
NOTE: There were 1060 observations read from the data set WORK._EMTSCM_INDS.
NOTE: The data set WORK._EMTSCM_META has 1 observations and 24 variables.
NOTE: PROCEDURE TIMEID used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
NOTE: Table WORK._EMTSCM_LABEL created, with 1 rows and 2 columns.
 
NOTE: Table WORK._EMTSCM_META2 created, with 1 rows and 25 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      387:48    407:62    423:122   433:137   443:136   453:152
NOTE: There were 1 observations read from the data set WORK._EMTSCM_META2.
NOTE: The data set EMWS5.TSDP3_TSMETA has 1 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The file WORK._EM_TSCM: (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
NOTE: View EMWS5.IDS3_DATA.VIEW used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
NOTE: There were 1060 observations read from the data set FINALIB.OIL_MYSQL.
NOTE: Table WORK._TMPTIMETABLE created, with 1060 rows and 1 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 822 observations read from the data set EMWS5.TSDP3_TIMESTARTANDEND.
NOTE: There were 1060 observations read from the data set WORK._TMPTIMETABLE.
NOTE: The data set WORK._TMPDIFF has 0 observations and 3 variables.
NOTE: PROCEDURE COMPARE used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      12:146
NOTE: There were 0 observations read from the data set WORK._TMPDIFF.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK._TMPDIFF (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMPTIMETABLE (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._TMPCONTENTS has 2 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._TMPCONTENTS.
      WHERE UPCASE(name)='DATE';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMPCONTENTS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      9:152    12:120
NOTE: There were 822 observations read from the data set EMWS5.TSDP3_TIMESTARTANDEND.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      1:2   1:2
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      181:6
NOTE: There were 1 observations read from the data set EMWS5.TSDP3_TSMETA.
NOTE: The data set EMWS5.TSDP3_TSMETA has 1 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1060 observations read from the data set EMWS5.IDS3_DATA.
NOTE: View EMWS5.IDS3_DATA.VIEW used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
NOTE: There were 1060 observations read from the data set FINALIB.OIL_MYSQL.
NOTE: The data set WORK._TMPINDS has 1060 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There are 78 time periods between START=11NOV15:00 and END=18JAN19:00.
NOTE: Number of series processed: 5
NOTE: There were 1060 observations read from the data set WORK._TMPINDS.
NOTE: The data set EMWS5.TSDP3_OUTDS has 78 observations and 6 variables.
NOTE: The data set EMWS5.TSDP3_OUTSUMMARY has 5 observations and 14 variables.
NOTE: The data set EMWS5.TSDP3_OUTSEASON has 120 observations and 7 variables.
NOTE: PROCEDURE TIMESERIES used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSDP3_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSDP3_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The data set WORK._EMTSCM_CONTENTS has 6 observations and 1 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 5 observations read from the data set EMWS5.TSDP3_VARIABLESET.
      WHERE (UPCASE(STRIP(level))='INTERVAL') and (((UPCASE(STRIP(role))='INPUT') and UPCASE(STRIP(use)) in ('D', 'Y')) or ((UPCASE(STRIP(role))='REJECTED') and (UPCASE(STRIP(use))='Y')) or ((UPCASE(STRIP(role))='TARGET') and UPCASE(STRIP(use)) in ('D',
      'Y')));
NOTE: The data set EMWS5.TSDP3_TSIDMAP has 5 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 78 observations read from the data set EMWS5.TSDP3_OUTDS.
NOTE: The data set EMWS5.TSDP3_OUTDS has 78 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Variable _varname_ is uninitialized.
NOTE: There were 5 observations read from the data set EMWS5.TSDP3_TSIDMAP.
NOTE: The data set EMWS5.TSDP3_TSIDMAP has 5 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK._EMTSCM_CONTENTS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_INDS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_LABEL (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META2 (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 120 observations read from the data set EMWS5.TSDP3_OUTSEASON.
NOTE: The data set EMWS5.TSDP3_OUTSEASON has 120 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 120 observations read from the data set EMWS5.TSDP3_OUTSEASON.
NOTE: The data set WORK._TMP_INDS has 120 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 5 observations read from the data set EMWS5.TSDP3_TSIDMAP.
NOTE: The data set WORK._TMP_TSIDDS has 5 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 5 observations read from the data set WORK._TMP_TSIDDS.
NOTE: There were 120 observations read from the data set WORK._TMP_INDS.
NOTE: The data set EMWS5.TSDP3_OUTSEASON has 120 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMP_INDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK._TMP_TSIDDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
16964
16965
16966  *------------------------------------------------------------*;
16967  * End TRAIN: TSDP3;
16968  *------------------------------------------------------------*;
 
16969  *------------------------------------------------------------*;
16970  * Close any missing semi colons;
16971  *------------------------------------------------------------*;
16972  ;
16973  ;
16974  ;
16975  ;
16976  quit;
16977  *------------------------------------------------------------*;
16978  * Close any unbalanced quotes;
16979  *------------------------------------------------------------*;
16980  /*; *"; *'; */
16981  ;
16982  run;
16983  quit;
16984  /* Reset EM Options */
16985  options formchar="|----|+|---+=|-/\<>*";
16986  options nocenter ls=256 ps=10000;
16987  goptions reset=all device=GIF NODISPLAY;
 
*------------------------------------------------------------*
* Score Log
Date:                December 19, 2019
Time:                14:17:10
*------------------------------------------------------------*
17089  %let EMEXCEPTIONSTRING=;
17090  *------------------------------------------------------------*;
17091  * SCORE: TSDP3;
17092  *------------------------------------------------------------*;
17093  %let EM_ACTION = SCORE;
17094  %let syscc = 0;
17095
17096  %macro EM_TSDP_MAIN;
17097
17098     filename temp catalog 'sashelp.emtsdm.tsdp_macros.source';
17099     %include temp;
17100     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
17101     %include temp;
17102     filename temp;
17103
17104     %if %upcase(&EM_ACTION) = CREATE %then %do;
17105         filename temp catalog 'sashelp.emtsdm.tsdp_create.source';
17106         %include temp;
17107         filename temp;
17108         %EM_TSDP_CREATE;
17109     %end;
17110     %else
17111     %if %upcase(&EM_ACTION) = TRAIN %then %do;
17112          filename temp catalog 'sashelp.emtsdm.tsdp_train.source';
17113             %include temp;
17114             filename temp;
17115         %EM_TSDP_TRAIN;
17116     %end;
17117     %else
17118     %if %upcase(&EM_ACTION) = SCORE %then %do;
17119          filename temp catalog 'sashelp.emtsdm.tsdp_score.source';
17120             %include temp;
17121             filename temp;
17122         %EM_TSDP_SCORE;
17123     %end;
17124     %else
17125     %if %upcase(&EM_ACTION) = REPORT %then %do;
17126             filename temp catalog 'sashelp.emtsdm.tsdp_report.source';
17127             %include temp;
17128             filename temp;
17129          %EM_TSDP_REPORT;
17130     %end;
17131     %else
17132       %if %upcase(&EM_ACTION) = OPENTIMETABLEACTION  %then %do;
17133             filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
17134             %include temp;
17135             filename temp;
17136          %EM_TSDP_OpenTimeTable ;
17137     %end;
17138     %else
17139     %if %upcase(&EM_ACTION) = CLOSETABLEACTION  %then %do;
17140            filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
17141             %include temp;
17142             filename temp;
17143          %EM_TSDP_closeTimeTable ;
17144     %end;
17145
17146  %mend EM_TSDP_MAIN;
17147  %EM_TSDP_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_MACROS.SOURCE.
17148 +/*----------------------------------------------------------------------------------+
17149 + |
17150 + |   Title :
17151 + |   TS Data Preparation Node for Time Series Data Mining
17152 + |
17153 + |   Support : Taiyeong Lee( Taiyeong.Lee@sas.com)
17154 + |
17155 + |   Notes:
17156 + |
17157 + |----------------------------------------------------------------------------------*/
17160 +%Macro EM_TSDP_Timeseries(
17161 +    /*--- input data set and variables ----*/
17162 +    inds            = ,
17163 +    crossid         = ,
17164 +    timeid          = ,
17166 +      /*--- time ID variable ----------------*/
17167 +    interval        = ,
17168 +    accumulation    = ,
17169 +    timeidfmttype   = ,
17170 +    timeidformat    = ,
17171 +    start           = ,
17172 +    end             = ,
17173 +    seasonlength    = ,
17175 +      /*--- transformation ------------------*/
17176 +    transform       = ,
17177 +    boxcoxpara      = ,
17179 +      /*--- differencing --------------------*/
17180 +    applydif        = ,
17181 +    dif             = ,
17182 +    applysdif       = ,
17183 +    sdif            = ,
17185 +      /*--- missing intepretation------------*/
17186 +    missing         = ,
17187 +    missingconstant = ,
17188 +    zeromiss        = ,
17190 +      /*--- output data sets ----------------*/
17191 +    outds           = ,
17192 +    outsum          = ,
17193 +    outseason       =
17194 +);
17196 +/*%if &interval eq Hour or &interval eq Minute or &interval eq Second
17197 +    or &EM_PROPERTY_TIMEOFDAY eq Y or &timeidfmttype eq DATETIME   */
17198 +%if &timeidfmttype eq DATETIME
17199 +%then %do;
17200 +    %let _dtTag=DT;
17201 +%end;
17202 +%else %if &timeidfmttype eq TIME
17203 +%then %do;
17204 +    %let _dtTag=T;
17205 +%end;
17206 +%else %do;
17207 +    %let _dtTag=D;
17208 +%end;
17210 +proc sort data=&inds(keep = &crossid &timeid %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED)
17211 +     out=_tmpinds;
17212 +     by &crossid &timeid;
17213 +run;
17215 +proc timeseries data=_tmpinds out=&outds
17216 +    %if "&crossid" eq " "
17217 +        %then %do; outsum=&outsum(rename=(_NAME_=_NAMEID_)) %end;
17218 +        %else %do; outsum=&outsum %end;
17219 +    %if &seasonlength gt 1
17220 +    %then %do;
17221 +        outseason = &outseason seasonality= &seasonlength
17222 +    %end;
17223 +    ;
17225 +    %if &seasonlength gt 1
17226 +    %then %do;
17227 +        season SUM MEAN MIN MAX MEDIAN;
17228 +    %end;
17230 +    %if &crossid ne  %then %do;
17231 +        by &crossid;
17232 +    %end;
17234 +    id &timeid
17235 +        interval   = &interval
17236 +        accumulate = &accumulation
17237 +        %if &missing eq CONSTANT %then %do;
17238 +            setmissing = &missingconstant
17239 +        %end;
17240 +        %else %do;
17241 +            setmissing = &missing
17242 +        %end;
17243 +        %if &zeromiss ne NONE  %then %do;
17244 +            zeromiss = &zeromiss
17245 +        %end;
17246 +        %if &start ne  %then %do;
17247 +            %let  _start = "&start" ;
17248 +            start = &_start.&_dtTag
17249 +        %end;
17250 +        %if &end ne  %then %do;
17251 +            %let  _end = "&end";
17252 +            end = &_end.&_dtTag
17253 +        %end;
17254 +    ;
17256 +    var %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /
17257 +        %if &zeromiss ne NONE  %then %do;
17258 +            zeromiss = &zeromiss
17259 +        %end;
17260 +        %if &transform ne NONE  %then %do;
17261 +            %if &transform eq BOXCOX  %then %do;
17262 +                transform = BOXCOX(&boxcoxpara)
17263 +            %end;
17264 +            %else %do;
17265 +                transform = &transform
17266 +            %end;
17267 +        %end;
17268 +        %if &applydif eq Y  %then %do;
17269 +            dif = (&dif)
17270 +        %end;
17271 +        %if &applysdif eq Y %then %do;
17272 +            sdif = (&sdif)
17273 +        %end;
17274 +    ;
17275 +run;
17276 +quit;
17278 +%mend EM_TSDP_TimeSeries;
17281 +/*-----------------------------------------------------------------
17283 +    MERGE AFTER CLUSTERING
17285 ++------------------------------------------------------------------*/
17287 +%macro EM_TSDP_MergeAfterClustering();
17289 +/*--- need to fix the code based on data Role (train or transaction) ---*/
17291 +%EM_REGISTER(KEY=CLUSTS, TYPE=DATA);
17292 +%EM_GETNAME(KEY=CLUSTS, TYPE=DATA);
17294 +%let _train = ;
17295 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
17296 +%if &dsid > 0 %then %do;
17297 + %let vn_data =%sysfunc(varnum(&dsid, DATA));
17298 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
17299 +%do %while(^ %sysfunc(fetch(&dsid)));
17300 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
17301 +     %if &_key eq TSDRTRAIN %then %do;
17302 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
17303 +     %end;
17304 +     %else %if &_key eq TSDCTRAIN %then %do;
17305 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
17306 +     %end;
17307 +     %else %if &_key eq TSDPTRAINDS %then %do;
17308 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
17309 +     %end;
17310 +%end;
17311 +%end;
17312 +%let dsid = %sysfunc(close(&dsid));
17314 +proc sort data =&_train out=_inds;
17315 +     by %EM_CROSSID;
17316 +run;
17317 +proc sort data=&EM_IMPORT_DATA out=_outclus(KEEP= %EM_CROSSID _SEGMENT_);
17318 +      by %EM_CROSSID;
17319 +run;
17320 +data &EM_USER_CLUSTS;
17321 +     merge _inds _outclus;
17322 +     by %EM_CROSSID;
17323 +run;
17325 +proc sort data =&EM_USER_TSIDMAP;
17326 +     by %EM_CROSSID;
17327 +run;
17329 +data &EM_USER_TSIDMAP;
17330 +     merge &EM_USER_TSIDMAP _outclus;
17331 +     by %EM_CROSSID;
17332 +run;
17334 +data &EM_USER_CLUSTS ;
17335 +    merge  &EM_USER_TSIDMAP &EM_USER_CLUSTS;
17336 +     by %EM_CROSSID;
17337 +run;
17338 +quit;
17340 +%mend EM_TSDP_MergeAfterClustering;
17342 +%macro EM_TSDP_MergeTSID(inds=, tsidds=, byvar=, outds=);
17344 +    proc sort data =&inds out=_tmp_inds;
17345 +        by &byvar;
17346 +    proc sort data=&tsidds out=_tmp_tsidds;
17347 +        by &byvar;
17348 +    run;
17349 +    %if &outds eq %then %do;
17350 +        data &inds;
17351 +    %end;
17352 +    %else %do;
17353 +        data &outds;
17354 +    %end;
17355 +            merge _tmp_tsidds _tmp_inds;
17356 +            by &byvar;
17357 +        run;
17359 +    %EM_TS_DELETE_DATA(dsname=_tmp_inds);
17360 +    %EM_TS_DELETE_DATA(dsname=_tmp_tsidds);
17362 +%mend EM_TSDP_MergeTSID;
17364 +%macro EM_TS_SummaryDS(inDS=, crossid=);
17365 +    %let j=1;
17366 +    %do %while(%scan(&crossid, &j) ne );
17367 +        %let _csvar=%scan(&crossid, &j);
17368 +        %EM_REGISTER(KEY=OUTSUM&j, TYPE=DATA);
17369 +        %EM_GETNAME(KEY=OUTSUM&j, TYPE=DATA);
17370 +        %EM_TS_SummaryByCSID(inDS=&inDS, outDS=&EM_USER_OUTSUM&j,crossIDVar=&_csvar);
17371 +        %let j=%eval(&j+1);
17372 +    %end;
17373 +%mend EM_TS_SummaryDS;
17376 +%macro EM_TS_SummaryByCSID(inDS=, outDS=, RoleVar=_role_, TSVar=_varname_, crossIDVar=);
17377 +    proc sql noprint;
17378 +        create table &outDS as
17379 +            select distinct &RoleVar, &TSVar, &crossIDVAr,
17380 +                mean(mean1)  as mean      label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmean, noquote))",
17381 +                std(mean1)   as std_mean  label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smean, noquote))",
17382 +                mean(sum1)   as sum       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_msum, noquote))",
17383 +                std(sum1)    as std_sum   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_ssum, noquote))",
17384 +                mean(min1)   as min       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmin, noquote))",
17385 +                std(min1)    as std_min   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smin, noquote))",
17386 +                mean(max1)   as max       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmax, noquote))",
17387 +                std(max1)    as std_max   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smax, noquote))"
17388 +            from &inDS(rename=(mean=mean1 sum=sum1 min=min1 max=max1))
17389 +                group by &TSVar, &crossIDVar
17390 +                order by &TSVar, &crossIDVar
17391 +        ;
17392 +    quit;
17393 +%mend;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
17394 +/*
17395 +       MACRO: TS Utility macros
17397 +       PURPOSE: TS Utility macros
17398 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
17400 +       HISTORY:
17401 +       NOTE:
17403 +*/
17405 +/*
17406 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
17407 +                          timeid=, timeformat=, timeinformat=);
17408 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
17410 +    %do;
17411 +    %let m_data      = &data;
17412 +    %let m_decdata   = &decdata;
17413 +    %let m_decmeta   = &decmeta;
17414 +    %let m_cmeta     = &cmeta;
17415 +    %let m_outfile   = &outfile;
17416 +    %let m_crossid   = &crossid;
17417 +    %let m_timeid    = &timeid;
17418 +    %let m_timeformat    = &timeformat;
17419 +    %let m_timeinformat    = &timeinformat;
17420 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
17421 +  %end;
17422 +%mend EM_TS_CreateTsMetaDs;
17423 +*/
17424 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
17425 +proc sql;
17426 +      create table _tmp_inds
17427 +      as select distinct &timeid from  &indata;
17428 +quit;
17429 +run;
17430 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
17431 +  id &timeid
17432 +%if &timeinterval ne %then %do;
17433 +    %if &timeformattype eq DATE %then %do;
17434 +        interval=&timeinterval
17435 +    %end;
17436 +    %else %if &timeformattype eq DATETIME  %then %do;
17437 +        %let dttimeinterval= DT&timeinterval;
17438 +         interval=&dttimeinterval
17439 +    %end;
17440 +%end;
17441 +;
17442 +run;
17444 +data &outds;
17445 +     set _tmp_tsmeta;
17446 +     format START &timeformat;
17447 +     format END &timeformat;
17448 +     length APPLY_START_END $8;
17449 +     APPLY_START_END ="No";
17450 +     FORMAT = "&timeformat";
17451 +     ROLE ="TIMEID";
17452 +     rename TIMEID = NAME;
17453 +     rename SEASONALITY= LengthOfCycle;
17454 +     rename INTERVAL = TIMEINTERVAL ;
17455 +     rename FORMAT = TIMEFORMAT;
17456 +     output;
17457 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
17458 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
17459 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
17460 +run;
17462 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
17463 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
17465 +%mend EM_TS_CreateTSMetaData;
17469 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
17471 +/* if updated = Y it will pass the TSMETA created by just the previous node */
17473 +%let _tsmetads = ;
17475 +%if &updated = Y %then %do;
17476 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
17477 +%if %sysfunc(exist(&_tsmetads)) %then %do;
17478 +%goto endline;
17479 +%end;
17480 +%end;
17482 +%if &eminfodata eq %then %do;
17483 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
17484 +    data &EM_DATA_EMINFO;
17485 +         set &EM_IMPORT_DATA_EMINFO;
17486 +    run;
17487 +%end;
17488 +%else %do;
17489 +    %let dsid=%sysfunc(open(&eminfodata));
17490 +    data &EM_DATA_EMINFO;
17491 +         set &eminfodata;
17492 +    run;
17493 +%end;
17494 +%if &dsid > 0 %then %do;
17495 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
17496 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
17497 +    %do %while(^ %sysfunc(fetch(&dsid)));
17498 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
17499 +         %if &_key eq TSMETA %then %do;
17500 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
17501 +         %end;
17502 +    %end;
17503 +    %let dsid = %sysfunc(close(&dsid));
17504 +%end; /* the end of %if &dsid > 0 %then %do; */
17506 +%endline:
17508 +%if &_tsmetads ne %then %do;
17509 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
17510 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
17511 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
17512 +         data &EM_USER_TSMETA;
17513 +                   set &_tsmetads;
17514 +         run;
17515 +    %end;
17516 +%end;
17518 +*proc print data=&EM_DATA_EMINFO;
17519 +*proc print data=&EM_IMPORT_DATA_EMINFO;
17520 +*run;
17521 +%MEND EM_TS_GETTSMETA;
17524 +/*
17525 +%macro EM_GETTSMETAVARS(TimeInterval=);
17526 +%global &TimeInterval;
17527 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
17528 +%if &dsid > 0 %then %do;
17529 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
17530 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
17531 +%do %while(^ %sysfunc(fetch(&dsid)));
17532 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17533 +     %if &_role eq TIMEID %then %do;
17534 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
17535 +     %end;
17536 +%end;
17537 +%let dsid = %sysfunc(close(&dsid));
17538 +%end;
17539 +%MEND EM_GETTSMETAVARS;
17540 +*/
17541 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
17542 +%global &TimeInterval;
17543 +%global &TimeId;
17544 +%global &EndTime;
17545 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
17546 +proc print data=&EM_USER_TSMETA;
17547 +run;
17548 +%if &dsid > 0 %then %do;
17549 +%if &TimeInterval ne %then %do;
17550 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
17551 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
17552 +    %do %while(^ %sysfunc(fetch(&dsid)));
17553 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17554 +        %if &_role eq TIMEID %then %do;
17555 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
17556 +        %end;
17557 +     %end;
17558 +%end;
17559 +%if &TimeId ne %then %do;
17560 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
17561 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
17562 +    %do %while(^ %sysfunc(fetch(&dsid)));
17563 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17564 +        %if &_role eq TIMEID %then %do;
17565 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
17566 +        %end;
17567 +    %end;
17568 +%end;
17570 +%if &EndTime ne %then %do;
17571 +    %let vn_end =%sysfunc(varnum(&dsid, END));
17572 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
17573 +    %do %while(^ %sysfunc(fetch(&dsid)));
17574 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17575 +        %if &_role eq TIMEID %then %do;
17576 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
17577 +        %end;
17578 +     %end;
17579 +%end;
17580 +%let dsid = %sysfunc(close(&dsid));
17581 +%end;
17582 +%MEND EM_TS_GETTSMETAVARS;
17586 +/*------------------------------------------------------------------
17588 +      Macro EM_GETTSIDMAP
17590 +------------------------------------------------------------------+*/
17593 +%macro EM_TS_GETTSIDMAP(updated=);
17595 +%let _tsidmap = ;
17597 +%if &updated = Y %then %do;
17598 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
17599 +%if %sysfunc(exist(&_tsidmap)) %then %do;
17600 +%goto endline;
17601 +%end;
17602 +%end;
17604 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
17605 +%if &dsid > 0 %then %do;
17606 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
17607 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
17608 +%do %while(^ %sysfunc(fetch(&dsid)));
17609 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
17610 +     %if &_key eq TSIDMAP %then %do;
17611 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
17612 +     %end;
17613 +%end;
17615 +%let dsid = %sysfunc(close(&dsid));
17616 +%end;
17618 +%endline:
17620 +%if &_tsidmap ne %then %do;
17622 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
17623 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
17625 +%if %sysfunc(exist(&_tsidmap)) %then %do;
17626 +         data &EM_USER_TSIDMAP;
17627 +               set &_tsidmap;
17628 +         run;
17629 +    %end;
17630 +%end;
17631 +%MEND EM_TS_GETTSIDMAP;
17633 +/*------------------------------------------------------------------*/
17638 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
17639 +%global &value;
17642 +%let dsid = %sysfunc(open(&data));
17643 +%if &dsid > 0 %then %do;
17644 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
17645 +    %if &vn_var < 1 %then %do;
17646 +        %let &value = 0;
17647 +        %let dsid = %sysfunc(close(&dsid));
17648 +        %goto endline;
17649 +    %end;
17650 +%let dsid = %sysfunc(close(&dsid));
17651 +%end;
17653 +%let _tmp=_tmpDS;
17654 +proc means data=&data &stat;
17655 +     var &var;
17656 +     output out=&_tmp;
17657 +run;
17659 +%let dsid = %sysfunc(open(&_tmp));
17660 +%if &dsid > 0 %then %do;
17661 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
17662 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
17663 +     %do %while(^%sysfunc(fetch(&dsid)));
17664 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
17665 +         %if &_stat eq &stat %then %do;
17666 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
17667 +          %end;
17668 +      %end;
17669 +%let dsid = %sysfunc(close(&dsid));
17670 +%end;
17671 +proc datasets lib=work nolist;
17672 + delete &_tmp;
17673 +run;
17674 +%endline:
17675 +%MEND EM_TS_GET_STAT;
17678 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
17679 +%global &format;
17680 +%global &informat;
17681 +%let dsid = %sysfunc(open(&data));
17682 +%if &dsid > 0 %then %do;
17683 +%let vn_var =%sysfunc(varnum(&dsid, &var));
17684 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
17685 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
17686 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
17687 +%end;
17688 +%let dsid = %sysfunc(close(&dsid));
17689 +%end;
17690 +%MEND EM_TS_GET_VAR_FORMAT;
17692 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
17693 +      %if &lib eq %then %let lib=work;
17694 +       proc datasets lib=&lib nolist;
17695 +              delete &dsname;
17696 +       run;
17697 +%Mend  EM_TS_DELETE_DATA;
17700 +%macro EM_TS_GetNObs(inds=, nobs=);
17701 +    %global &nobs;
17702 +    %let &nobs=0;
17703 +    data _null_;
17704 +        set &inds end=eof;
17705 +        if eof then call symput("&nobs", _N_);
17706 +    run;
17707 +    quit;
17709 +    /*
17710 +    %let dsid=%sysfunc(open(&outdata));
17711 +    %if dsid > 0 %then %do;
17712 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
17713 +        %let dsid = %sysfunc(close(&dsid));
17714 +     %end;
17715 +    */
17716 +%mend  EM_TS_GetNObs;
17719 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
17720 +%global &time1;
17721 +%global &time2;
17722 +%if &default = Y %then %do;
17723 +   data _null_;
17724 +        set &data end=eof;
17725 +        if _N_ = 1 then  call symput("&time1", DATE);
17726 +        if eof then call symput("&time2", DATE);
17727 +    run;%end;
17728 +%else %do;
17729 +    %let dsid = %sysfunc(open(&data));
17730 +    %if &dsid > 0 %then %do;
17731 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
17732 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
17733 +        %do %while(^%sysfunc(fetch(&dsid)));
17734 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
17735 +             %if &_index eq 1 %then %do;
17736 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
17737 +             %end;
17738 +             %if &_index eq 2 %then %do;
17739 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
17740 +             %end;
17741 +        %end;
17742 +    %let dsid = %sysfunc(close(&dsid));
17743 +    %end;
17744 +%end;
17746 +%MEND EM_TS_GET_TIME_VALUES;
17748 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
17749 +%global &exist;
17750 + %let &exist = N;
17751 +%let dsid = %sysfunc(open(&data));
17752 +%if &dsid > 0 %then %do;
17753 +%let vn_var =%sysfunc(varnum(&dsid, &var));
17754 +%if &vn_var > 0 %then %do;
17755 +    %let &exist = Y;
17756 +%end;
17757 +%let dsid = %sysfunc(close(&dsid));
17758 +%end;
17759 +%MEND EM_TS_GET_VAR_EXIST;
17762 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
17763 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
17764 +      set &intreedata;
17765 +        LENGTH NodeType $32;
17766 +      if _PARENT_ eq " " then delete;
17767 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
17768 +        else NodeType = "CLUSTER";
17769 +        LinkID = _N_;
17770 +run;
17771 +%Mend EM_TS_MakeConstellPlotData;
17776 +%macro EM_TS_CreateIDMap(
17777 +/*-------------------------------------------------------------------------*/
17778 +/*---   Written by Xiangxiang Meng                                         */
17779 +/*-------------------------------------------------------------------------*/
17780 +inDS          =,      /* imported data set in TS data mining               */
17781 +outIDMap      =,      /* output data set of TS ID map                      */
17782 +outDS         =,      /* output data set of TS and TS ID merged            */
17783 +variableSet   =,      /* EM variable set                                   */
17784 +TSIDbyCrossID =Y,
17785 +inEM          =Y
17786 +/*-------------------------------------------------------------------------*/
17787 +);
17789 +%global EM_TS_ERR;
17790 +%let EM_TS_ERR = 0;
17792 +%if &inEM eq Y %then %do;
17793 +    %let num_crossIDVar = &EM_NUM_CROSSID;
17794 +    proc sql noprint;
17795 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
17796 +    quit;
17797 +%end;
17798 +%else %do;
17799 +    proc sql noprint;
17800 +         select count(*) into :num_crossIDVar from &variableSet
17801 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17802 +         ;
17803 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
17804 +         ;
17805 +    quit;
17806 +    %let num_crossIDVar=&num_crossIDVar;
17807 +%end;
17809 +* see if _TSID_ exists;
17811 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
17812 +run;
17814 +proc sql noprint;
17815 +    select count(*) into :has_TSID
17816 +        from _emtscm_contents
17817 +        where upcase(strip(name)) eq '_TSID_'
17818 +    ;
17819 +quit;
17821 +/*-------------------------------------------------------------------------*/
17822 +* Creating TSID map..;
17823 +/*-------------------------------------------------------------------------*/
17825 +%if (&num_crossIDVar gt 0) %then %do;
17827 +    data _emtscm_tmpIDMap;
17828 +        set &variableSet;
17829 +        where  (upcase(strip(level)) eq 'INTERVAL')
17830 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
17831 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
17832 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
17833 +          );
17834 +        _emts_dummy=1;
17835 +        keep name label role _emts_dummy;
17836 +    run;
17838 +    proc sql noprint;
17839 +        * create a string of crossID variable like A,B,C,D..;
17840 +        select distinct name into :crossIDVar separated by ','
17841 +            from &variableSet
17842 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17843 +            order by name
17844 +        ;
17845 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
17846 +            from &variableSet
17847 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17848 +            order by name
17849 +        ;
17850 +        * create the TSID map data set;
17851 +        create table _emtscm_tmp1 as
17852 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
17853 +        ;
17854 +        * create a level list of cross ID variables and time series variables;
17855 +        create table &outIDMap as
17856 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
17857 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
17858 +            where a._emts_dummy eq b._emts_dummy
17859 +            order by a.name, &crossIDVar
17860 +        ;
17861 +    quit;
17863 +    %if &TSIDbyCrossID = Y %then %do;
17864 +        * create unique TSID only by Cross ID;
17865 +        data &outIDMap;
17866 +            length _TSID_ 8;
17867 +            set &outIDMap;
17868 +            by _NAMEID_;
17869 +            if first._NAMEID_
17870 +                then _TSID_=1;
17871 +                else _TSID_+1;
17872 +        run;
17873 +        %if "&outDS" ne "" %then %do;
17874 +            * merge TSID into &inDS;
17875 +            proc sql noprint;
17876 +                create table &outDS as
17877 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
17878 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
17879 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
17880 +                        where %do i = 1 %to &num_crossIDVar;
17881 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
17882 +                              %end;
17883 +                             b._TSID_ is not missing
17884 +                    order by b._TSID_, a.&timeIDVar
17885 +                ;
17886 +            quit;
17887 +        %end;
17888 +    %end;
17889 +    %else %do;
17890 +        * create unique TSID by Cross ID and _NAMEID_;
17891 +        data &outIDMap;
17892 +            length _TSID_ 8;
17893 +            set &outIDMap;
17894 +            _TSID_=_n_;
17895 +        run;
17896 +        %if "&outDS" ne "" %then %do;
17897 +            *no merge in this output;
17898 +            data &outDS;
17899 +                set &inDS;
17900 +            run;
17901 +        %end;
17902 +    %end;
17904 +    proc sort data=&outIDMap;
17905 +        by _NAMEID_ _TSID_;
17906 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
17907 +        format _TSID_ best12. _NAMEID2_ $40.;
17908 +        set &outIDMap;
17909 +        by _NAMEID_;
17910 +        if first._NAMEID_
17911 +            then _emts_ind=1;
17912 +            else _emts_ind+1;
17913 +        drop _emts_ind;
17914 +        rename _NAMEID_=_VARNAME_;
17915 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
17916 +        if _labelID_ eq ' '
17917 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
17918 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
17919 +    run;
17921 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
17923 +%end;
17924 +%else %do; /* if no crossid's the nameid needs to be created */
17926 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
17927 +        length _TSID_ 8;
17928 +        set &variableSet;
17929 +        where  (upcase(strip(level)) eq 'INTERVAL')
17930 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
17931 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
17932 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
17933 +          );
17934 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
17935 +        rename ROLE = _ROLE_;
17936 +        _NAMEID_=strip(name);
17937 +        _VARNAME_=strip(name);
17938 +        if label eq ' '
17939 +            then _LABELID_ = strip(name);
17940 +            else _LABELID_ = strip(label);
17941 +        _TSID_=_n_;
17942 +    run;
17944 +    %if "&outDS" ne "" %then %do;
17945 +        *no merge in this output;
17946 +        data &outDS;
17947 +            set &inDS;
17948 +        run;
17949 +    %end;
17950 +%end;
17952 +data &outIDMap;
17953 +    set &outIDMap;
17954 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
17955 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
17956 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
17957 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
17958 +run;
17960 +proc datasets lib=work nolist;
17961 +    delete _emtscm_:;
17962 +run; quit;
17964 +%mend EM_TS_createIDMap;
17966 +%macro EM_TS_CreateMetaData(
17967 +/*-------------------------------------------------------------------------*/
17968 +  inDS          =,      /* imported data set in TS data mining             */
17969 +  outDS         =,      /* output data set of TS metadata                  */
17970 +  variableSet   =,      /* EM variable set                                 */
17971 +  timeInterval  =,      /* time interval                                   */
17972 +  rc            =       /* return code                                     */
17973 +/*-------------------------------------------------------------------------*/
17974 +);
17976 +%if %eval(
17977 +      &EM_NUM_BINARY_INPUT   +
17978 +      &EM_NUM_ORDINAL_INPUT  +
17979 +      &EM_NUM_NOMINAL_INPUT  +
17980 +      &EM_NUM_BINARY_REJECTED   +
17981 +      &EM_NUM_ORDINAL_REJECTED  +
17982 +      &EM_NUM_NOMINAL_REJECTED  +
17983 +      &EM_NUM_ORDINAL_TARGET  +
17984 +      &EM_NUM_NOMINAL_TARGET +
17985 +      &EM_NUM_BINARY_TARGET
17986 +      ) > 0
17987 +%then %do;
17988 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
17989 +        %put &em_codebar;
17990 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
17991 +        %put &errormsg;
17992 +        %put &em_codebar;
17993 +        %goto ENDLINE;
17994 +%end;
17996 +%global EM_TS_ERR;
17997 +%let EM_TS_ERR = 0;
17999 +%if &timeInterval eq AUTO
18000 +    %then %let timeInterval  = ;
18001 +    %else %let timeInterval  = %upcase(&timeInterval);
18003 +/*-------------------------------------------------------------------------*/
18004 +* check time ID variable;
18005 +/*-------------------------------------------------------------------------*/
18007 +* number of variables in the Variableset with ROLE=TIMEID;
18008 +proc sql noprint;
18009 +    select count(*) into :num_timeID from &variableset
18010 +        where upcase(role) eq 'TIMEID';
18011 +quit;
18013 +/*-------------------------------------------------------------------------*/
18014 +* process only when there is one Time ID, otherwise exception message;
18015 +/*-------------------------------------------------------------------------*/
18017 +%if &num_timeID eq 0 %then %do;
18019 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
18020 +    %let EM_TS_ERR = 11;
18021 +    %put &em_codebar;
18022 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
18023 +    %put &errormsg;
18024 +    %put &em_codebar;
18025 +    %goto tscm_endline;
18027 +%end;
18028 +%else %if &num_timeID gt 1 %then %do;
18030 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
18031 +    %let EM_TS_ERR = 12;
18032 +    %put &em_codebar;
18033 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
18034 +    %put &errormsg;
18035 +    %put &em_codebar;
18036 +    %goto tscm_endline;
18038 +%end;
18039 +%else %do;
18040 +    *** proceed when there is one Time ID;
18042 +    data _null_;
18043 +        set &variableset(where=(upcase(role)='TIMEID'));
18044 +        call symput('timeIDFormat',     strip(format));
18045 +        call symput('timeID',           strip(upcase(name)      ));
18046 +        call symput('timeIDLevel',      strip(upcase(level))     );
18047 +        call symput('timeIDFormatType', strip(upcase(formattype)));
18048 +    run;
18050 +    *** exception message if the time ID is not an interval variable;
18051 +    %if &timeIDLevel ne INTERVAL %then %do;
18052 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
18053 +        %let EM_TS_ERR = 13;
18054 +        %put &em_codebar;
18055 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
18056 +        %put &errormsg;
18057 +        %put &em_codebar;
18058 +        %goto tscm_endline;
18059 +    %end;
18061 +    %if (&timeIDFormatType ne DATETIME) and
18062 +        (&timeIDFormatType ne DATE) and
18063 +        (&timeIDFormatType ne TIME) and
18064 +        (&timeIDFormatType ne USER)
18065 +    %then %do;
18066 +        *** sequential format-type of time ID;
18068 +        %let timeInterval = DAY;
18069 +        %let timeIDFormatType = SEQ;
18071 +        proc sql noprint;
18072 +            create table _emtscm_inds as
18073 +                 select distinct &timeID from &inDS(keep=&timeID)
18074 +                 where &timeID is not missing;
18075 +            select count(*) into :num_nonInteger from _emtscm_inds
18076 +                where &timeID ne int(&timeID);
18077 +        quit;
18079 +        %if &num_nonInteger gt 0 %then %do;
18080 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
18081 +            %let EM_TS_ERR = 14;
18082 +            %put &em_codebar;
18083 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
18084 +            %put &errormsg;
18085 +            %put &em_codebar;
18086 +            %goto tscm_endline;
18087 +        %end;
18088 +    %end;
18089 +    %else %do;
18090 +        *** date, datetime, time format-type of time ID;
18092 +        *** must have a format;
18093 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
18094 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
18095 +            %let EM_TS_ERR = 15;
18096 +            %put &em_codebar;
18097 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
18098 +            %put &errormsg;
18099 +            %put &em_codebar;
18100 +            %goto tscm_endline;
18101 +        %end;
18103 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
18104 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
18105 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
18106 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
18107 +                %let EM_TS_ERR = 16;
18108 +                %put &em_codebar;
18109 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
18110 +                %put &errormsg;
18111 +                %put &em_codebar;
18112 +                %goto tscm_endline;
18113 +            %end;
18114 +        %end;
18116 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
18117 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
18118 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
18119 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
18120 +                %let EM_TS_ERR = 17;
18121 +                %put &em_codebar;
18122 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
18123 +                %put &errormsg;
18124 +                %put &em_codebar;
18125 +                %goto tscm_endline;
18126 +            %end;
18127 +        %end;
18129 +        *** the AUTO function is currently turned off for TIME timeID variable;
18130 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
18131 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
18132 +            %let EM_TS_ERR = 18;
18133 +            %put &em_codebar;
18134 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
18135 +            %put &errormsg;
18136 +            %put &em_codebar;
18137 +            %goto tscm_endline;
18138 +        %end;
18140 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
18141 +            %then %let timeInterval =DT&timeInterval;
18143 +        proc sql noprint;
18144 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
18145 +                where &timeID is not missing;
18146 +        quit;
18147 +    %end;
18149 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
18150 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
18151 +    run;
18153 +    %let hasValidInterval = 0;
18154 +    %let hasLengthOne     = 0;
18156 +    proc sql noprint;
18157 +        create table _emtscm_label as
18158 +            select name,label
18159 +            from dictionary.columns
18160 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
18161 +        ;
18162 +        create table _emtscm_meta2 as
18163 +            select a.*, b.label
18164 +            from _emtscm_meta as a, _emtscm_label as b
18165 +            where upcase(a.timeID) eq upcase(b.name)
18166 +        ;
18167 +    quit;
18169 +    data &outDS;
18170 +        set _emtscm_meta2;
18171 +        format
18172 +            timeformat      $30.
18173 +            role            $10.
18174 +            start           &timeIDformat
18175 +            end             &timeIDformat
18176 +            apply_start_end $8.
18177 +        ;
18178 +        rename
18179 +            timeID      = name
18180 +            seasonality = lengthOfCycle
18181 +            interval    = timeinterval
18182 +        ;
18183 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
18185 +        role            = "TIMEID";
18186 +        apply_start_end = 'N';
18187 +        timeformat      = symget('timeIDformat');
18188 +        timeformattype  = symget('timeIDformatType');
18190 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
18191 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
18192 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
18193 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
18194 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
18195 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
18196 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
18197 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
18198 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
18199 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
18201 +        if timeformattype eq 'SEQ' then do;
18202 +            timeformat='BEST12.';
18203 +            seasonality=1;
18204 +        end;
18206 +        call symput('_tinterval',interval);
18208 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
18210 +        if upcase(timeformattype) eq 'DATE' and
18211 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
18212 +            then call symput('hasValidInterval',1);
18214 +        if upcase(timeformattype) eq 'DATETIME' and
18215 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
18216 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
18217 +            then call symput('hasValidInterval',1);
18219 +        if upcase(timeformattype) eq 'TIME' and
18220 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
18221 +            then call symput('hasValidInterval',1);
18223 +        if upcase(timeformattype) eq 'SEQ'
18224 +            then call symput('hasValidInterval',1);
18226 +        if upcase(timeformattype) eq 'USER'
18227 +            then call symput('hasValidInterval',1);
18229 +        if start eq end
18230 +            then call symput('hasLengthOne',1);
18231 +    run;
18233 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
18235 +    *** detect any missing time interval after running PROC TIMEID;
18236 +    %if &_tinterval eq %then %do;
18237 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
18238 +        %let EM_TS_ERR = 19;
18239 +        %put &em_codebar;
18240 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
18241 +        %put &errormsg;
18242 +        %put &em_codebar;
18243 +        %goto tscm_endline;
18244 +    %end;
18246 +    *** detect any missing time interval after running PROC TIMEID;
18247 +    %if &hasValidInterval eq 0 %then %do;
18248 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
18249 +        %let EM_TS_ERR = 20;
18250 +        %put &em_codebar;
18251 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
18252 +        %put &errormsg;
18253 +        %put &em_codebar;
18254 +        %goto tscm_endline;
18255 +    %end;
18257 +    %if &hasLengthOne eq 1 %then %do;
18258 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
18259 +        %let EM_TS_ERR = 21;
18260 +        %put &em_codebar;
18261 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
18262 +        %put &errormsg;
18263 +        %put &em_codebar;
18264 +        %goto tscm_endline;
18265 +    %end;
18267 +%end;
18269 +%tscm_endline:;
18271 +%mend EM_TS_CreateMetaData;
18274 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
18276 +data _null_;
18277 +    set &tsmeta;
18278 +    call symput('_timeidFormatType', timeformattype);
18279 +    call symput('_timeid', strip(name));
18280 +    call symput('_seqstartnum',strip(put(start,best12.)));
18281 +run;
18283 +proc contents data=&inDS noprint
18284 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
18285 +run; quit;
18287 +data _null_;
18288 +    set _emts_tmpp1;
18289 +    call symput('_timeIDlabel',label);
18290 +run;
18292 +%if &_timeidFormatType eq SEQ
18293 +%then %do;
18294 +    proc sql noprint;
18295 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
18296 +    quit;
18297 +    %let _dummystarttime=&_dummystarttime;
18299 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
18300 +        set &inDS;
18301 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
18302 +        drop &_timeid;
18303 +        label _tsdp_tmpID = "&_timeIDlabel";
18305 +    run;
18306 +%end;
18308 +%mend;
18310 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
18312 +data _null_;
18313 +    set &tsmeta;
18314 +    call symput('_timeidFormatType', timeformattype);
18315 +    call symput('_timeidFormat', timeformat);
18316 +    call symput('_timeid', strip(name));
18317 +    call symput('_timeinterval',strip(upcase(timeinterval)));
18318 +run;
18320 +/* manually change time ID format to a longer enough time format */
18321 +/* because proc timeid returns time5. for second time interval */
18322 +/* which is not long enough for transpose with time unit as seconds */
18323 +%if &_timeinterval eq SECOND
18324 +%then %do;
18325 +    %let _timeIDformat = %str(time8.);
18326 +%end;
18328 +proc contents data=&inDS noprint
18329 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
18330 +run; quit;
18332 +data _null_;
18333 +    set _emts_tmpp1;
18334 +    call symput('_timeIDlabel',label);
18335 +run;
18337 +%if &_timeidFormatType eq TIME
18338 +%then %do;
18339 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
18340 +        set &inDS;
18341 +        _tsdp_tmpID = timepart(&_timeID);
18342 +        format _tsdp_tmpID &_timeidFormat;
18343 +        label  _tsdp_tmpID = "&_timeIDlabel";
18344 +        drop &_timeid;
18345 +    run;
18346 +%end;
18348 +%mend;
18350 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
18352 + proc sql noprint;
18353 +     create table _tmptimetable as
18354 +         select distinct &timeidvar as DATE from &inDS
18355 +         where &timeIDVar is not missing
18356 +         order by &timeIDVar;
18357 + quit;
18359 +%if &compare eq Y %then %do;
18360 +    * compare with the existing time table;
18361 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
18362 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
18363 +    run;
18365 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
18367 +    %if &_diffobs > 0 %then %do; /* create it again */
18368 +        data &outDS(keep=DATE _INDEX_);
18369 +            set _tmptimetable end = _eof_;
18370 +            if _N_ = 1
18371 +                then _INDEX_ = 1;
18372 +                else _INDEX_ = 0;
18373 +            if _eof_ then _INDEX_= 2;
18374 +        run;
18375 +    %end;
18377 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
18378 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
18379 +%end;
18380 +%else %do;
18381 +    * create a new time table directly;
18382 +    data &outDS(keep=DATE _INDEX_);
18383 +        set _tmptimetable end = _eof_;
18384 +        if _N_ = 1
18385 +            then _INDEX_ = 1;
18386 +            else _INDEX_ = 0;
18387 +        if _eof_ then _INDEX_= 2;
18388 +    run;
18390 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
18391 +%end;
18393 +* assign a defult format BEST12. for sequential time ID;
18395 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
18397 +%let _nodatefmt=N;
18399 +data _null_;
18400 +    set _tmpcontents;
18401 +    where upcase(name) eq 'DATE';
18402 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
18403 +run;
18405 +%if "&_nodatefmt" eq "Y" %then %do;
18406 +    data &outDS;
18407 +        set &outDS;
18408 +        format date best12.;
18409 +    run;
18410 +%end;
18412 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
18414 +%mend;
18418 +%macro EM_TS_Transpose(
18419 +/*-------------------------------------------------------------------------*/
18420 +  inDS          =,      /* imported data set in TS data mining             */
18421 +  inIDMap       =,      /* input TS ID map                                 */
18422 +  variableSet   =,      /* variable set                                    */
18423 +  transposeBy   =,      /* byTSID or byTimeID                              */
18424 +  outDS         =,      /* output transposed data set                      */
18425 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
18426 +  inEM          =Y,
18427 +  timePrefix    =_T
18428 +/*-------------------------------------------------------------------------*/
18429 +);
18431 +%let timePrefix = &timePrefix;
18433 +%if  &EM_NUM_CROSSID > 0 %then %do;
18435 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
18436 +    set &inIDMap;
18437 +    drop _NAMEID_;
18438 +    run;
18439 +%let inIDMap=_emtstp_map0;
18441 +%end;
18443 +proc sql noprint;
18444 +    * number of TS Variables to be transposed;
18445 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
18446 +    ;
18447 +    * number of TS Variables to be transposed;
18448 +    select max(_TSID_) into :num_TSID from &inIDMap
18449 +    ;
18450 +    * name list of TS Variables;
18451 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
18452 +        from &inIDMap
18453 +        order by _NAMEID_
18454 +    ;
18455 +    * total number of time series =max(_TSID_)*&num_TSVar;
18456 +    * and the number of digits of this variable is &num_digits;
18457 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
18458 +        from &inIDMap
18459 +    ;
18460 +      * Time ID variable;
18461 +    select name into:timeIDVar from &variableset
18462 +        where upcase(role) eq 'TIMEID'
18463 +    ;
18464 +quit;
18465 +%let num_digits = &num_digits;
18466 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
18468 +/*-------------------------------------------------------------------------*/
18470 +* get number of cross IDs and also the TIME ID variable name;
18471 +%if &inEM eq Y %then %do;
18472 +    %let num_crossIDVar = &EM_NUM_CROSSID;
18473 +    %let crossIDVar     = %EM_CROSSID;
18474 +%end;
18475 +%else %do;
18476 +    proc sql noprint;
18477 +        * number of cross ID;
18478 +        select count(*) into :num_crossIDVar
18479 +            from &variableSet
18480 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
18481 +        ;
18482 +        * create a string of crossID variable like A B C D..;
18483 +        select distinct name into :crossIDVar separated by ' '
18484 +            from &variableSet
18485 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
18486 +            order by name
18487 +        ;
18488 +    quit;
18489 +    %let num_crossIDVar=&num_crossIDVar;
18490 +%end;
18492 +/*-------------------------------------------------------------------------*/
18494 +%if (&num_crossIDVar gt 0) %then %do;
18496 +    data _emtstp_tmpDat;
18497 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
18498 +        _NAMEID_ = cats("_TS_",_TSID_);
18499 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
18500 +    run;
18502 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
18504 +        * update the ID maps;
18505 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
18506 +            by _NAMEID_ _TSID_;
18507 +        data &outIDMap;
18508 +            set _emtstp_tmpmap;
18509 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
18510 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
18511 +        run;
18513 +        * get the names for the new variables;
18514 +        proc sql noprint;
18515 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
18516 +            ;
18517 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
18518 +            ;
18519 +        quit;
18521 +        * data must be sorted before transposed;
18522 +        proc sort data=_emtstp_tmpDat;
18523 +            by &timeIDvar;
18524 +        run;
18526 +        %do i = 1 %to &num_TSVar;
18527 +            %let i = &i;
18528 +            * transpose one cross-type time series data by TSID;
18529 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
18530 +                id _NAMEID_;
18531 +                by &timeIDVar;
18532 +                var &&&TSVar&i;
18533 +            run;
18534 +        %end;
18536 +        * merge all vertical time series, rename and label them;
18537 +        data &outDS;
18538 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
18539 +            by &timeIDVar;
18540 +            rename
18541 +                %do i = 1 %to &num_TSVar;
18542 +                    %do j = 1 %to &num_TSID;
18543 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
18544 +                        /* %put &i &j &num1 &num_TSID; */
18545 +                        _V_&i._TS_&j = &&&tsname&num1
18546 +                    %end;
18547 +                %end;
18548 +            ;
18549 +            label
18550 +                %do i = 1 %to &num_TSVar;
18551 +                    %do j = 1 %to &num_TSID;
18552 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
18553 +                        /* %put &i &j &num1 &num_TSID; */
18554 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
18555 +                    %end;
18556 +                %end;
18557 +            ;
18558 +        run;
18559 +    %end;
18560 +    %else %do;
18562 +        * update the ID maps;
18563 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
18564 +            by _NAMEID_ _TSID_;
18565 +        data &outIDMap;
18566 +            set _emtstp_tmpmap;
18567 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
18568 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
18569 +        run;
18571 +        proc sql noprint;
18572 +            * get the roles for the new variables;
18573 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
18574 +                from &inIDMap
18575 +                order by _NAMEID_
18576 +            ;
18577 +            * get the length of the time series;
18578 +            select count(distinct &timeIDvar) into :num_T
18579 +                from _emtstp_tmpDat
18580 +            ;
18581 +        quit;
18583 +        * data must be sorted before transposed;
18584 +        proc sort data=_emtstp_tmpDat;
18585 +            by _TSID_ &crossIDVar &timeIDvar;
18586 +        run;
18588 +        %do i = 1 %to &num_TSVar;
18589 +            %let i = &i;
18590 +            * transpose one cross-type time series data by TIMEID;
18591 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
18592 +                by _TSID_ &crossIDVar;
18593 +                var &&&TSVar&i;
18594 +            run;
18595 +        %end;
18597 +        * stack all horizontal time series;
18598 +        data &outDS;
18599 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
18600 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
18601 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
18602 +            %do i=1 %to &num_TSVar;
18603 +                if in&i then do;
18604 +                    _NAMEID_ ="&&&TSVar&i";
18605 +                    _ROLE_   ="&&&TSRole&i";
18606 +                end;
18607 +            %end;
18608 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
18609 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
18610 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
18611 +        run;
18612 +    %end;
18613 +%end;
18614 +%else %do;
18616 +    proc sql noprint;
18617 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
18618 +            order by _NAMEID_
18619 +        ;
18620 +    quit;
18622 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
18623 +        * transpose the panel-type time series data by TSID;
18624 +        proc sort data=&inDS out=_emtstp_tmpDat;
18625 +            by &timeIDvar;
18626 +        proc transpose data=_emtstp_tmpDat
18627 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
18628 +            by &timeIDVar;
18629 +            var &panelTSVar;
18630 +        run;
18631 +        proc datasets lib=work nolist;
18632 +            modify _emtstp_tmpDat2;
18633 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
18634 +            run; quit;
18635 +    %end;
18636 +    %else %do;
18637 +        * transpose the panel-type time series data by TIMEID;
18638 +        proc sort data=&inDS out=_emtstp_tmpDat;
18639 +            by &timeIDvar;
18640 +        data _emtstp_tmpDat;
18641 +            set _emtstp_tmpDat;
18642 +            _tmp_ind=_n_;
18643 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
18644 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
18645 +            ID _tmp_ind;
18646 +            var &panelTSVar;
18647 +        run;
18648 +    %end;
18650 +      * merge ID maps to the transpose data set;
18651 +      proc sql noprint;
18652 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
18653 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
18654 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
18655 +          ;
18656 +      quit;
18658 +      * update the TS ID map;
18659 +      data &outIDMap;
18660 +          set &inIDMap;
18661 +      run;
18662 +%end;
18664 +proc datasets lib=work nolist;
18665 +    delete _emtstp:;
18666 +run; quit;
18668 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_SCORE.SOURCE.
18670 +/*----------------------------------------------------------------------------------+
18671 + |
18672 + |   Title :  TS DP Score
18673 + |
18674 + |
18675 + |  Support : Taiyeong Lee(Taiyeong.Lee@sas.com)
18676 + |
18677 + +-----------------------------------------------------------------------------------*/
18678 +%macro EM_TSDP_SCORE;
18680 +%if &EM_IMPORT_DATA ne  %then %do;
18681 +    %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
18682 +    %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
18683 +%end;
18684 +%else %if &EM_IMPORT_TRANSACTION ne  %then %do;
18685 +    %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
18686 +    %let _FILE_CDELTA  = &EM_FILE_CDELTA_TRANSACTION;
18687 +%end;
18689 +%EM_GETNAME(KEY=OUTSEASON, TYPE=DATA);
18690 +%EM_GETNAME(KEY=TSMETA,    TYPE=DATA);
18691 +%EM_GETNAME(KEY=OUTDS,     TYPE=DATA);
18692 +%EM_GETNAME(KEY=TSIDMAP,   TYPE=DATA);
18694 +%let _seasonlength = ;
18695 +data &EM_USER_TSMETA;
18696 +    set &EM_USER_TSMETA;
18697 +    call symput('_seasonlength', userSeasonality);
18698 +run;
18700 +%if &EM_PROPERTY_EXPORTSEASONSTAT eq Y and &_seasonlength gt 1
18701 +%then %do;
18702 +    data  &_EXPORT_DATA;
18703 +        set &EM_USER_OUTSEASON;
18704 +        keep  _NAMEID_ _SEASON_ _TSID_ %EM_CROSSID
18705 +        %if  &EM_PROPERTY_SEASONSTAT eq ALL %then %do;
18706 +            SUM MAX MIN MEAN MEDIAN
18707 +        %end;
18708 +        %else %do;
18709 +            &EM_PROPERTY_SEASONSTAT
18710 +        %end;
18711 +        ;
18712 +    run;
18714 +    %if  &EM_PROPERTY_SEASONSTAT ne ALL %then %do;
18715 +        proc sort data =&_EXPORT_DATA out= &_EXPORT_DATA;
18716 +            by _TSID_ _NAMEID_ %EM_CROSSID  ;
18717 +        run;
18718 +        proc transpose data =&_EXPORT_DATA out= &_EXPORT_DATA prefix= SEASON ;
18719 +            by _TSID_ _NAMEID_ %EM_CROSSID  ;
18720 +        run;
18722 +        data &_EXPORT_DATA;
18723 +            set &_EXPORT_DATA;
18724 +            if _NAME_ ="_SEASON_" then delete;
18725 +            drop _NAME_ _LABEL_;
18726 +         run;
18727 +    %end;
18728 +%end;
18729 +%else %do;
18730 +    data  &_EXPORT_DATA;
18731 +        set &EM_USER_OUTDS;
18732 +    run;
18733 +%end;
18735 +data _null_;
18736 +    filename X "&_FILE_CDELTA";
18737 +    FILE X;
18738 +    put 'if upcase(NAME) eq "_TSID_"   then role="ID" ;' ;
18739 +    put 'if upcase(NAME) eq "_NAMEID_" then role="ID" ;' ;
18740 +    put 'if upcase(NAME) eq "_TSNAME_" then role="CROSSID" ;' ;
18741 +    put 'if upcase(NAME) eq "_TSVALUE_" then role="TARGET" ;' ;
18742 +    put 'if upcase(NAME) eq "_ROLE_"   then role="REJECTED" ;' ;
18743 +    %if &EM_PROPERTY_KEEPVARROLE eq Y %then %do;
18744 +       %if &EM_PROPERTY_TRANSBYVAR eq BYTSID %then %do;
18745 +           %let dsid=%sysfunc(open(&EM_USER_TSIDMAP(where=(strip(_ROLE_)="TARGET"))));
18746 +           %if &dsid > 0 %then %do;
18747 +               %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
18748 +               %do %while(^%sysfunc(fetch(&dsid)));
18749 +                   %let _nameid  = %sysfunc(getvarc(&dsid, &vn_nameid));
18750 +                   put "if upcase(NAME) eq upcase(strip('&_nameid')) then role='TARGET' ;" ;
18751 +               %end;
18752 +               %let dsid = %sysfunc(close(&dsid));
18753 +           %end;
18754 +       %end;
18755 +    %end;
18756 +run;
18758 +%mend EM_TSDP_SCORE;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      16:140
NOTE: There were 1 observations read from the data set EMWS5.TSDP3_TSMETA.
NOTE: The data set EMWS5.TSDP3_TSMETA has 1 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 78 observations read from the data set EMWS5.TSDP3_OUTDS.
NOTE: The data set EMWS5.TSDP3_TRAIN has 78 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The file X is:
      Filename=F:\WQD7005\MalaysiaStockPrediction-master\SAS\Mildstone5\Milestone5-Insight\Workspaces\EMWS5\TSDP3\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=19Dec2019:14:17:10,
      Create Time=19Dec2019:12:28:09
 
NOTE: 5 records were written to the file X.
      The minimum record length was 46.
      The maximum record length was 52.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
18759
18760
18761  *------------------------------------------------------------*;
18762  * End SCORE: TSDP3;
18763  *------------------------------------------------------------*;
 
18765  *------------------------------------------------------------*;
18766  * TSDP3: Computing metadata for TRAIN data;
18767  *------------------------------------------------------------*;
 
19118  proc sort data = EMWS5.Ids3_EMINFO OUT=WORK.SORTEDEMINFO NOTHREADS;
19119  by TARGET KEY;
19120  run;
 
NOTE: There were 3 observations read from the data set EMWS5.IDS3_EMINFO.
NOTE: The data set WORK.SORTEDEMINFO has 3 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
19121  proc sort data = EMWS5.TSDP3_EMINFO OUT=WORK.TEMP_INFO NOTHREADS;
19122  by TARGET KEY;
19123  run;
 
NOTE: There were 5 observations read from the data set EMWS5.TSDP3_EMINFO.
NOTE: The data set WORK.TEMP_INFO has 5 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
19124  data EMWS5.TSDP3_EMINFO;
19125  merge WORK.SORTEDEMINFO WORK.TEMP_INFO;
19126  by TARGET KEY;
19127  run;
 
NOTE: There were 3 observations read from the data set WORK.SORTEDEMINFO.
NOTE: There were 5 observations read from the data set WORK.TEMP_INFO.
NOTE: The data set EMWS5.TSDP3_EMINFO has 8 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
19128  proc datasets lib=work nolist;
19129  delete TEMP_INFO SORTEDEMINFO;
19130  run;
 
NOTE: Deleting WORK.TEMP_INFO (memtype=DATA).
NOTE: Deleting WORK.SORTEDEMINFO (memtype=DATA).
19131  quit;
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
*------------------------------------------------------------*
* Report Log
Date:                December 19, 2019
Time:                14:17:11
*------------------------------------------------------------*
19155  %let EMEXCEPTIONSTRING=;
19156  *------------------------------------------------------------*;
19157  * REPORT: TSDP3;
19158  *------------------------------------------------------------*;
19159  %let EM_ACTION = REPORT;
19160  %let syscc = 0;
19161
19162  %macro EM_TSDP_MAIN;
19163
19164     filename temp catalog 'sashelp.emtsdm.tsdp_macros.source';
19165     %include temp;
19166     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
19167     %include temp;
19168     filename temp;
19169
19170     %if %upcase(&EM_ACTION) = CREATE %then %do;
19171         filename temp catalog 'sashelp.emtsdm.tsdp_create.source';
19172         %include temp;
19173         filename temp;
19174         %EM_TSDP_CREATE;
19175     %end;
19176     %else
19177     %if %upcase(&EM_ACTION) = TRAIN %then %do;
19178          filename temp catalog 'sashelp.emtsdm.tsdp_train.source';
19179             %include temp;
19180             filename temp;
19181         %EM_TSDP_TRAIN;
19182     %end;
19183     %else
19184     %if %upcase(&EM_ACTION) = SCORE %then %do;
19185          filename temp catalog 'sashelp.emtsdm.tsdp_score.source';
19186             %include temp;
19187             filename temp;
19188         %EM_TSDP_SCORE;
19189     %end;
19190     %else
19191     %if %upcase(&EM_ACTION) = REPORT %then %do;
19192             filename temp catalog 'sashelp.emtsdm.tsdp_report.source';
19193             %include temp;
19194             filename temp;
19195          %EM_TSDP_REPORT;
19196     %end;
19197     %else
19198       %if %upcase(&EM_ACTION) = OPENTIMETABLEACTION  %then %do;
19199             filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
19200             %include temp;
19201             filename temp;
19202          %EM_TSDP_OpenTimeTable ;
19203     %end;
19204     %else
19205     %if %upcase(&EM_ACTION) = CLOSETABLEACTION  %then %do;
19206            filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
19207             %include temp;
19208             filename temp;
19209          %EM_TSDP_closeTimeTable ;
19210     %end;
19211
19212  %mend EM_TSDP_MAIN;
19213  %EM_TSDP_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_MACROS.SOURCE.
19214 +/*----------------------------------------------------------------------------------+
19215 + |
19216 + |   Title :
19217 + |   TS Data Preparation Node for Time Series Data Mining
19218 + |
19219 + |   Support : Taiyeong Lee( Taiyeong.Lee@sas.com)
19220 + |
19221 + |   Notes:
19222 + |
19223 + |----------------------------------------------------------------------------------*/
19226 +%Macro EM_TSDP_Timeseries(
19227 +    /*--- input data set and variables ----*/
19228 +    inds            = ,
19229 +    crossid         = ,
19230 +    timeid          = ,
19232 +      /*--- time ID variable ----------------*/
19233 +    interval        = ,
19234 +    accumulation    = ,
19235 +    timeidfmttype   = ,
19236 +    timeidformat    = ,
19237 +    start           = ,
19238 +    end             = ,
19239 +    seasonlength    = ,
19241 +      /*--- transformation ------------------*/
19242 +    transform       = ,
19243 +    boxcoxpara      = ,
19245 +      /*--- differencing --------------------*/
19246 +    applydif        = ,
19247 +    dif             = ,
19248 +    applysdif       = ,
19249 +    sdif            = ,
19251 +      /*--- missing intepretation------------*/
19252 +    missing         = ,
19253 +    missingconstant = ,
19254 +    zeromiss        = ,
19256 +      /*--- output data sets ----------------*/
19257 +    outds           = ,
19258 +    outsum          = ,
19259 +    outseason       =
19260 +);
19262 +/*%if &interval eq Hour or &interval eq Minute or &interval eq Second
19263 +    or &EM_PROPERTY_TIMEOFDAY eq Y or &timeidfmttype eq DATETIME   */
19264 +%if &timeidfmttype eq DATETIME
19265 +%then %do;
19266 +    %let _dtTag=DT;
19267 +%end;
19268 +%else %if &timeidfmttype eq TIME
19269 +%then %do;
19270 +    %let _dtTag=T;
19271 +%end;
19272 +%else %do;
19273 +    %let _dtTag=D;
19274 +%end;
19276 +proc sort data=&inds(keep = &crossid &timeid %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED)
19277 +     out=_tmpinds;
19278 +     by &crossid &timeid;
19279 +run;
19281 +proc timeseries data=_tmpinds out=&outds
19282 +    %if "&crossid" eq " "
19283 +        %then %do; outsum=&outsum(rename=(_NAME_=_NAMEID_)) %end;
19284 +        %else %do; outsum=&outsum %end;
19285 +    %if &seasonlength gt 1
19286 +    %then %do;
19287 +        outseason = &outseason seasonality= &seasonlength
19288 +    %end;
19289 +    ;
19291 +    %if &seasonlength gt 1
19292 +    %then %do;
19293 +        season SUM MEAN MIN MAX MEDIAN;
19294 +    %end;
19296 +    %if &crossid ne  %then %do;
19297 +        by &crossid;
19298 +    %end;
19300 +    id &timeid
19301 +        interval   = &interval
19302 +        accumulate = &accumulation
19303 +        %if &missing eq CONSTANT %then %do;
19304 +            setmissing = &missingconstant
19305 +        %end;
19306 +        %else %do;
19307 +            setmissing = &missing
19308 +        %end;
19309 +        %if &zeromiss ne NONE  %then %do;
19310 +            zeromiss = &zeromiss
19311 +        %end;
19312 +        %if &start ne  %then %do;
19313 +            %let  _start = "&start" ;
19314 +            start = &_start.&_dtTag
19315 +        %end;
19316 +        %if &end ne  %then %do;
19317 +            %let  _end = "&end";
19318 +            end = &_end.&_dtTag
19319 +        %end;
19320 +    ;
19322 +    var %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /
19323 +        %if &zeromiss ne NONE  %then %do;
19324 +            zeromiss = &zeromiss
19325 +        %end;
19326 +        %if &transform ne NONE  %then %do;
19327 +            %if &transform eq BOXCOX  %then %do;
19328 +                transform = BOXCOX(&boxcoxpara)
19329 +            %end;
19330 +            %else %do;
19331 +                transform = &transform
19332 +            %end;
19333 +        %end;
19334 +        %if &applydif eq Y  %then %do;
19335 +            dif = (&dif)
19336 +        %end;
19337 +        %if &applysdif eq Y %then %do;
19338 +            sdif = (&sdif)
19339 +        %end;
19340 +    ;
19341 +run;
19342 +quit;
19344 +%mend EM_TSDP_TimeSeries;
19347 +/*-----------------------------------------------------------------
19349 +    MERGE AFTER CLUSTERING
19351 ++------------------------------------------------------------------*/
19353 +%macro EM_TSDP_MergeAfterClustering();
19355 +/*--- need to fix the code based on data Role (train or transaction) ---*/
19357 +%EM_REGISTER(KEY=CLUSTS, TYPE=DATA);
19358 +%EM_GETNAME(KEY=CLUSTS, TYPE=DATA);
19360 +%let _train = ;
19361 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19362 +%if &dsid > 0 %then %do;
19363 + %let vn_data =%sysfunc(varnum(&dsid, DATA));
19364 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
19365 +%do %while(^ %sysfunc(fetch(&dsid)));
19366 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19367 +     %if &_key eq TSDRTRAIN %then %do;
19368 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
19369 +     %end;
19370 +     %else %if &_key eq TSDCTRAIN %then %do;
19371 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
19372 +     %end;
19373 +     %else %if &_key eq TSDPTRAINDS %then %do;
19374 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
19375 +     %end;
19376 +%end;
19377 +%end;
19378 +%let dsid = %sysfunc(close(&dsid));
19380 +proc sort data =&_train out=_inds;
19381 +     by %EM_CROSSID;
19382 +run;
19383 +proc sort data=&EM_IMPORT_DATA out=_outclus(KEEP= %EM_CROSSID _SEGMENT_);
19384 +      by %EM_CROSSID;
19385 +run;
19386 +data &EM_USER_CLUSTS;
19387 +     merge _inds _outclus;
19388 +     by %EM_CROSSID;
19389 +run;
19391 +proc sort data =&EM_USER_TSIDMAP;
19392 +     by %EM_CROSSID;
19393 +run;
19395 +data &EM_USER_TSIDMAP;
19396 +     merge &EM_USER_TSIDMAP _outclus;
19397 +     by %EM_CROSSID;
19398 +run;
19400 +data &EM_USER_CLUSTS ;
19401 +    merge  &EM_USER_TSIDMAP &EM_USER_CLUSTS;
19402 +     by %EM_CROSSID;
19403 +run;
19404 +quit;
19406 +%mend EM_TSDP_MergeAfterClustering;
19408 +%macro EM_TSDP_MergeTSID(inds=, tsidds=, byvar=, outds=);
19410 +    proc sort data =&inds out=_tmp_inds;
19411 +        by &byvar;
19412 +    proc sort data=&tsidds out=_tmp_tsidds;
19413 +        by &byvar;
19414 +    run;
19415 +    %if &outds eq %then %do;
19416 +        data &inds;
19417 +    %end;
19418 +    %else %do;
19419 +        data &outds;
19420 +    %end;
19421 +            merge _tmp_tsidds _tmp_inds;
19422 +            by &byvar;
19423 +        run;
19425 +    %EM_TS_DELETE_DATA(dsname=_tmp_inds);
19426 +    %EM_TS_DELETE_DATA(dsname=_tmp_tsidds);
19428 +%mend EM_TSDP_MergeTSID;
19430 +%macro EM_TS_SummaryDS(inDS=, crossid=);
19431 +    %let j=1;
19432 +    %do %while(%scan(&crossid, &j) ne );
19433 +        %let _csvar=%scan(&crossid, &j);
19434 +        %EM_REGISTER(KEY=OUTSUM&j, TYPE=DATA);
19435 +        %EM_GETNAME(KEY=OUTSUM&j, TYPE=DATA);
19436 +        %EM_TS_SummaryByCSID(inDS=&inDS, outDS=&EM_USER_OUTSUM&j,crossIDVar=&_csvar);
19437 +        %let j=%eval(&j+1);
19438 +    %end;
19439 +%mend EM_TS_SummaryDS;
19442 +%macro EM_TS_SummaryByCSID(inDS=, outDS=, RoleVar=_role_, TSVar=_varname_, crossIDVar=);
19443 +    proc sql noprint;
19444 +        create table &outDS as
19445 +            select distinct &RoleVar, &TSVar, &crossIDVAr,
19446 +                mean(mean1)  as mean      label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmean, noquote))",
19447 +                std(mean1)   as std_mean  label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smean, noquote))",
19448 +                mean(sum1)   as sum       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_msum, noquote))",
19449 +                std(sum1)    as std_sum   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_ssum, noquote))",
19450 +                mean(min1)   as min       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmin, noquote))",
19451 +                std(min1)    as std_min   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smin, noquote))",
19452 +                mean(max1)   as max       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmax, noquote))",
19453 +                std(max1)    as std_max   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smax, noquote))"
19454 +            from &inDS(rename=(mean=mean1 sum=sum1 min=min1 max=max1))
19455 +                group by &TSVar, &crossIDVar
19456 +                order by &TSVar, &crossIDVar
19457 +        ;
19458 +    quit;
19459 +%mend;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
19460 +/*
19461 +       MACRO: TS Utility macros
19463 +       PURPOSE: TS Utility macros
19464 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
19466 +       HISTORY:
19467 +       NOTE:
19469 +*/
19471 +/*
19472 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
19473 +                          timeid=, timeformat=, timeinformat=);
19474 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
19476 +    %do;
19477 +    %let m_data      = &data;
19478 +    %let m_decdata   = &decdata;
19479 +    %let m_decmeta   = &decmeta;
19480 +    %let m_cmeta     = &cmeta;
19481 +    %let m_outfile   = &outfile;
19482 +    %let m_crossid   = &crossid;
19483 +    %let m_timeid    = &timeid;
19484 +    %let m_timeformat    = &timeformat;
19485 +    %let m_timeinformat    = &timeinformat;
19486 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
19487 +  %end;
19488 +%mend EM_TS_CreateTsMetaDs;
19489 +*/
19490 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
19491 +proc sql;
19492 +      create table _tmp_inds
19493 +      as select distinct &timeid from  &indata;
19494 +quit;
19495 +run;
19496 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
19497 +  id &timeid
19498 +%if &timeinterval ne %then %do;
19499 +    %if &timeformattype eq DATE %then %do;
19500 +        interval=&timeinterval
19501 +    %end;
19502 +    %else %if &timeformattype eq DATETIME  %then %do;
19503 +        %let dttimeinterval= DT&timeinterval;
19504 +         interval=&dttimeinterval
19505 +    %end;
19506 +%end;
19507 +;
19508 +run;
19510 +data &outds;
19511 +     set _tmp_tsmeta;
19512 +     format START &timeformat;
19513 +     format END &timeformat;
19514 +     length APPLY_START_END $8;
19515 +     APPLY_START_END ="No";
19516 +     FORMAT = "&timeformat";
19517 +     ROLE ="TIMEID";
19518 +     rename TIMEID = NAME;
19519 +     rename SEASONALITY= LengthOfCycle;
19520 +     rename INTERVAL = TIMEINTERVAL ;
19521 +     rename FORMAT = TIMEFORMAT;
19522 +     output;
19523 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
19524 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
19525 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
19526 +run;
19528 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
19529 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
19531 +%mend EM_TS_CreateTSMetaData;
19535 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
19537 +/* if updated = Y it will pass the TSMETA created by just the previous node */
19539 +%let _tsmetads = ;
19541 +%if &updated = Y %then %do;
19542 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
19543 +%if %sysfunc(exist(&_tsmetads)) %then %do;
19544 +%goto endline;
19545 +%end;
19546 +%end;
19548 +%if &eminfodata eq %then %do;
19549 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19550 +    data &EM_DATA_EMINFO;
19551 +         set &EM_IMPORT_DATA_EMINFO;
19552 +    run;
19553 +%end;
19554 +%else %do;
19555 +    %let dsid=%sysfunc(open(&eminfodata));
19556 +    data &EM_DATA_EMINFO;
19557 +         set &eminfodata;
19558 +    run;
19559 +%end;
19560 +%if &dsid > 0 %then %do;
19561 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
19562 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
19563 +    %do %while(^ %sysfunc(fetch(&dsid)));
19564 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19565 +         %if &_key eq TSMETA %then %do;
19566 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
19567 +         %end;
19568 +    %end;
19569 +    %let dsid = %sysfunc(close(&dsid));
19570 +%end; /* the end of %if &dsid > 0 %then %do; */
19572 +%endline:
19574 +%if &_tsmetads ne %then %do;
19575 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
19576 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19577 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
19578 +         data &EM_USER_TSMETA;
19579 +                   set &_tsmetads;
19580 +         run;
19581 +    %end;
19582 +%end;
19584 +*proc print data=&EM_DATA_EMINFO;
19585 +*proc print data=&EM_IMPORT_DATA_EMINFO;
19586 +*run;
19587 +%MEND EM_TS_GETTSMETA;
19590 +/*
19591 +%macro EM_GETTSMETAVARS(TimeInterval=);
19592 +%global &TimeInterval;
19593 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19594 +%if &dsid > 0 %then %do;
19595 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19596 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
19597 +%do %while(^ %sysfunc(fetch(&dsid)));
19598 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19599 +     %if &_role eq TIMEID %then %do;
19600 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19601 +     %end;
19602 +%end;
19603 +%let dsid = %sysfunc(close(&dsid));
19604 +%end;
19605 +%MEND EM_GETTSMETAVARS;
19606 +*/
19607 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
19608 +%global &TimeInterval;
19609 +%global &TimeId;
19610 +%global &EndTime;
19611 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19612 +proc print data=&EM_USER_TSMETA;
19613 +run;
19614 +%if &dsid > 0 %then %do;
19615 +%if &TimeInterval ne %then %do;
19616 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19617 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19618 +    %do %while(^ %sysfunc(fetch(&dsid)));
19619 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19620 +        %if &_role eq TIMEID %then %do;
19621 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19622 +        %end;
19623 +     %end;
19624 +%end;
19625 +%if &TimeId ne %then %do;
19626 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
19627 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19628 +    %do %while(^ %sysfunc(fetch(&dsid)));
19629 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19630 +        %if &_role eq TIMEID %then %do;
19631 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
19632 +        %end;
19633 +    %end;
19634 +%end;
19636 +%if &EndTime ne %then %do;
19637 +    %let vn_end =%sysfunc(varnum(&dsid, END));
19638 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19639 +    %do %while(^ %sysfunc(fetch(&dsid)));
19640 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19641 +        %if &_role eq TIMEID %then %do;
19642 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19643 +        %end;
19644 +     %end;
19645 +%end;
19646 +%let dsid = %sysfunc(close(&dsid));
19647 +%end;
19648 +%MEND EM_TS_GETTSMETAVARS;
19652 +/*------------------------------------------------------------------
19654 +      Macro EM_GETTSIDMAP
19656 +------------------------------------------------------------------+*/
19659 +%macro EM_TS_GETTSIDMAP(updated=);
19661 +%let _tsidmap = ;
19663 +%if &updated = Y %then %do;
19664 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
19665 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19666 +%goto endline;
19667 +%end;
19668 +%end;
19670 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19671 +%if &dsid > 0 %then %do;
19672 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
19673 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
19674 +%do %while(^ %sysfunc(fetch(&dsid)));
19675 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19676 +     %if &_key eq TSIDMAP %then %do;
19677 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
19678 +     %end;
19679 +%end;
19681 +%let dsid = %sysfunc(close(&dsid));
19682 +%end;
19684 +%endline:
19686 +%if &_tsidmap ne %then %do;
19688 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
19689 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19691 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19692 +         data &EM_USER_TSIDMAP;
19693 +               set &_tsidmap;
19694 +         run;
19695 +    %end;
19696 +%end;
19697 +%MEND EM_TS_GETTSIDMAP;
19699 +/*------------------------------------------------------------------*/
19704 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
19705 +%global &value;
19708 +%let dsid = %sysfunc(open(&data));
19709 +%if &dsid > 0 %then %do;
19710 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
19711 +    %if &vn_var < 1 %then %do;
19712 +        %let &value = 0;
19713 +        %let dsid = %sysfunc(close(&dsid));
19714 +        %goto endline;
19715 +    %end;
19716 +%let dsid = %sysfunc(close(&dsid));
19717 +%end;
19719 +%let _tmp=_tmpDS;
19720 +proc means data=&data &stat;
19721 +     var &var;
19722 +     output out=&_tmp;
19723 +run;
19725 +%let dsid = %sysfunc(open(&_tmp));
19726 +%if &dsid > 0 %then %do;
19727 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
19728 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
19729 +     %do %while(^%sysfunc(fetch(&dsid)));
19730 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
19731 +         %if &_stat eq &stat %then %do;
19732 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
19733 +          %end;
19734 +      %end;
19735 +%let dsid = %sysfunc(close(&dsid));
19736 +%end;
19737 +proc datasets lib=work nolist;
19738 + delete &_tmp;
19739 +run;
19740 +%endline:
19741 +%MEND EM_TS_GET_STAT;
19744 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
19745 +%global &format;
19746 +%global &informat;
19747 +%let dsid = %sysfunc(open(&data));
19748 +%if &dsid > 0 %then %do;
19749 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19750 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
19751 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
19752 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
19753 +%end;
19754 +%let dsid = %sysfunc(close(&dsid));
19755 +%end;
19756 +%MEND EM_TS_GET_VAR_FORMAT;
19758 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
19759 +      %if &lib eq %then %let lib=work;
19760 +       proc datasets lib=&lib nolist;
19761 +              delete &dsname;
19762 +       run;
19763 +%Mend  EM_TS_DELETE_DATA;
19766 +%macro EM_TS_GetNObs(inds=, nobs=);
19767 +    %global &nobs;
19768 +    %let &nobs=0;
19769 +    data _null_;
19770 +        set &inds end=eof;
19771 +        if eof then call symput("&nobs", _N_);
19772 +    run;
19773 +    quit;
19775 +    /*
19776 +    %let dsid=%sysfunc(open(&outdata));
19777 +    %if dsid > 0 %then %do;
19778 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
19779 +        %let dsid = %sysfunc(close(&dsid));
19780 +     %end;
19781 +    */
19782 +%mend  EM_TS_GetNObs;
19785 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
19786 +%global &time1;
19787 +%global &time2;
19788 +%if &default = Y %then %do;
19789 +   data _null_;
19790 +        set &data end=eof;
19791 +        if _N_ = 1 then  call symput("&time1", DATE);
19792 +        if eof then call symput("&time2", DATE);
19793 +    run;%end;
19794 +%else %do;
19795 +    %let dsid = %sysfunc(open(&data));
19796 +    %if &dsid > 0 %then %do;
19797 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
19798 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
19799 +        %do %while(^%sysfunc(fetch(&dsid)));
19800 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
19801 +             %if &_index eq 1 %then %do;
19802 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
19803 +             %end;
19804 +             %if &_index eq 2 %then %do;
19805 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
19806 +             %end;
19807 +        %end;
19808 +    %let dsid = %sysfunc(close(&dsid));
19809 +    %end;
19810 +%end;
19812 +%MEND EM_TS_GET_TIME_VALUES;
19814 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
19815 +%global &exist;
19816 + %let &exist = N;
19817 +%let dsid = %sysfunc(open(&data));
19818 +%if &dsid > 0 %then %do;
19819 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19820 +%if &vn_var > 0 %then %do;
19821 +    %let &exist = Y;
19822 +%end;
19823 +%let dsid = %sysfunc(close(&dsid));
19824 +%end;
19825 +%MEND EM_TS_GET_VAR_EXIST;
19828 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
19829 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
19830 +      set &intreedata;
19831 +        LENGTH NodeType $32;
19832 +      if _PARENT_ eq " " then delete;
19833 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
19834 +        else NodeType = "CLUSTER";
19835 +        LinkID = _N_;
19836 +run;
19837 +%Mend EM_TS_MakeConstellPlotData;
19842 +%macro EM_TS_CreateIDMap(
19843 +/*-------------------------------------------------------------------------*/
19844 +/*---   Written by Xiangxiang Meng                                         */
19845 +/*-------------------------------------------------------------------------*/
19846 +inDS          =,      /* imported data set in TS data mining               */
19847 +outIDMap      =,      /* output data set of TS ID map                      */
19848 +outDS         =,      /* output data set of TS and TS ID merged            */
19849 +variableSet   =,      /* EM variable set                                   */
19850 +TSIDbyCrossID =Y,
19851 +inEM          =Y
19852 +/*-------------------------------------------------------------------------*/
19853 +);
19855 +%global EM_TS_ERR;
19856 +%let EM_TS_ERR = 0;
19858 +%if &inEM eq Y %then %do;
19859 +    %let num_crossIDVar = &EM_NUM_CROSSID;
19860 +    proc sql noprint;
19861 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
19862 +    quit;
19863 +%end;
19864 +%else %do;
19865 +    proc sql noprint;
19866 +         select count(*) into :num_crossIDVar from &variableSet
19867 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19868 +         ;
19869 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
19870 +         ;
19871 +    quit;
19872 +    %let num_crossIDVar=&num_crossIDVar;
19873 +%end;
19875 +* see if _TSID_ exists;
19877 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
19878 +run;
19880 +proc sql noprint;
19881 +    select count(*) into :has_TSID
19882 +        from _emtscm_contents
19883 +        where upcase(strip(name)) eq '_TSID_'
19884 +    ;
19885 +quit;
19887 +/*-------------------------------------------------------------------------*/
19888 +* Creating TSID map..;
19889 +/*-------------------------------------------------------------------------*/
19891 +%if (&num_crossIDVar gt 0) %then %do;
19893 +    data _emtscm_tmpIDMap;
19894 +        set &variableSet;
19895 +        where  (upcase(strip(level)) eq 'INTERVAL')
19896 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
19897 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
19898 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
19899 +          );
19900 +        _emts_dummy=1;
19901 +        keep name label role _emts_dummy;
19902 +    run;
19904 +    proc sql noprint;
19905 +        * create a string of crossID variable like A,B,C,D..;
19906 +        select distinct name into :crossIDVar separated by ','
19907 +            from &variableSet
19908 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19909 +            order by name
19910 +        ;
19911 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
19912 +            from &variableSet
19913 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19914 +            order by name
19915 +        ;
19916 +        * create the TSID map data set;
19917 +        create table _emtscm_tmp1 as
19918 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
19919 +        ;
19920 +        * create a level list of cross ID variables and time series variables;
19921 +        create table &outIDMap as
19922 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
19923 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
19924 +            where a._emts_dummy eq b._emts_dummy
19925 +            order by a.name, &crossIDVar
19926 +        ;
19927 +    quit;
19929 +    %if &TSIDbyCrossID = Y %then %do;
19930 +        * create unique TSID only by Cross ID;
19931 +        data &outIDMap;
19932 +            length _TSID_ 8;
19933 +            set &outIDMap;
19934 +            by _NAMEID_;
19935 +            if first._NAMEID_
19936 +                then _TSID_=1;
19937 +                else _TSID_+1;
19938 +        run;
19939 +        %if "&outDS" ne "" %then %do;
19940 +            * merge TSID into &inDS;
19941 +            proc sql noprint;
19942 +                create table &outDS as
19943 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
19944 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
19945 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
19946 +                        where %do i = 1 %to &num_crossIDVar;
19947 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
19948 +                              %end;
19949 +                             b._TSID_ is not missing
19950 +                    order by b._TSID_, a.&timeIDVar
19951 +                ;
19952 +            quit;
19953 +        %end;
19954 +    %end;
19955 +    %else %do;
19956 +        * create unique TSID by Cross ID and _NAMEID_;
19957 +        data &outIDMap;
19958 +            length _TSID_ 8;
19959 +            set &outIDMap;
19960 +            _TSID_=_n_;
19961 +        run;
19962 +        %if "&outDS" ne "" %then %do;
19963 +            *no merge in this output;
19964 +            data &outDS;
19965 +                set &inDS;
19966 +            run;
19967 +        %end;
19968 +    %end;
19970 +    proc sort data=&outIDMap;
19971 +        by _NAMEID_ _TSID_;
19972 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
19973 +        format _TSID_ best12. _NAMEID2_ $40.;
19974 +        set &outIDMap;
19975 +        by _NAMEID_;
19976 +        if first._NAMEID_
19977 +            then _emts_ind=1;
19978 +            else _emts_ind+1;
19979 +        drop _emts_ind;
19980 +        rename _NAMEID_=_VARNAME_;
19981 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
19982 +        if _labelID_ eq ' '
19983 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
19984 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
19985 +    run;
19987 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
19989 +%end;
19990 +%else %do; /* if no crossid's the nameid needs to be created */
19992 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
19993 +        length _TSID_ 8;
19994 +        set &variableSet;
19995 +        where  (upcase(strip(level)) eq 'INTERVAL')
19996 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
19997 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
19998 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
19999 +          );
20000 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
20001 +        rename ROLE = _ROLE_;
20002 +        _NAMEID_=strip(name);
20003 +        _VARNAME_=strip(name);
20004 +        if label eq ' '
20005 +            then _LABELID_ = strip(name);
20006 +            else _LABELID_ = strip(label);
20007 +        _TSID_=_n_;
20008 +    run;
20010 +    %if "&outDS" ne "" %then %do;
20011 +        *no merge in this output;
20012 +        data &outDS;
20013 +            set &inDS;
20014 +        run;
20015 +    %end;
20016 +%end;
20018 +data &outIDMap;
20019 +    set &outIDMap;
20020 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
20021 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
20022 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
20023 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
20024 +run;
20026 +proc datasets lib=work nolist;
20027 +    delete _emtscm_:;
20028 +run; quit;
20030 +%mend EM_TS_createIDMap;
20032 +%macro EM_TS_CreateMetaData(
20033 +/*-------------------------------------------------------------------------*/
20034 +  inDS          =,      /* imported data set in TS data mining             */
20035 +  outDS         =,      /* output data set of TS metadata                  */
20036 +  variableSet   =,      /* EM variable set                                 */
20037 +  timeInterval  =,      /* time interval                                   */
20038 +  rc            =       /* return code                                     */
20039 +/*-------------------------------------------------------------------------*/
20040 +);
20042 +%if %eval(
20043 +      &EM_NUM_BINARY_INPUT   +
20044 +      &EM_NUM_ORDINAL_INPUT  +
20045 +      &EM_NUM_NOMINAL_INPUT  +
20046 +      &EM_NUM_BINARY_REJECTED   +
20047 +      &EM_NUM_ORDINAL_REJECTED  +
20048 +      &EM_NUM_NOMINAL_REJECTED  +
20049 +      &EM_NUM_ORDINAL_TARGET  +
20050 +      &EM_NUM_NOMINAL_TARGET +
20051 +      &EM_NUM_BINARY_TARGET
20052 +      ) > 0
20053 +%then %do;
20054 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
20055 +        %put &em_codebar;
20056 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
20057 +        %put &errormsg;
20058 +        %put &em_codebar;
20059 +        %goto ENDLINE;
20060 +%end;
20062 +%global EM_TS_ERR;
20063 +%let EM_TS_ERR = 0;
20065 +%if &timeInterval eq AUTO
20066 +    %then %let timeInterval  = ;
20067 +    %else %let timeInterval  = %upcase(&timeInterval);
20069 +/*-------------------------------------------------------------------------*/
20070 +* check time ID variable;
20071 +/*-------------------------------------------------------------------------*/
20073 +* number of variables in the Variableset with ROLE=TIMEID;
20074 +proc sql noprint;
20075 +    select count(*) into :num_timeID from &variableset
20076 +        where upcase(role) eq 'TIMEID';
20077 +quit;
20079 +/*-------------------------------------------------------------------------*/
20080 +* process only when there is one Time ID, otherwise exception message;
20081 +/*-------------------------------------------------------------------------*/
20083 +%if &num_timeID eq 0 %then %do;
20085 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
20086 +    %let EM_TS_ERR = 11;
20087 +    %put &em_codebar;
20088 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
20089 +    %put &errormsg;
20090 +    %put &em_codebar;
20091 +    %goto tscm_endline;
20093 +%end;
20094 +%else %if &num_timeID gt 1 %then %do;
20096 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
20097 +    %let EM_TS_ERR = 12;
20098 +    %put &em_codebar;
20099 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
20100 +    %put &errormsg;
20101 +    %put &em_codebar;
20102 +    %goto tscm_endline;
20104 +%end;
20105 +%else %do;
20106 +    *** proceed when there is one Time ID;
20108 +    data _null_;
20109 +        set &variableset(where=(upcase(role)='TIMEID'));
20110 +        call symput('timeIDFormat',     strip(format));
20111 +        call symput('timeID',           strip(upcase(name)      ));
20112 +        call symput('timeIDLevel',      strip(upcase(level))     );
20113 +        call symput('timeIDFormatType', strip(upcase(formattype)));
20114 +    run;
20116 +    *** exception message if the time ID is not an interval variable;
20117 +    %if &timeIDLevel ne INTERVAL %then %do;
20118 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
20119 +        %let EM_TS_ERR = 13;
20120 +        %put &em_codebar;
20121 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
20122 +        %put &errormsg;
20123 +        %put &em_codebar;
20124 +        %goto tscm_endline;
20125 +    %end;
20127 +    %if (&timeIDFormatType ne DATETIME) and
20128 +        (&timeIDFormatType ne DATE) and
20129 +        (&timeIDFormatType ne TIME) and
20130 +        (&timeIDFormatType ne USER)
20131 +    %then %do;
20132 +        *** sequential format-type of time ID;
20134 +        %let timeInterval = DAY;
20135 +        %let timeIDFormatType = SEQ;
20137 +        proc sql noprint;
20138 +            create table _emtscm_inds as
20139 +                 select distinct &timeID from &inDS(keep=&timeID)
20140 +                 where &timeID is not missing;
20141 +            select count(*) into :num_nonInteger from _emtscm_inds
20142 +                where &timeID ne int(&timeID);
20143 +        quit;
20145 +        %if &num_nonInteger gt 0 %then %do;
20146 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
20147 +            %let EM_TS_ERR = 14;
20148 +            %put &em_codebar;
20149 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
20150 +            %put &errormsg;
20151 +            %put &em_codebar;
20152 +            %goto tscm_endline;
20153 +        %end;
20154 +    %end;
20155 +    %else %do;
20156 +        *** date, datetime, time format-type of time ID;
20158 +        *** must have a format;
20159 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
20160 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
20161 +            %let EM_TS_ERR = 15;
20162 +            %put &em_codebar;
20163 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
20164 +            %put &errormsg;
20165 +            %put &em_codebar;
20166 +            %goto tscm_endline;
20167 +        %end;
20169 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
20170 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
20171 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
20172 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
20173 +                %let EM_TS_ERR = 16;
20174 +                %put &em_codebar;
20175 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
20176 +                %put &errormsg;
20177 +                %put &em_codebar;
20178 +                %goto tscm_endline;
20179 +            %end;
20180 +        %end;
20182 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
20183 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
20184 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
20185 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
20186 +                %let EM_TS_ERR = 17;
20187 +                %put &em_codebar;
20188 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
20189 +                %put &errormsg;
20190 +                %put &em_codebar;
20191 +                %goto tscm_endline;
20192 +            %end;
20193 +        %end;
20195 +        *** the AUTO function is currently turned off for TIME timeID variable;
20196 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
20197 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
20198 +            %let EM_TS_ERR = 18;
20199 +            %put &em_codebar;
20200 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
20201 +            %put &errormsg;
20202 +            %put &em_codebar;
20203 +            %goto tscm_endline;
20204 +        %end;
20206 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
20207 +            %then %let timeInterval =DT&timeInterval;
20209 +        proc sql noprint;
20210 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
20211 +                where &timeID is not missing;
20212 +        quit;
20213 +    %end;
20215 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
20216 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
20217 +    run;
20219 +    %let hasValidInterval = 0;
20220 +    %let hasLengthOne     = 0;
20222 +    proc sql noprint;
20223 +        create table _emtscm_label as
20224 +            select name,label
20225 +            from dictionary.columns
20226 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
20227 +        ;
20228 +        create table _emtscm_meta2 as
20229 +            select a.*, b.label
20230 +            from _emtscm_meta as a, _emtscm_label as b
20231 +            where upcase(a.timeID) eq upcase(b.name)
20232 +        ;
20233 +    quit;
20235 +    data &outDS;
20236 +        set _emtscm_meta2;
20237 +        format
20238 +            timeformat      $30.
20239 +            role            $10.
20240 +            start           &timeIDformat
20241 +            end             &timeIDformat
20242 +            apply_start_end $8.
20243 +        ;
20244 +        rename
20245 +            timeID      = name
20246 +            seasonality = lengthOfCycle
20247 +            interval    = timeinterval
20248 +        ;
20249 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
20251 +        role            = "TIMEID";
20252 +        apply_start_end = 'N';
20253 +        timeformat      = symget('timeIDformat');
20254 +        timeformattype  = symget('timeIDformatType');
20256 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
20257 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
20258 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
20259 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
20260 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
20261 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
20262 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
20263 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
20264 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
20265 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
20267 +        if timeformattype eq 'SEQ' then do;
20268 +            timeformat='BEST12.';
20269 +            seasonality=1;
20270 +        end;
20272 +        call symput('_tinterval',interval);
20274 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
20276 +        if upcase(timeformattype) eq 'DATE' and
20277 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
20278 +            then call symput('hasValidInterval',1);
20280 +        if upcase(timeformattype) eq 'DATETIME' and
20281 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
20282 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
20283 +            then call symput('hasValidInterval',1);
20285 +        if upcase(timeformattype) eq 'TIME' and
20286 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
20287 +            then call symput('hasValidInterval',1);
20289 +        if upcase(timeformattype) eq 'SEQ'
20290 +            then call symput('hasValidInterval',1);
20292 +        if upcase(timeformattype) eq 'USER'
20293 +            then call symput('hasValidInterval',1);
20295 +        if start eq end
20296 +            then call symput('hasLengthOne',1);
20297 +    run;
20299 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
20301 +    *** detect any missing time interval after running PROC TIMEID;
20302 +    %if &_tinterval eq %then %do;
20303 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
20304 +        %let EM_TS_ERR = 19;
20305 +        %put &em_codebar;
20306 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
20307 +        %put &errormsg;
20308 +        %put &em_codebar;
20309 +        %goto tscm_endline;
20310 +    %end;
20312 +    *** detect any missing time interval after running PROC TIMEID;
20313 +    %if &hasValidInterval eq 0 %then %do;
20314 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
20315 +        %let EM_TS_ERR = 20;
20316 +        %put &em_codebar;
20317 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
20318 +        %put &errormsg;
20319 +        %put &em_codebar;
20320 +        %goto tscm_endline;
20321 +    %end;
20323 +    %if &hasLengthOne eq 1 %then %do;
20324 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
20325 +        %let EM_TS_ERR = 21;
20326 +        %put &em_codebar;
20327 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
20328 +        %put &errormsg;
20329 +        %put &em_codebar;
20330 +        %goto tscm_endline;
20331 +    %end;
20333 +%end;
20335 +%tscm_endline:;
20337 +%mend EM_TS_CreateMetaData;
20340 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
20342 +data _null_;
20343 +    set &tsmeta;
20344 +    call symput('_timeidFormatType', timeformattype);
20345 +    call symput('_timeid', strip(name));
20346 +    call symput('_seqstartnum',strip(put(start,best12.)));
20347 +run;
20349 +proc contents data=&inDS noprint
20350 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20351 +run; quit;
20353 +data _null_;
20354 +    set _emts_tmpp1;
20355 +    call symput('_timeIDlabel',label);
20356 +run;
20358 +%if &_timeidFormatType eq SEQ
20359 +%then %do;
20360 +    proc sql noprint;
20361 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
20362 +    quit;
20363 +    %let _dummystarttime=&_dummystarttime;
20365 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20366 +        set &inDS;
20367 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
20368 +        drop &_timeid;
20369 +        label _tsdp_tmpID = "&_timeIDlabel";
20371 +    run;
20372 +%end;
20374 +%mend;
20376 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
20378 +data _null_;
20379 +    set &tsmeta;
20380 +    call symput('_timeidFormatType', timeformattype);
20381 +    call symput('_timeidFormat', timeformat);
20382 +    call symput('_timeid', strip(name));
20383 +    call symput('_timeinterval',strip(upcase(timeinterval)));
20384 +run;
20386 +/* manually change time ID format to a longer enough time format */
20387 +/* because proc timeid returns time5. for second time interval */
20388 +/* which is not long enough for transpose with time unit as seconds */
20389 +%if &_timeinterval eq SECOND
20390 +%then %do;
20391 +    %let _timeIDformat = %str(time8.);
20392 +%end;
20394 +proc contents data=&inDS noprint
20395 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20396 +run; quit;
20398 +data _null_;
20399 +    set _emts_tmpp1;
20400 +    call symput('_timeIDlabel',label);
20401 +run;
20403 +%if &_timeidFormatType eq TIME
20404 +%then %do;
20405 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20406 +        set &inDS;
20407 +        _tsdp_tmpID = timepart(&_timeID);
20408 +        format _tsdp_tmpID &_timeidFormat;
20409 +        label  _tsdp_tmpID = "&_timeIDlabel";
20410 +        drop &_timeid;
20411 +    run;
20412 +%end;
20414 +%mend;
20416 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
20418 + proc sql noprint;
20419 +     create table _tmptimetable as
20420 +         select distinct &timeidvar as DATE from &inDS
20421 +         where &timeIDVar is not missing
20422 +         order by &timeIDVar;
20423 + quit;
20425 +%if &compare eq Y %then %do;
20426 +    * compare with the existing time table;
20427 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
20428 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
20429 +    run;
20431 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
20433 +    %if &_diffobs > 0 %then %do; /* create it again */
20434 +        data &outDS(keep=DATE _INDEX_);
20435 +            set _tmptimetable end = _eof_;
20436 +            if _N_ = 1
20437 +                then _INDEX_ = 1;
20438 +                else _INDEX_ = 0;
20439 +            if _eof_ then _INDEX_= 2;
20440 +        run;
20441 +    %end;
20443 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
20444 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20445 +%end;
20446 +%else %do;
20447 +    * create a new time table directly;
20448 +    data &outDS(keep=DATE _INDEX_);
20449 +        set _tmptimetable end = _eof_;
20450 +        if _N_ = 1
20451 +            then _INDEX_ = 1;
20452 +            else _INDEX_ = 0;
20453 +        if _eof_ then _INDEX_= 2;
20454 +    run;
20456 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20457 +%end;
20459 +* assign a defult format BEST12. for sequential time ID;
20461 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
20463 +%let _nodatefmt=N;
20465 +data _null_;
20466 +    set _tmpcontents;
20467 +    where upcase(name) eq 'DATE';
20468 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
20469 +run;
20471 +%if "&_nodatefmt" eq "Y" %then %do;
20472 +    data &outDS;
20473 +        set &outDS;
20474 +        format date best12.;
20475 +    run;
20476 +%end;
20478 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
20480 +%mend;
20484 +%macro EM_TS_Transpose(
20485 +/*-------------------------------------------------------------------------*/
20486 +  inDS          =,      /* imported data set in TS data mining             */
20487 +  inIDMap       =,      /* input TS ID map                                 */
20488 +  variableSet   =,      /* variable set                                    */
20489 +  transposeBy   =,      /* byTSID or byTimeID                              */
20490 +  outDS         =,      /* output transposed data set                      */
20491 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
20492 +  inEM          =Y,
20493 +  timePrefix    =_T
20494 +/*-------------------------------------------------------------------------*/
20495 +);
20497 +%let timePrefix = &timePrefix;
20499 +%if  &EM_NUM_CROSSID > 0 %then %do;
20501 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
20502 +    set &inIDMap;
20503 +    drop _NAMEID_;
20504 +    run;
20505 +%let inIDMap=_emtstp_map0;
20507 +%end;
20509 +proc sql noprint;
20510 +    * number of TS Variables to be transposed;
20511 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
20512 +    ;
20513 +    * number of TS Variables to be transposed;
20514 +    select max(_TSID_) into :num_TSID from &inIDMap
20515 +    ;
20516 +    * name list of TS Variables;
20517 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
20518 +        from &inIDMap
20519 +        order by _NAMEID_
20520 +    ;
20521 +    * total number of time series =max(_TSID_)*&num_TSVar;
20522 +    * and the number of digits of this variable is &num_digits;
20523 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
20524 +        from &inIDMap
20525 +    ;
20526 +      * Time ID variable;
20527 +    select name into:timeIDVar from &variableset
20528 +        where upcase(role) eq 'TIMEID'
20529 +    ;
20530 +quit;
20531 +%let num_digits = &num_digits;
20532 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
20534 +/*-------------------------------------------------------------------------*/
20536 +* get number of cross IDs and also the TIME ID variable name;
20537 +%if &inEM eq Y %then %do;
20538 +    %let num_crossIDVar = &EM_NUM_CROSSID;
20539 +    %let crossIDVar     = %EM_CROSSID;
20540 +%end;
20541 +%else %do;
20542 +    proc sql noprint;
20543 +        * number of cross ID;
20544 +        select count(*) into :num_crossIDVar
20545 +            from &variableSet
20546 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20547 +        ;
20548 +        * create a string of crossID variable like A B C D..;
20549 +        select distinct name into :crossIDVar separated by ' '
20550 +            from &variableSet
20551 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20552 +            order by name
20553 +        ;
20554 +    quit;
20555 +    %let num_crossIDVar=&num_crossIDVar;
20556 +%end;
20558 +/*-------------------------------------------------------------------------*/
20560 +%if (&num_crossIDVar gt 0) %then %do;
20562 +    data _emtstp_tmpDat;
20563 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
20564 +        _NAMEID_ = cats("_TS_",_TSID_);
20565 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
20566 +    run;
20568 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20570 +        * update the ID maps;
20571 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20572 +            by _NAMEID_ _TSID_;
20573 +        data &outIDMap;
20574 +            set _emtstp_tmpmap;
20575 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20576 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20577 +        run;
20579 +        * get the names for the new variables;
20580 +        proc sql noprint;
20581 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
20582 +            ;
20583 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
20584 +            ;
20585 +        quit;
20587 +        * data must be sorted before transposed;
20588 +        proc sort data=_emtstp_tmpDat;
20589 +            by &timeIDvar;
20590 +        run;
20592 +        %do i = 1 %to &num_TSVar;
20593 +            %let i = &i;
20594 +            * transpose one cross-type time series data by TSID;
20595 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
20596 +                id _NAMEID_;
20597 +                by &timeIDVar;
20598 +                var &&&TSVar&i;
20599 +            run;
20600 +        %end;
20602 +        * merge all vertical time series, rename and label them;
20603 +        data &outDS;
20604 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
20605 +            by &timeIDVar;
20606 +            rename
20607 +                %do i = 1 %to &num_TSVar;
20608 +                    %do j = 1 %to &num_TSID;
20609 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20610 +                        /* %put &i &j &num1 &num_TSID; */
20611 +                        _V_&i._TS_&j = &&&tsname&num1
20612 +                    %end;
20613 +                %end;
20614 +            ;
20615 +            label
20616 +                %do i = 1 %to &num_TSVar;
20617 +                    %do j = 1 %to &num_TSID;
20618 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20619 +                        /* %put &i &j &num1 &num_TSID; */
20620 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
20621 +                    %end;
20622 +                %end;
20623 +            ;
20624 +        run;
20625 +    %end;
20626 +    %else %do;
20628 +        * update the ID maps;
20629 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20630 +            by _NAMEID_ _TSID_;
20631 +        data &outIDMap;
20632 +            set _emtstp_tmpmap;
20633 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20634 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20635 +        run;
20637 +        proc sql noprint;
20638 +            * get the roles for the new variables;
20639 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
20640 +                from &inIDMap
20641 +                order by _NAMEID_
20642 +            ;
20643 +            * get the length of the time series;
20644 +            select count(distinct &timeIDvar) into :num_T
20645 +                from _emtstp_tmpDat
20646 +            ;
20647 +        quit;
20649 +        * data must be sorted before transposed;
20650 +        proc sort data=_emtstp_tmpDat;
20651 +            by _TSID_ &crossIDVar &timeIDvar;
20652 +        run;
20654 +        %do i = 1 %to &num_TSVar;
20655 +            %let i = &i;
20656 +            * transpose one cross-type time series data by TIMEID;
20657 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
20658 +                by _TSID_ &crossIDVar;
20659 +                var &&&TSVar&i;
20660 +            run;
20661 +        %end;
20663 +        * stack all horizontal time series;
20664 +        data &outDS;
20665 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
20666 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
20667 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
20668 +            %do i=1 %to &num_TSVar;
20669 +                if in&i then do;
20670 +                    _NAMEID_ ="&&&TSVar&i";
20671 +                    _ROLE_   ="&&&TSRole&i";
20672 +                end;
20673 +            %end;
20674 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
20675 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
20676 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
20677 +        run;
20678 +    %end;
20679 +%end;
20680 +%else %do;
20682 +    proc sql noprint;
20683 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
20684 +            order by _NAMEID_
20685 +        ;
20686 +    quit;
20688 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20689 +        * transpose the panel-type time series data by TSID;
20690 +        proc sort data=&inDS out=_emtstp_tmpDat;
20691 +            by &timeIDvar;
20692 +        proc transpose data=_emtstp_tmpDat
20693 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
20694 +            by &timeIDVar;
20695 +            var &panelTSVar;
20696 +        run;
20697 +        proc datasets lib=work nolist;
20698 +            modify _emtstp_tmpDat2;
20699 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
20700 +            run; quit;
20701 +    %end;
20702 +    %else %do;
20703 +        * transpose the panel-type time series data by TIMEID;
20704 +        proc sort data=&inDS out=_emtstp_tmpDat;
20705 +            by &timeIDvar;
20706 +        data _emtstp_tmpDat;
20707 +            set _emtstp_tmpDat;
20708 +            _tmp_ind=_n_;
20709 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
20710 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
20711 +            ID _tmp_ind;
20712 +            var &panelTSVar;
20713 +        run;
20714 +    %end;
20716 +      * merge ID maps to the transpose data set;
20717 +      proc sql noprint;
20718 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
20719 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
20720 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
20721 +          ;
20722 +      quit;
20724 +      * update the TS ID map;
20725 +      data &outIDMap;
20726 +          set &inIDMap;
20727 +      run;
20728 +%end;
20730 +proc datasets lib=work nolist;
20731 +    delete _emtstp:;
20732 +run; quit;
20734 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_REPORT.SOURCE.
20735 +%macro EM_TSDP_REPORT;
20737 +%EM_GETNAME(KEY=TSIDMAPSUM, TYPE=DATA);
20738 +%EM_GETNAME(KEY=TSIDMAP,    TYPE=DATA);
20739 +%EM_GETNAME(KEY=TSMETA,     TYPE=DATA);
20740 +%EM_GETNAME(KEY=OUTSUMMARY, TYPE=DATA);
20741 +%EM_GETNAME(KEY=OUTSEASON,  TYPE=DATA);
20742 +%EM_GETNAME(KEY=OUTDS,      TYPE=DATA);
20744 +%let _EXPORT_DATA  = &EM_USER_OUTDS;
20745 +%let _EXPORT_DSKEY = OUTDS;
20746 +%let n_max_tsplot  = &EM_PROPERTY_NMaxTSPlot;
20747 +%let _crossidvar   = %EM_CROSSID;
20749 +%let viewnum=1;
20751 +%EM_REPORT(key=TSMETA,  view=&viewnum, viewtype=DATA, block=Model, Autodisplay=Y, description=tsmetatable) ;
20752 +%let viewnum=%eval(&viewnum+1);
20754 +%EM_REPORT(key=TSIDMAP, view=&viewnum, viewtype=DATA, block=Model, Autodisplay=Y, description=tsidmaptable) ;
20755 +%let viewnum=%eval(&viewnum+1);
20757 +%EM_TS_GetNObs(inds=&EM_USER_TSIDMAP, nobs=_tsdp_tsidmap_n);
20760 +%let _str_mean   = %sysfunc(sasmsg(sashelp.dmine, rpt_timeseries_label_mean, noquote));
20761 +%let _str_min    = %sysfunc(sasmsg(sashelp.dmine, rpt_timeseries_label_min, noquote));
20762 +%let _str_max    = %sysfunc(sasmsg(sashelp.dmine, rpt_timeseries_label_max, noquote));
20763 +%let _str_sum    = %sysfunc(sasmsg(sashelp.dmine, rpt_timeseries_label_sum, noquote));
20764 +%let _str_median = %sysfunc(sasmsg(sashelp.dmine, rpt_timeseries_label_median, noquote));
20766 +/*--------------------------------------------------------------------
20768 +%if (&_crossidvar ne ) %then %do;
20770 +  %if (&_tsdp_tsidmap_n > 0 ) %then %do;
20771 +    proc dmdb data=&EM_USER_TSIDMAP classout=&EM_USER_TSIDMAPSUM;
20772 +      class &_crossidvar ;
20773 +    run;
20774 +    data _tmp_a;
20775 +       NAME = "TSID";
20776 +       FREQUENCY = &_tsdp_tsidmap_n;
20777 +       FREQPERCENT = 100;
20778 +       output;
20779 +    run;
20780 +    data &EM_USER_TSIDMAPSUM;
20781 +       set &EM_USER_TSIDMAPSUM _tmp_a;
20782 +    rename NAME=VARIABLE;
20783 +    rename FREQUENCY=COUNT;
20784 +    rename FREQPERCENT=PERCENT;
20785 +    Label  NAME  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name, noquote))";
20786 +    Label  FREQUENCY  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_count, noquote))";
20787 +    Label  FREQPERCENT = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_percent, noquote))";
20788 +    Label  LEVEL  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_level, noquote))";
20789 +    keep NAME LEVEL FREQUENCY FREQPERCENT;
20790 +    run;
20791 +    %EM_TS_DELETE_DATA(dsname=_tmp_a);
20792 +    %EM_REPORT(key=TSIDMAPSUM,  viewtype=DATA, block=Model,  Autodisplay=Y, description=sumtsidmap) ;
20796 +    %EM_TSDP_MergeTSID(inds=&EM_USER_OUTSUMMARY, tsidds=&EM_USER_TSIDMAP, byvar=%EM_CROSSID, outds=);
20797 +    %let j=1;
20798 +    %do %while(%scan(&_crossidVar, &j) ne );
20799 +       %let _csvar=%scan(&_crossidVar, &j);
20800 +           %let TitleOutSumPlot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsdp_outsumplot, noquote, &_csvar));
20801 +           %EM_REPORT(key=OUTSUMMARY,  viewtype=BAR, view=&j, block=Plot, Autodisplay=Y, x=_TSID_, FREQ=MEAN, group=&_csvar, description=&TitleOutSumPlot) ;
20802 +           %EM_REPORT(VIEW=&j, Freq=SUM);
20803 +           %EM_REPORT(VIEW=&j, Freq=MAX);
20804 +           %EM_REPORT(VIEW=&j, Freq=MIN);
20805 +           %EM_REPORT(VIEW=&j, Freq=STDDEV);
20806 +           %EM_REPORT(VIEW=&j, Freq=N);
20807 +           %EM_REPORT(VIEW=&j, Freq=NMISS);
20808 +           %EM_REPORT(VIEW=&j, Freq=NOBS);
20809 +       %let j=%eval(&j+1);
20810 +     %end;
20813 +  %end;
20814 +%end;
20816 +------------------------------------------------------------------------------*/
20818 +%if (&_crossidvar ne ) %then %do;
20820 +    *** TSID Map Summary Table;
20821 +    %if (&_tsdp_tsidmap_n > 0 ) %then %do;
20822 +        proc dmdb data=&EM_USER_TSIDMAP classout=_tmp_idmapsum;
20823 +            class &_crossidvar ;
20824 +        run;
20826 +        proc sql noprint;
20827 +            create table &EM_USER_TSIDMAPSUM as
20828 +                select a.*, b.label
20829 +                from _tmp_idmapsum as a left join &EM_DATA_VARIABLESET as b
20830 +                    on upcase(a.name) eq upcase(b.name)
20831 +                ;
20832 +        quit;
20834 +        data _tmp_a;
20835 +            NAME = "TSID";
20836 +            FREQUENCY = &_tsdp_tsidmap_n;
20837 +            FREQPERCENT = 100;
20838 +        run;
20840 +        data &EM_USER_TSIDMAPSUM;
20841 +            set &EM_USER_TSIDMAPSUM _tmp_a;
20842 +            rename NAME=VARIABLE;
20843 +            rename FREQUENCY=COUNT;
20844 +            rename FREQPERCENT=PERCENT;
20845 +            label  NAME        = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name, noquote))";
20846 +            label  FREQUENCY   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_count, noquote))";
20847 +            label  FREQPERCENT = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_percent, noquote))";
20848 +            label  LEVEL       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_level, noquote))";
20849 +            label  label       = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel, noquote))";
20851 +            keep NAME LEVEL FREQUENCY FREQPERCENT label;
20852 +        run;
20853 +        %EM_TS_DELETE_DATA(dsname=_tmp_a);
20854 +        %EM_TS_DELETE_DATA(dsname=_tmp_idmapsum);
20856 +        %EM_REPORT(key=TSIDMAPSUM, view=&viewnum, viewtype=DATA, block=Model,  Autodisplay=Y, description=sumtsidmap);
20857 +        %let viewnum=%eval(&viewnum+1);
20859 +    %end;
20861 +    *** Time Series Summary Tables for each Cross-ID;
20862 +    %let j=1;
20863 +    %do %while(%scan(&_crossidvar, &j) ne );
20864 +        %let _csvar=%scan(&_crossidvar, &j);
20865 +        %let j=&j;
20866 +        %EM_GETNAME(KEY=OUTSUM&j, TYPE=DATA);
20867 +        %let _csvarlabel=  ;
20868 +        %let dsid=%sysfunc(open(&EM_USER_OUTSUMMARY));
20869 +        %if &dsid %then %do;
20870 +            %let _csvarlabel=%sysfunc(varlabel(&dsid, %sysfunc(varnum(&dsid,&_csvar))));
20871 +            %let rc=%sysfunc(close(&dsid));
20872 +        %end;
20873 +        %if &_csvarlabel eq  %then %do;
20874 +            %let tssummaryplotname = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsdp_outsumplot, noquote, &_csvar ));
20875 +        %end;
20876 +        %else %do;
20877 +            %let tssummaryplotname = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsdp_outsumplot, noquote, &_csvarlabel ));
20878 +        %end;
20880 +        %EM_REPORT(key=OUTSUM&j, viewtype=lattice, block=PLOT, autodisplay=Y, latticetype=bar, latticex=_varname_,
20881 +                   view=&viewnum, X=&_csvar, freq=mean,  choicetext=&_str_mean, Description=&tssummaryplotname);
20882 +        /*
20883 +        %EM_REPORT(key=OUTSUM&j, viewtype=lattice, block=PLOT, autodisplay=Y, latticetype=bar, latticex=_varname_,
20884 +                   view=&viewnum, X=&_csvar, freq=mean,  choicetext=&_str_mean, Description=tssummary);
20885 +        */
20886 +        %EM_REPORT(view=&viewnum, freq=max, choicetext=&_str_max);
20887 +        %EM_REPORT(view=&viewnum, freq=min, choicetext=&_str_min);
20888 +        %EM_REPORT(view=&viewnum, freq=sum, choicetext=&_str_sum);
20890 +        %let viewnum=%eval(&viewnum+1);
20891 +        %let j=%eval(&j+1);
20892 +    %end;
20893 +%end;
20894 +%else %do;
20895 +    *** for panel data;
20896 +    data &EM_USER_OUTSUMMARY;
20897 +        set &EM_USER_OUTSUMMARY;
20898 +        rename _name_=_nameid_;
20899 +    run;
20901 +    %EM_TSDP_MergeTSID(inds=&EM_USER_OUTSUMMARY, tsidds=&EM_USER_TSIDMAP, byvar=_NAMEID_, outds=);
20902 +    %EM_REPORT(key=OUTSUMMARY,  viewtype=BAR, view=&viewnum, Autodisplay=Y, x=_TSID_,
20903 +               block=PLOT, FREQ=MEAN, description=tssummary, choicetext=&_str_mean) ;
20904 +        %EM_REPORT(view=&viewnum, freq=max, choicetext=&_str_max);
20905 +        %EM_REPORT(view=&viewnum, freq=min, choicetext=&_str_min);
20906 +        %EM_REPORT(view=&viewnum, freq=sum, choicetext=&_str_sum);
20907 +    %let viewnum=%eval(&viewnum+1);
20908 +%end;
20910 +/*----------------------------------------------------------------------------*/
20911 +/* Time Series Plots                                                          */
20912 +/*----------------------------------------------------------------------------*/
20914 +%let _timeidVar = %EM_TIMEID;
20915 +%let _targetVar = %EM_TARGET;
20916 +%let _inputVars  = %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED;
20918 +%EM_TS_GET_STAT(data=&EM_USER_TSIDMAP, var=_TSID_, stat=MAX, value=n_tsid);
20920 +%let dsid=%sysfunc(open(&_EXPORT_DATA));
20921 +%let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
20922 +%let vn_timeid =%sysfunc(varnum(&dsid, &_timeidVar));
20923 +%let dsid = %sysfunc(close(&dsid));
20925 +%if (&_crossidvar ne ) %then %do;
20927 +    %if (&vn_tsid  > 0) %then %do;
20929 +        *** identify the right data set for plot;
20930 +        *** set limit to the maximum number of TSID;
20931 +        %if (&vn_timeid  > 0) %then %do;
20932 +            %if (&n_tsid  > &n_max_tsplot)
20933 +            %then %do;
20934 +                %EM_REGISTER(KEY=PLOTSUBDS, TYPE=DATA);
20935 +                data &EM_USER_PLOTSUBDS;
20936 +                    set &_EXPORT_DATA(where=(_TSID_ <= &n_max_tsplot)) ;
20937 +                run;
20938 +                %let _PLOTDSKEY = PLOTSUBDS ;
20939 +            %end;
20940 +            %else %do;
20941 +                %let _PLOTDSKEY = &_EXPORT_DSKEY;
20942 +            %end;
20943 +        %end;
20944 +        %else %do;
20945 +            /* ----- For the case of Transposed by TimeID -------------- */
20946 +            %EM_GETNAME(KEY=TRANS_IMPORTDS, TYPE=DATA);
20947 +            %if (&n_tsid  > &n_max_tsplot)
20948 +            %then %do;
20949 +                %EM_REGISTER(KEY=PLOTSUBDS, TYPE=DATA);
20950 +                data &EM_USER_PLOTSUBDS;
20951 +                    set &EM_USER_TRANS_IMPORTDS(where=(_TSID_ <= &n_max_tsplot)) ;
20952 +                run;
20953 +                %let _PLOTDSKEY = PLOTSUBDS ;
20954 +            %end;
20955 +            %else %do;
20956 +                %let _PLOTDSKEY = TRANS_IMPORTDS;
20957 +            %end;
20958 +        %end;
20960 +        *** for target time series;
20961 +        %let j=1;
20962 +        %do %while(%scan(&_targetVar, &j) ne );
20963 +            %let _tgvar=%scan(&_targetVar, &j);
20964 +            %if &j eq 1 %then %do;
20965 +                %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, VIEW=&viewnum, X=&_timeidVar, Y=&_tgvar, block=PLOT,
20966 +                           GROUP=_TSID_, AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=targettsplot);
20967 +            %end;
20968 +            %else %do;
20969 +                %EM_REPORT(VIEW=&viewnum, Y=&_tgvar);
20970 +            %end;
20971 +            %let j=%eval(&j+1);
20972 +        %end;
20973 +        %let viewnum=%eval(&viewnum+1);
20975 +        *** for input time series;
20976 +        %let j=1;
20977 +        %do %while(%scan(&_inputVars, &j) ne );
20978 +            %let _iptvar=%scan(&_inputVars, &j);
20979 +            %if &j eq 1 %then %do;
20980 +                %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, view=&viewnum, X=&_timeidVar, Y=&_iptvar, block=PLOT,
20981 +                           GROUP=_TSID_, AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=inputtsplot);
20982 +            %end;
20983 +            %else %do;
20984 +                %EM_REPORT(VIEW=&viewnum, Y=&_iptvar);
20985 +            %end;
20986 +            %let j=%eval(&j+1);
20987 +        %end;
20988 +        %let viewnum=%eval(&viewnum+1);
20989 +    %end;
20990 +    %else %do;
20992 +        %let nvar=1;
20993 +        %let _yvars=;
20994 +        %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
20995 +        %if &dsid > 0 %then %do;
20996 +            %let vn_name =%sysfunc(varnum(&dsid, _NAMEID_));
20997 +            %do %while((^ %sysfunc(fetch(&dsid))) and (&nvar <= &n_max_tsplot));
20998 +                %let _varname  = %sysfunc(getvarc(&dsid, &vn_name));
20999 +                %let _yvars = &_yvars &_varname ;
21000 +                %let nvar=%eval(&nvar+1);
21001 +            %end;
21002 +            %let dsid = %sysfunc(close(&dsid));
21003 +        %end;
21005 +        %EM_REGISTER(KEY=PLOTSUBDS, TYPE=DATA);
21006 +        data &EM_USER_PLOTSUBDS;
21007 +            set &&&EM_USER_&_EXPORT_DSKEY;
21008 +            keep &_timeidvar &_yvars;
21009 +        run;
21011 +        %EM_REPORT(KEY=PLOTSUBDS, VIEWTYPE=LINEPLOT, view=&viewnum,  block=PLOT, X=&_timeidVar,  Y=_ANYNUMERIC_,
21012 +                   AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=timeseriesplot);
21013 +        %let viewnum=%eval(&viewnum+1);
21015 +        %EM_REPORT(Key=PLOTSUBDS, ViewType=LINEPLOT, view=&viewnum, block=PLOT, X=&_timeidvar, Y=&_yvars,
21016 +                   autodisplay=Y, description=multipletsplot);
21017 +        %let viewnum=%eval(&viewnum+1);
21018 +   %end;
21019 +%end;
21020 +%else %do;
21022 +    %if (&n_tsid  > &n_max_tsplot) %then %do;
21023 +        %EM_REGISTER(KEY=PLOTSUBDS, TYPE=DATA);
21024 +        data &EM_USER_PLOTSUBDS;
21025 +            %if &EM_PROPERTY_TRANSPOSE eq Y %then %do;
21026 +                %EM_GETNAME(KEY=TRANS_IMPORTDS, TYPE=DATA);
21027 +                set &EM_USER_TRANS_IMPORTDS;
21028 +            %end;
21029 +            %else %do;
21030 +               set &_EXPORT_DATA;
21031 +            %end;
21033 +           %let nvar=1;
21034 +           %let _yvars=;
21035 +           %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
21036 +           %if &dsid > 0 %then %do;
21037 +               %let vn_name =%sysfunc(varnum(&dsid, _NAMEID_));
21038 +               %do %while((^ %sysfunc(fetch(&dsid))) and (&nvar <= &n_max_tsplot));
21039 +                   %let _varname  = %sysfunc(getvarc(&dsid, &vn_name));
21040 +                   %let _yvars = &_yvars &_varname ;
21041 +                   %let nvar=%eval(&nvar+1);
21042 +               %end;
21043 +               %let dsid = %sysfunc(close(&dsid));
21044 +           %end;
21045 +           keep &_timeidVar &_yvars;
21046 +       run;
21047 +       %let _PLOTDSKEY = PLOTSUBDS ;
21049 +       %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, view=&viewnum, X=&_timeidVar, Y=&_yvars, block=PLOT,
21050 +                  AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=multipletsplot);
21051 +       %let viewnum=%eval(&viewnum+1);
21052 +       %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, view=&viewnum, X=&_timeidVar, Y=_ANYNUMERIC_, block=PLOT,
21053 +                  AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=timeseriesplot);
21054 +       %let viewnum=%eval(&viewnum+1);
21055 +    %end;
21056 +    %else %do;
21057 +        %if &EM_PROPERTY_TRANSPOSE ne N %then %do;
21058 +            %EM_GETNAME(KEY=TRANS_IMPORTDS, TYPE=DATA);
21059 +            %let _PLOTDSKEY = TRANS_IMPORTDS;
21060 +        %end;
21061 +        %else %do;
21062 +            %let _PLOTDSKEY = &_EXPORT_DSKEY;
21063 +        %end;
21065 +        %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, view=&viewnum, X=&_timeidVar, block=PLOT,
21066 +                   Y=%EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED,
21067 +                   AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=multipletsplot);
21068 +        %let viewnum=%eval(&viewnum+1);
21069 +        %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, view=&viewnum, X=&_timeidVar, Y=_ANYNUMERIC_, block=PLOT,
21070 +                   AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=timeseriesplot);
21071 +        %let viewnum=%eval(&viewnum+1);
21072 +    %end;
21073 +%end;
21075 +/*----------------------------------------------------------------------------*/
21076 +/* Seasonality Summary Plots                                                  */
21077 +/*----------------------------------------------------------------------------*/
21079 +data _null_;
21080 +      set &EM_USER_TSMETA;
21081 +    call symput('_seasonlength',userSeasonality);
21082 +run;
21084 +%if &_seasonlength gt 1 %then %do;
21086 +    *%EM_REPORT(key=OUTSEASON,viewtype=DATA, block=Model, Autodisplay=Y, description=outseason) ;
21088 +    %if (&n_tsid  > &n_max_tsplot) %then %do;
21089 +        %EM_REGISTER(KEY=PLOTSEASONDS, TYPE=DATA);
21090 +        data &EM_USER_PLOTSEASONDS;
21091 +            set &EM_USER_OUTSEASON(where=(_TSID_ <= &n_max_tsplot)) ;
21092 +        run;
21093 +        %let _PLOTSEASONDS = PLOTSEASONDS ;
21094 +    %end;
21095 +    %else %do;
21096 +        %let _PLOTSEASONDS = OUTSEASON ;
21097 +    %end;
21099 +    %EM_REPORT(KEY=&_PLOTSEASONDS, VIEWTYPE=LINEPLOT, View=&viewnum,  X=_SEASON_, Y=MEAN, block=PLOT,
21100 +               AUTODISPLAY=Y, group=_NAMEID_, DESCRIPTION=SeasonStatPlot, choicetext=&_str_mean);
21101 +    %EM_REPORT(VIEW=&viewnum, Y=SUM, choicetext=&_str_sum);
21102 +    %EM_REPORT(VIEW=&viewnum, Y=MIN, choicetext=&_str_min);
21103 +    %EM_REPORT(VIEW=&viewnum, Y=MAX, choicetext=&_str_max);
21104 +    %EM_REPORT(VIEW=&viewnum, Y=MEDIAN, choicetext=&_str_median);
21105 +    %let viewnum=%eval(&viewnum+1);
21106 +%end;
21108 +%Mend EM_TSDP_REPORT;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 264 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      11:146
NOTE: There were 5 observations read from the data set EMWS5.TSDP3_TSIDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 5 observations read from the data set EMWS5.TSDP3_OUTSUMMARY.
NOTE: The data set EMWS5.TSDP3_OUTSUMMARY has 5 observations and 14 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 5 observations read from the data set EMWS5.TSDP3_OUTSUMMARY.
NOTE: The data set WORK._TMP_INDS has 5 observations and 14 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 5 observations read from the data set EMWS5.TSDP3_TSIDMAP.
NOTE: The data set WORK._TMP_TSIDDS has 5 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 5 observations read from the data set WORK._TMP_TSIDDS.
NOTE: There were 5 observations read from the data set WORK._TMP_INDS.
NOTE: The data set EMWS5.TSDP3_OUTSUMMARY has 5 observations and 17 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMP_INDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK._TMP_TSIDDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 264 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 396 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 396 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 528 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 528 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 660 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 660 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 792 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 5 observations read from the data set EMWS5.TSDP3_TSIDMAP.
NOTE: The data set WORK._TMPDS has 5 observations and 4 variables.
NOTE: The PROCEDURE MEANS printed page 2.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK._TMPDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 792 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 929 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 929 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1062 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      113:137
NOTE: There were 1 observations read from the data set EMWS5.TSDP3_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1062 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1195 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1195 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1328 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1328 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1461 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1461 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1594 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1594 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1727 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
21109
21110
21111  *------------------------------------------------------------*;
21112  * End REPORT: TSDP3;
21113  *------------------------------------------------------------*;
 
21114  /* Reset EM Options */
21115  options formchar="|----|+|---+=|-/\<>*";
21116  options nocenter ls=256 ps=10000;
21117  goptions reset=all device=GIF NODISPLAY;
 
21118  proc sort data=WORK.EM_USER_REPORT;
21119  by ID VIEW;
21120  run;
 
NOTE: There were 1727 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1727 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
