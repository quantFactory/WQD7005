*------------------------------------------------------------*
User:                ali
Date:                December 19, 2019
Time:                14:31:56
Site:                12601940
Platform:            W32_8PRO
Maintenance Release: 9.04.01M3P062415
EM Version:          14.1
* 
*------------------------------------------------------------*
* Training Log
Date:                December 19, 2019
Time:                14:31:53
*------------------------------------------------------------*
14718  proc freq data=EMWS5.TSESM2_VariableSet noprint;
14719  table ROLE*LEVEL/out=WORK.TSESM2META;
14720  run;
 
NOTE: There were 6 observations read from the data set EMWS5.TSESM2_VARIABLESET.
NOTE: The data set WORK.TSESM2META has 3 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
14721  proc print data=WORK.TSESM2META label noobs;
14722  var ROLE LEVEL COUNT;
14723  label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
14724  title9 ' ';
14725  title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
14726  run;
 
NOTE: There were 3 observations read from the data set WORK.TSESM2META.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
14727  title10;
 
14728  %let EMEXCEPTIONSTRING=;
PERFORMANCE  DETAILS
15090  *------------------------------------------------------------*;
15091  * TSESM2: Generation of macros and macro variables;
15092  * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
15093  *------------------------------------------------------------*;
 
15094  %let EMEXCEPTIONSTRING=;
15095  *------------------------------------------------------------*;
15096  * TRAIN: TSESM2;
15097  *------------------------------------------------------------*;
15098  %let EM_ACTION = TRAIN;
15099  %let syscc = 0;
15100
15101  %macro EM_TSESM_MAIN;
15102
15103     filename temp catalog 'sashelp.emtsdm.tsesm_macros.source';
15104     %include temp;
15105     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
15106     %include temp;
15107     filename temp;
15108
15109     %if %upcase(&EM_ACTION) = CREATE %then %do;
15110         filename temp catalog 'sashelp.emtsdm.tsesm_create.source';
15111         %include temp;
15112         filename temp;
15113         %EM_TSESM_CREATE;
15114     %end;
15115     %else
15116     %if %upcase(&EM_ACTION) = TRAIN %then %do;
15117          filename temp catalog 'sashelp.emtsdm.tsesm_train.source';
15118             %include temp;
15119             filename temp;
15120          %EM_TSESM_TRAIN;
15121     %end;
15122     %else
15123     %if %upcase(&EM_ACTION) = SCORE %then %do;
15124             filename temp catalog 'sashelp.emtsdm.tsesm_score.source';
15125             %include temp;
15126             filename temp;
15127           %EM_TSESM_SCORE;
15128     %end;
15129     %else
15130     %if %upcase(&EM_ACTION) = REPORT %then %do;
15131             filename temp catalog 'sashelp.emtsdm.tsesm_report.source';
15132             %include temp;
15133             filename temp;
15134            %EM_TSESM_REPORT;
15135     %end;
15136  %mend EM_TSESM_MAIN;
15137  %EM_TSESM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_MACROS.SOURCE.
15138 +/*----------------------------------------------------------------------------------+
15139 + |
15140 + |   Title :  Time Series data Mining Forcating Macros
15141 + |
15142 + |   SUPPORT: Ruiwen Zhang (Ruiwen.Zhang@sas.com)
15143 + |
15144 + |
15145 + +-----------------------------------------------------------------------------------*/
15148 +%macro EM_TSESM_Forecast(indata=,
15149 +                method=,
15150 +                timeinterval=,
15151 +                timeid= ,
15152 +                target= ,
15153 +                tsidvar=,
15154 +                lead=,
15155 +                back=,
15156 +                startsum=,
15157 +                accumulate=,
15158 +                seasonality=,
15159 +                alpha=,
15160 +                extendedvalue=,
15161 +                outest = ,
15162 +                outdata = ,
15163 +                outfor = ,
15164 +                outstat = ,
15165 +                outsum=
15166 +   );
15169 +   %if &tsidvar eq _SEGMENT_ %then %do;
15170 +       proc sort data=&indata out=_tmpdata;
15171 +            by  &tsidvar %EM_CROSSID &timeid ;
15172 +       run;
15173 +       proc timeseries  data =_tmpdata out=_tmpdata;
15174 +            by  &tsidvar %EM_CROSSID;
15175 +            id &timeid interval=&timeinterval accumulate=&accumulate;
15176 +            var &target / ;
15177 +       run;
15178 +       proc esm data =_tmpdata
15179 +   %end;
15180 +   %else %do;
15181 +       proc sort data= &indata out=_tmpdata;
15182 +            by  &tsidvar %EM_CROSSID &timeid ;
15183 +       run;
15184 +       proc esm data = _tmpdata
15185 +   %end;
15186 +            lead=&lead  back=&back startsum=&startsum
15188 +   %if &seasonality ne DEFAULT %then %do;
15189 +            seasonality = &seasonality
15190 +   %end;
15193 +            out=&outdata
15194 +            outest=&outest
15195 +            outfor =&outfor
15196 +            outstat=&outstat
15197 +            outsum= &outsum
15198 +       ;
15199 +        id &timeid  interval = &timeinterval   accumulate=&accumulate ;
15201 +        %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15202 +            %if &target ne %then %do;
15203 +            forecast &target   /  model = none alpha=&alpha;
15204 +            %end;
15205 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15206 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /  model = &method alpha=&alpha use=&extendedvalue;
15207 +            %end;
15208 +        %end;
15209 +        %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
15210 +            %if &target ne %then %do;
15211 +            forecast &target /  model =&method alpha=&alpha;
15212 +            %end;
15213 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15214 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
15215 +            %end;
15216 +        %end;
15217 +        %else %do; /* for KLD, FORECAST Cluster , SIMILARITY */
15218 +            forecast &target /*%EM_INTERVAL_INPUT*/ /  model = &method alpha=&alpha use=predict;
15219 +        %end;
15221 +   %if &tsidvar ne %then %do;
15222 +        by &tsidvar %EM_CROSSID ;
15223 +   %end;
15224 +   run;
15225 +%mend EM_TSESM_Forecast;
15228 +%macro EM_TSESM_CreateOutFor(indata=,
15229 +                            target=,
15230 +                            timeid=,
15231 +                            tsidVar=,
15232 +                            percent=,
15233 +                            outdata=);
15235 +  %let lowerBound = L&percent;
15236 +  %let upperBound = U&percent;
15238 +  data ds_fore(rename=(&target=FORECAST)  drop=_TYPE_)
15239 +       ds_resid(rename=(&target=RESIDUAL) drop=_TYPE_)
15240 +       ds_act(rename=(&target=ACTUAL) drop=_TYPE_)
15241 +       ds_lower(rename=(&target=LBOUND)  drop=_TYPE_)
15242 +       ds_upper(rename=(&target=UBOUND) drop=_TYPE_)
15243 +       ds_std(rename=(&target=STD) drop=_TYPE_);
15244 +     set &indata;
15245 +       if _TYPE_="FORECAST" then output ds_fore;
15246 +       if _TYPE_="RESIDUAL" then output ds_resid;
15247 +       if _TYPE_="ACTUAL" then output ds_act;
15248 +       if _TYPE_="&lowerBound" then output ds_lower;
15249 +       if _TYPE_="&upperBound" then output ds_upper;
15250 +       if _TYPE_="STD" then output ds_std;
15251 +  run;
15253 +  data &outdata;
15254 +       merge ds_fore ds_resid ds_act ds_lower ds_upper ds_std;
15255 +       by &tsidVar &timeid;
15256 +       label  FORECAST = "Forecast";
15257 +       label  ACTUAL = "Actual";
15258 +       label  RESIDUAL = "Residual";
15259 +       label  LBOUND = "Lower Bound";
15260 +       label  UBOUND = "Upper Bound";
15261 +       label   STD = "Standard Deviation";
15262 +  run;
15263 +%mend EM_TSESM_CreateOutFor;
15266 +%macro EM_TSESM_CreateOutExpand(indata=,
15267 +                       target=,
15268 +                       timeid=,
15269 +                       tsidVar=,
15270 +                       percent=,
15271 +                       outlower=,
15272 +                       outupper=,
15273 +                       outdata=);
15275 +  %let lowerBound = L&percent;
15276 +  %let upperBound = U&percent;
15278 +  /*proc print data=&indata(obs=200);
15279 +  run;
15280 +  */
15282 +  data ds_fore(drop=&target)
15283 +       ds_lower(drop=&target)
15284 +       ds_upper(drop=&target)
15285 +       ds_act;
15286 +     set &indata;
15287 +       if _TYPE_="FORECAST" and _LEAD_  > 0 then output ds_fore;
15288 +       if _TYPE_="&lowerBound" and  _LEAD_  > 0 then output ds_lower;
15289 +       if _TYPE_="&upperBound" and  _LEAD_  > 0 then output ds_upper;
15290 +       if _TYPE_="ACTUAL" then output ds_act;
15291 +  run;
15293 +  /*
15294 +  proc print data = ds_fore;
15295 +  proc print data=ds_act;
15296 +  run;
15297 +  */
15298 +  data &outdata;
15299 +       merge ds_act ds_fore;
15300 +       by &tsidVar &timeid;
15301 +  run;
15303 +  data &outlower;
15304 +       merge ds_act ds_lower;
15305 +       by &tsidVar &timeid;
15306 +  run;
15308 +  data &outupper;
15309 +       merge ds_act ds_upper;
15310 +       by &tsidVar &timeid;
15311 +  run;
15312 +  /*
15313 +  proc print data=&outdata(obs=300);
15314 +  proc print data=&outlower(obs=300);
15315 +  proc print data=&outupper(obs=300);
15316 +  run;
15317 +  */
15318 +%mend EM_TSESM_CreateOutExpand;
15322 +%macro EM_TSESM_MakeOutClus(indata=,
15323 +                   target=,
15324 +                   timeid=,
15325 +                   tsidVar=,
15326 +                   percent=,
15327 +                   outlower=,
15328 +                   outupper=,
15329 +                   outdata=);
15332 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
15334 +  data &outdata(rename=(_NAME_ =_NAMEID_));
15335 +       set &indata;
15336 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD;
15337 +  run;
15339 +  %let dsid=%sysfunc(open(&outdata));
15340 +  %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
15341 +  %let dsid=%sysfunc(close(&dsid));
15343 +  %if &vn_name > 0 %then %do;
15344 +      data &outdata(drop=_NAMEID_);
15345 +           merge &EM_USER_TSIDMAP &outdata;
15346 +           by _TSID_;
15347 +      run;
15348 +  %end;
15349 +  %else %do;
15350 +      proc sort data= &outdata; by _NAMEID_;
15351 +      run;
15352 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
15353 +      run;
15354 +      data &outdata(drop=_NAMEID_);
15355 +           merge &EM_USER_TSIDMAP &outdata;
15356 +           by _NAMEID_;
15357 +      run;
15358 +  %end;
15360 +%mend EM_TSESM_MakeOutClus;
15363 +%macro EM_TSESM_CreateOutEst(indata=,
15364 +                    target=,
15365 +                    timeid=,
15366 +                    outdata=);
15368 +%mend EM_TSESM_CreateOutEst;
15371 +%macro EM_TSESM_Best_Forecast(indata=,
15372 +                method=,
15373 +                timeinterval=,
15374 +                timeid= ,
15375 +                target= ,
15376 +                tsidvar=,
15377 +                lead=,
15378 +                back=,
15379 +                startsum=,
15380 +                accumulate=,
15381 +                seasonality=,
15382 +                alpha=,
15383 +                criterion=,
15384 +                extendedvalue=,
15385 +                outest = ,
15386 +                outdata = ,
15387 +                outfor = ,
15388 +                outstat = ,
15389 +                outsum=
15390 +   );
15392 +   %let _indata = &indata;
15394 +   %if &tsidvar eq _SEGMENT_ %then %do;
15395 +       proc sort data=&indata out=_tmpdata;
15396 +            by  &tsidvar %EM_CROSSID &timeid ;
15397 +       run;
15398 +       proc timeseries  data =_tmpdata out=_tmpdata;
15399 +            by  &tsidvar %EM_CROSSID ;
15400 +            id &timeid interval=&timeinterval accumulate=&accumulate;
15401 +            var &target / ;
15402 +       run;
15403 +       %let _indata = _tmpdata;
15404 +   %end;
15406 +   %let n_model = 0;
15408 +   %if &EM_PROPERTY_SIMPLE eq Y %then %do;
15410 +       %let n_model = %eval(&n_model+1);
15412 +       %let _ds_out =_out&n_model;
15413 +       %let _ds_outest =_outest&n_model;
15414 +       %let _ds_outfor =_outfor&n_model;
15415 +       %let _ds_outstat =_outstat&n_model;
15416 +       %let _ds_outsum=_outsum&n_model;
15418 +       %EM_TSESM_ESM(method=SIMPLE,
15419 +        timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15420 +        lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15421 +        out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15422 +        );
15424 +   %end;
15425 +   %if &EM_PROPERTY_DOUBLE eq Y %then %do;
15427 +       %let n_model = %eval(&n_model+1);
15429 +       %let _ds_out =_out&n_model;
15430 +       %let _ds_outest =_outest&n_model;
15431 +       %let _ds_outfor =_outfor&n_model;
15432 +       %let _ds_outstat =_outstat&n_model;
15433 +       %let _ds_outsum=_outsum&n_model;
15435 +       %EM_TSESM_ESM(method=DOUBLE,
15436 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15437 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15438 +             out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15439 +       );
15440 +   %end;
15442 +   %if &EM_PROPERTY_LINEAR eq Y %then %do;
15444 +       %let n_model = %eval(&n_model+1);
15445 +       %let _ds_out =_out&n_model;
15446 +       %let _ds_outest =_outest&n_model;
15447 +       %let _ds_outfor =_outfor&n_model;
15448 +       %let _ds_outstat =_outstat&n_model;
15449 +       %let _ds_outsum=_outsum&n_model;
15451 +       %EM_TSESM_ESM(method=LINEAR,
15452 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15453 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15454 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15455 +        );
15456 +   %end;
15458 +   %if &EM_PROPERTY_DAMPTREND eq Y %then %do;
15460 +       %let n_model = %eval(&n_model+1);
15462 +       %let _ds_out =_out&n_model;
15463 +       %let _ds_outest =_outest&n_model;
15464 +       %let _ds_outfor =_outfor&n_model;
15465 +       %let _ds_outstat =_outstat&n_model;
15466 +       %let _ds_outsum=_outsum&n_model;
15468 +       %EM_TSESM_ESM(method=DAMPTREND,
15469 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15470 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15471 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15472 +            );
15473 +   %end;
15474 +   /*------- Seasonal model ------*/
15476 +   %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do;
15478 +   %if (&EM_PROPERTY_WINTERS eq Y) %then %do;
15480 +       %let n_model = %eval(&n_model+1);
15482 +       %let _ds_out =_out&n_model;
15483 +       %let _ds_outest =_outest&n_model;
15484 +       %let _ds_outfor =_outfor&n_model;
15485 +       %let _ds_outstat =_outstat&n_model;
15486 +       %let _ds_outsum=_outsum&n_model;
15488 +       %EM_TSESM_ESM(method=WINTERS,
15489 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15490 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15491 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15492 +        );
15493 +   %end;
15495 +   %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then %do;
15497 +       %let n_model = %eval(&n_model+1);
15499 +       %let _ds_out =_out&n_model;
15500 +       %let _ds_outest =_outest&n_model;
15501 +       %let _ds_outfor =_outfor&n_model;
15502 +       %let _ds_outstat =_outstat&n_model;
15503 +       %let _ds_outsum=_outsum&n_model;
15505 +       %EM_TSESM_ESM(method=ADDSEASONAL,
15506 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15507 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15508 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15509 +       );
15510 +   %end;
15512 +   %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %do;
15514 +       %let n_model = %eval(&n_model+1);
15516 +       %let _ds_out =_out&n_model;
15517 +       %let _ds_outest =_outest&n_model;
15518 +       %let _ds_outfor =_outfor&n_model;
15519 +       %let _ds_outstat =_outstat&n_model;
15520 +       %let _ds_outsum=_outsum&n_model;
15522 +       %EM_TSESM_ESM(method=MULTSEASONAL,
15523 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15524 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15525 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15526 +       );
15527 +   %end;
15529 +   %if (&EM_PROPERTY_ADDWINTERS eq Y) %then %do;
15531 +       %let n_model = %eval(&n_model+1);
15533 +       %let _ds_out =_out&n_model;
15534 +       %let _ds_outest =_outest&n_model;
15535 +       %let _ds_outfor =_outfor&n_model;
15536 +       %let _ds_outstat =_outstat&n_model;
15537 +       %let _ds_outsum=_outsum&n_model;
15539 +       %EM_TSESM_ESM(method=ADDWINTERS,
15540 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15541 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15542 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15543 +            );
15544 +   %end;
15547 +   %end; /* end of %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do; */
15548 +   /*-------- end of seasonal model  ------------------------------------------------------*/
15550 +   %if &n_model eq 0 %then %do;
15552 +       /*---- %PUT  ERROR:THE NUMBER OF CANDIDATE MODELS IS ZERO;  */
15553 +       %let  EMEXCEPTIONSTRING = exception.server.tsdm.zerocandidatemodel;
15554 +   %end;
15555 +   %else %do;
15556 +         %EM_TSESM_BestModelSel(crit=&criterion,
15557 +                               n_mdl=&n_model,
15558 +                               tsidvar=&tsidvar,
15559 +                               timeid=&timeid,
15560 +                               out=&outdata,
15561 +                               outest=&outest,
15562 +                               outfor =&outfor,
15563 +                               outstat=&outstat,
15564 +                               outsum=&outsum
15565 +                  );
15566 +   %end;
15568 +%mend EM_TSESM_Best_Forecast;
15571 +%macro EM_TSESM_ESM(method= ,
15572 +           timeinterval=,
15573 +           timeid= ,
15574 +           target= ,
15575 +           tsidvar=,
15576 +           lead=,
15577 +           back=,
15578 +           startsum=,
15579 +           accumulate=,
15580 +           seasonality=,
15581 +           alpha=,
15582 +           out= ,
15583 +           outest= ,
15584 +           outfor= ,
15585 +           outstat= ,
15586 +           outsum=
15587 +           );
15589 +       proc sort data= &_indata out=_tmpdata;
15590 +            by  &tsidvar %EM_CROSSID &timeid ;
15591 +       run;
15592 +       proc esm data = _tmpdata  lead=&lead    back=&back  startsum=&startsum
15594 +       %if &seasonality ne DEFAULT %then %do;
15595 +                     seasonality = &seasonality
15596 +       %end;
15597 +            out=&out
15598 +            outest=&outest
15599 +            outfor =&outfor
15600 +            outstat=&outstat
15601 +            outsum= &outsum
15602 +            ;
15603 +       id &timeid  interval = &timeinterval  accumulate=&accumulate  ;
15605 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15606 +            %if &target ne %then %do;
15607 +            forecast &target   /  model = none alpha=&alpha;
15608 +            %end;
15609 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15610 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha use=&extendedvalue;
15611 +            %end;
15612 +       %end;
15613 +       %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
15614 +            %if &target ne %then %do;
15615 +            forecast &target /  model =&method alpha=&alpha;
15616 +            %end;
15617 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15618 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
15619 +            %end;
15620 +       %end;
15621 +       %else %do;   /*----- CLUSTER INPUT , KLD, SIMILARITY INPUT ------*/
15622 +            %if &target ne %then %do;
15623 +            forecast &target   /  model = &method alpha=&alpha;
15624 +            %end;
15625 +            /*
15626 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15627 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha;
15628 +            %end;
15629 +            */
15630 +       %end;
15632 +       %if &tsidvar ne %then %do;
15633 +        by &tsidvar %EM_CROSSID;
15634 +       %end;
15635 +       run;
15637 +%mend EM_TSESM_ESM;
15641 +%macro EM_TSESM_BestModelSel(crit=,
15642 +                    n_mdl=,
15643 +                    tsidvar=_TSID_,
15644 +                    timeid=MNTH_YR,
15645 +                    out=&_outdata,
15646 +                    outest=&_outest,
15647 +                    outfor =&_outfor,
15648 +                    outstat=&_outstat,
15649 +                    outsum=&_outsum
15650 +    );
15652 +   %let statbls=select *, 1 as mdlID from _outstat1;
15653 +   %let estbls=select *,  1 as mdlID from _outest1;
15654 +   %let fortbls=select *, 1 as mdlID from _outfor1;
15655 +   %let outbls=select *,  1 as mdlID from _out1;
15656 +   %let sumtbls=select *, 1 as mdlID from _outsum1;
15657 +   %do i=2 %to &n_mdl;
15658 +      %let statbls=&statbls union all select *, &i as mdlID from _outstat&i;
15659 +        %let estbls=&estbls union all select *, &i as mdlID from _outest&i;
15660 +        %let fortbls=&fortbls union all select *, &i as mdlID from _outfor&i;
15661 +        %let outbls=&outbls union all select *, &i as mdlID from _out&i;
15662 +        %let sumtbls=&sumtbls union all select *, &i as mdlID from _outsum&i;
15663 +   %end;
15665 +   %let dsid=%sysfunc(open(_out1));
15666 +   %let vn_tsid = 0;
15668 +   %if &dsid > 0 %then %do;
15669 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
15670 +         %let dsid = %sysfunc(close(&dsid));
15671 +   %end;
15673 +   %if &vn_tsid <= 0  %then %do;
15674 +       %let tsidvar=_NAME_;
15675 +   %end;
15677 +  /*
15678 +  %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15679 +     %let tsidvar=_NAME_;
15680 +   %end;
15681 +  */
15683 +   proc sql;
15684 +     create table tsstat as &statbls;
15685 +     create table tsest  as &estbls;
15686 +     create table tsfor  as &fortbls;
15687 +     create table tsout  as &outbls;
15688 +     create table tssum  as &sumtbls;
15689 +   quit;
15691 +    proc sort data=tsstat out=bestmdl;
15692 +        by &tsidvar &crit mdlID;
15693 +    run;
15695 +    * when multiple BEST model found;
15696 +    * use the one with smallest model ID;
15697 +    data bestmdl;
15698 +        set bestmdl;
15699 +        by &tsIDvar;
15700 +        if first.&tsIDVar;
15701 +    run;
15703 +   proc sql;
15704 +      create table bestID as
15705 +        select distinct(tsest.&tsidvar), _model_, &crit, bestmdl.mdlID
15706 +        from bestmdl,tsest
15707 +        where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar;
15709 +      create table &outfor
15710 +        as select tsfor.*, _model_, &crit from tsfor, bestID
15711 +        where tsfor.&tsidvar=bestID.&tsidvar and tsfor.mdlID=bestID.mdlID order by &tsidvar, &timeid;
15713 +        create table &outstat
15714 +        as select tsstat.*, _model_ from tsstat, bestID
15715 +      where tsstat.&tsidvar=bestID.&tsidvar and tsstat.mdlID=bestID.mdlID order by &tsidvar;
15717 +        create table &outest
15718 +        as select tsest.*, &crit from bestmdl, tsest
15719 +      where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar order by &tsidvar;
15721 +      create table &outsum
15722 +        as select tssum.*, _model_, &crit from tssum, bestID
15723 +      where tssum.&tsidvar=bestID.&tsidvar and tssum.mdlID=bestID.mdlID order by &tsidvar;
15725 +      /*
15726 +      %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15727 +        create table &out
15728 +          as select tsout.*, _model_, &crit from tsout, bestID
15729 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
15730 +      %end;
15731 +      */
15733 +      %if &tsidvar eq _TSID_ %then %do;
15735 +         create table &out
15736 +          as select tsout.*, _model_, &crit from tsout, bestID
15737 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
15739 +      %end;
15740 + run;
15741 +quit;
15743 + /*%if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
15745 + %if &tsidvar = _NAME_ %then %do;
15746 +      data
15747 +            %let i=1;
15748 +            %do i=1 %to &n_mdl;
15749 +               %let _tmpdsname = _tmpds&i;
15750 +                    &_tmpdsname
15751 +            %end;
15752 +        ;
15753 +         set work.Bestmdl;
15754 +            %let i=1;
15755 +            %do i=1 %to &n_mdl;
15756 +               %let _tmpdsname = _tmpds&i;
15757 +                  if mdlID = &i then output &_tmpdsname;
15758 +            %end;
15759 +      run;
15761 +      data &out;
15762 +           set _out1;
15763 +           keep &timeid %EM_TARGET;
15764 +      run;
15765 +      %let i=1;
15766 +      %do i=1 %to &n_mdl;
15767 +          %let _tmpdsname = _tmpds&i;
15768 +          %let _outdsname = _out&i;
15770 +          data &out;
15771 +               set &out;
15772 +               set &_outdsname(keep=
15773 +               %let dsid=%sysfunc(open(&_tmpdsname));
15774 +               %if &dsid > 0 %then %do;
15775 +                  %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
15776 +                  %do %while(^%sysfunc(fetch(&dsid)));
15777 +                     %let _name  = %sysfunc(getvarc(&dsid, &vn_name));
15778 +                          &_name
15779 +                  %end;
15780 +                  %let dsid = %sysfunc(close(&dsid));
15781 +               %end;
15782 +               );
15783 +           run;
15784 +       %end;
15786 +%end;
15788 +data &out;
15789 +     set  &out;
15790 +      drop mdlID _MODEL_ &crit;
15791 +data &outest;
15792 +      set  &outest;
15793 +      drop mdlID &crit;
15794 +data &outfor;
15795 +     set &outfor;
15796 +     drop mdlID &crit;
15797 +data &outstat;
15798 +     set &outstat;
15799 +     drop mdlID;
15800 +data &outsum;
15801 +     set &outsum;
15802 +     drop mdlID &crit;
15803 +run;
15805 +%mend EM_TSESM_BestModelSel;
15809 +%macro EM_TSESM_MakeOutlierIndex(indata=,
15810 +                        target=,
15811 +                        timeid=,
15812 +                        outoutlier=,
15813 +                        outlierds=,
15814 +                        outdata=);
15815 +%let label_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlier, noquote));
15816 +%let str_Actual_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actualoutlier, noquote));
15817 +%let str_Actual = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actual, noquote));
15818 +data &outdata;
15819 +     set &indata;
15820 +     length OutlierIndex 8.;
15821 +     length Outlier  $40;
15822 +     label  OutlierIndex = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlierindex, noquote))";
15823 +     label  Outlier = "&label_Outlier";
15824 +   /*  if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&label_Outlier";end;
15825 +       else  do; OutlierIndex=0; outlier =" "; end; */
15826 +     if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&str_Actual_Outlier";end;
15827 +       else  do; OutlierIndex=0; outlier ="&str_Actual"; end;
15828 +run;
15830 +data  &outoutlier;
15831 +      set  &outdata;
15832 +      keep &timeid _TSID_ _SEGMENT_ _NAME_ _NAMEID_ OUTLIERINDEX OUTLIER PREDICT;
15833 +      if ACTUAL = . then delete;
15834 +run;
15836 +data &outlierds;
15837 +     set &outoutlier;
15838 +     if OUTLIERINDEX = 0 then delete;
15839 +     Drop OUTLIERINDEX;
15840 +run;
15842 +%mend  EM_TSESM_MakeOutlierIndex;
15845 +%macro EM_TSESM_MakeSmoothedOutds(indata=,
15846 +                         inoutlierds=,
15847 +                         target=,
15848 +                         timeid=,
15849 +                         tsidvar=_TSID_,
15850 +                         replace=,
15851 +                         outdata=);
15854 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
15857 +%let dsid=%sysfunc(open(&indata));
15858 +%let vn_tsid = 0;
15859 +%if &dsid > 0 %then %do;
15860 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
15861 +         %let dsid = %sysfunc(close(&dsid));
15862 +%end;
15864 +%if &vn_tsid <= 0  %then %do;
15865 +    %let tsidvar=_NAME_;
15866 +%end;
15868 +%if &tsidvar = _TSID_ %then %do;
15869 +/* %if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
15870 + /*    data &outdata;
15871 +          merge &indata &inoutlierds;
15872 +          by _TSID_ &timeid;
15873 +          if OutlierIndex > 0 then
15874 +          %if &replace eq PREDICT %then %do;
15875 +             &target = PREDICT;
15876 +          %end;
15877 +          %else %do;
15878 +             &target = .;
15879 +          %end;
15880 +           Drop Predict _NAME_ OutlierIndex;
15881 +     run;     */
15882 +  %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
15883 +     %if &dsid > 0 %then %do;
15884 +         %let vn_nameid =%sysfunc(varnum(&dsid, _VARNAME_));
15885 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
15886 +         %let i = 1;
15887 +              %do %while(^%sysfunc(fetch(&dsid)));
15888 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
15889 +                  %let _vartsid= %sysfunc(getvarn(&dsid, &vn_tsid));
15890 +                  %if &i eq 1 %then %do;
15891 +                      data _tmpoutlier;
15892 +                           set &inoutlierds;
15893 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid then output;
15894 +                      run;
15895 +                      data &outdata;
15896 +                           merge &indata _tmpoutlier;
15897 +                           by _TSID_ &timeid ;
15898 +                           if OutlierIndex  > 0 then
15899 +                              %if &replace eq PREDICT %then %do;
15900 +                                &_varname = PREDICT;
15901 +                              %end;
15902 +                              %else %do;
15903 +                                &_varname = .;
15904 +                              %end;
15905 +                            Drop Predict _NAME_  OutlierIndex Outlier;
15906 +                      run;
15907 +                   %end;
15908 +                   %else %do;
15909 +                      data _tmpoutlier;
15910 +                           set &inoutlierds;
15911 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid  then output;
15912 +                      run;
15913 +                      data &outdata;
15914 +                           merge &outdata _tmpoutlier;
15915 +                           by _TSID_ &timeid ;
15916 +                           if OutlierIndex  > 0 then
15917 +                              %if &replace eq PREDICT %then %do;
15918 +                                &_varname = PREDICT;
15919 +                              %end;
15920 +                              %else %do;
15921 +                                &_varname = .;
15922 +                              %end;
15923 +                           Drop Predict _NAME_  OutlierIndex Outlier;
15924 +                      run;
15925 +                   %end;
15926 +                   %let i = %eval(&i+1);
15928 +              %end;
15929 +           %let dsid = %sysfunc(close(&dsid));
15930 +      %end;
15931 +%end;
15932 +%else %do;  /*  %if &tsidvar = _NAME_ %then %do; */
15934 +     %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
15935 +     %if &dsid > 0 %then %do;
15936 +         %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
15937 +         %let i = 1;
15938 +              %do %while(^%sysfunc(fetch(&dsid)));
15939 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
15940 +                  %if &i eq 1 %then %do;
15941 +                      data _tmpoutlier;
15942 +                           set &inoutlierds;
15943 +                           if _NAME_ ="&_varname"  then output;
15944 +                      run;
15945 +                      data &outdata;
15946 +                           merge &indata _tmpoutlier;
15947 +                           by &timeid;
15948 +                           if OutlierIndex  > 0 then
15949 +                              %if &replace eq PREDICT %then %do;
15950 +                                &_varname = PREDICT;
15951 +                              %end;
15952 +                              %else %do;
15953 +                                &_varname = .;
15954 +                              %end;
15955 +                            Drop Predict _NAME_ OutlierIndex Outlier;
15956 +                      run;
15957 +                   %end;
15958 +                   %else %do;
15959 +                      data _tmpoutlier;
15960 +                           set &inoutlierds;
15961 +                           if _NAME_ ="&_varname"  then output;
15962 +                      run;
15963 +                      data &outdata;
15964 +                           merge &outdata _tmpoutlier;
15965 +                           by &timeid;
15966 +                           if OutlierIndex  > 0 then
15967 +                              %if &replace eq PREDICT %then %do;
15968 +                                &_varname = PREDICT;
15969 +                              %end;
15970 +                              %else %do;
15971 +                                &_varname = .;
15972 +                              %end;
15973 +                           Drop Predict _NAME_ OutlierIndex Outlier;
15974 +                      run;
15975 +                   %end;
15976 +                   %let i = %eval(&i+1);
15978 +              %end;
15979 +           %let dsid = %sysfunc(close(&dsid));
15980 +      %end;
15981 +      %else %do;
15982 +            /* this block is added 09022011*/
15983 +            /* works for wide table in which each time series has a column */
15985 +            proc transpose data=&indata out=_tmpdata1;
15986 +                by &timeID;
15987 +            run;
15989 +            proc sql;
15990 +                create table _tmpdata2 as
15991 +                    select a.*, b.outlierindex, b.outlier, b.predict
15992 +                        from _tmpdata1 as a left join &inoutlierds as b
15993 +                            on a.&timeID eq b.&timeID and a._name_ eq b._name_
15994 +                        order by a.&timeID, a._name_
15995 +                    ;
15996 +            quit;
15998 +            data _tmpdata2;
15999 +                set _tmpdata2;
16000 +                if outlierindex eq 1 then
16001 +                    if &replace eq PREDICT then col1=predict; else col1=.;
16002 +            run;
16004 +            proc transpose data=_tmpdata2 out=_tmpdata3(drop=_name_ _label_);
16005 +                by &timeID;
16006 +                ID _name_;
16007 +                var col1;
16008 +            proc sort data=&inoutlierds out=_tmpoutlier;
16009 +                by &timeID _name_;
16010 +            proc transpose data=_tmpoutlier out=_tmpdata4(drop=_name_ _label_) prefix=Outlier_;
16011 +                by &timeID;
16012 +                ID _name_;
16013 +                var outlier;
16014 +            run;
16016 +            data &outdata;
16017 +                merge _tmpdata3 _tmpdata4;
16018 +                by &timeID;
16019 +            run;
16020 +      %end;
16021 +%end;
16022 +%mend EM_TSESM_MakeSmoothedOutds;
16024 +%Macro EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
16025 +                  insumdata=&EM_USER_OUTSUM,
16026 +                target=&_targetVar,
16027 +                timeid=&_timeidVar,
16028 +                futurepoint=1,
16029 +                outKLD=&EM_USER_OUTKLD
16030 +                );
16032 +%if &futurepoint > 0 %then %do;
16034 +proc sort data=&indata out=_tmptimeid;
16035 +     by &timeid;
16036 +run;
16038 +data _tmptimeid(keep=&timeid);
16039 +      set _tmptimeid; by &timeid;
16040 +      if first.&timeid then output;
16041 +run;
16043 +%let _targetTime =;
16044 +%let dsid=%sysfunc(open(work._tmptimeid));
16045 +%if &dsid > 0 %then %do;
16046 +    %let vn_timeid =%sysfunc(varnum(&dsid, &timeid));
16047 +    %let i = 1;
16048 +    %do %while(^%sysfunc(fetch(&dsid)));
16049 +       %if &i eq &futurepoint %then %do;
16050 +       %let _targetTime  = %sysfunc(getvarn(&dsid, &vn_timeid));
16051 +       %end;
16052 +       %let i = %eval(&i+1);
16053 +    %end;
16054 +    %let dsid = %sysfunc(close(&dsid));
16055 +%end;
16057 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
16058 +   set &indata;
16059 +   if &timeid eq &_targetTime then output;
16060 +run;
16062 +%end;  /* end of %if &futurepoint > 0 %then %do; */
16063 +%else %do;
16066 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
16067 +   set &insumdata;
16068 +run;
16071 +%end;
16073 +%EM_TSESM_KLD(indata=work._tmpKLD, outdata=&outKLD);
16075 +/* Merge TSIDMAP  */
16077 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16078 +data &outKLD(rename=(_NAME_ =_NAMEID_));
16079 +       set &outKLD;
16080 +run;
16082 +%let dsid=%sysfunc(open(&outKLD));
16083 +%let vn_name =%sysfunc(varnum(&dsid, _TSID_));
16084 +%let dsid=%sysfunc(close(&dsid));
16086 +%if &vn_name > 0 %then %do;
16087 +      data &outKLD(drop=_NAMEID_);
16088 +           merge &EM_USER_TSIDMAP &outKLD;
16089 +           by _TSID_;
16090 +      run;
16091 +%end;
16092 +%else %do;
16093 +      proc sort data= &outKLD; by _NAMEID_;
16094 +      run;
16095 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
16096 +      run;
16097 +      data &outKLD(drop=_NAMEID_);
16098 +           merge &EM_USER_TSIDMAP &outKLD;
16099 +           by _NAMEID_;
16100 +      run;
16101 +%end;
16103 +/* delete _tmptimeid  _tmpKLD */
16104 +%Mend  EM_TSESM_MakeOutKLD;
16107 +%Macro EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
16108 +                 target=&_targetVar,
16109 +                 timeid=&_timeidVar,
16110 +                 outdata=&EM_USER_OUTPRED
16111 +                 );
16113 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
16114 +%let _EndTime = ;
16115 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
16116 +%if &dsid > 0 %then %do;
16117 +    %let vn_end =%sysfunc(varnum(&dsid, END));
16118 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
16119 +    %do %while(^%sysfunc(fetch(&dsid)));
16120 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
16121 +       /*--------------------------------------------------------
16122 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
16123 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
16124 +        ---------------------------------------------------------*/
16125 +    %end;
16126 +    %let dsid = %sysfunc(close(&dsid));
16127 +%end;
16129 +data &outdata(keep= _TSID_ _NAME_  &timeid PREDICT LOWER UPPER STD);
16130 +     set &indata;
16131 +     if &timeid > &_EndTime then output;
16132 +run;
16133 +%Mend  EM_TSESM_MakeOutPred;
16136 +%macro EM_TSESM_KLD(indata=work._tmp, outdata=_out);
16138 +%let std_x = ;
16139 +%let mu_y = ;
16141 +%let dsid=%sysfunc(open(&indata));
16142 +%if &dsid > 0 %then %do;
16143 +    %let vn_pred =%sysfunc(varnum(&dsid, PREDICT));
16144 +    %let vn_std  = %sysfunc(varnum(&dsid, STD));
16145 +    %let i=1;
16146 +    %do %while(^%sysfunc(fetch(&dsid)));
16147 +        %let _pred  = %sysfunc(getvarn(&dsid, &vn_pred));
16148 +        %let _std  = %sysfunc(getvarn(&dsid, &vn_std));
16149 +        %let _tsid = _TSID&i.;
16150 +        /* create new data set */
16151 +            %if &i = 1 %then %do;
16152 +            data _tmpindata;
16153 +                set &indata;
16154 +                  mu_x = &_pred;
16155 +                  std_x = &_std;
16156 +                  rename predict = mu_y;
16157 +                  rename std = std_y;
16158 +            run;
16159 +        data _tmpout;
16160 +                 set _tmpindata;
16161 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
16162 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
16163 +             &_tsid= (KLD1+KLD2)/2;
16164 +             if &_tsid < 0 then &_tsid = 0;
16165 +                   drop KLD1 KLD2;
16166 +         run;
16167 +             %end;
16168 +         %else %do;
16169 +         data _tmpindata;
16170 +                  set _tmpout;
16171 +                  mu_x = &_pred;
16172 +                  std_x = &_std;
16174 +             run;
16175 +         data _tmpout;
16176 +                 set _tmpindata;
16177 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
16178 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
16179 +             &_tsid= (KLD1+KLD2)/2;
16180 +             if &_tsid < 0 then &_tsid = 0;
16181 +                   drop KLD1 KLD2;
16182 +         run;
16184 +         %end;
16185 +             %let i = %eval(&i+1);
16187 +    %end;
16188 +    %let dsid = %sysfunc(close(&dsid));
16189 +    data &outdata;
16190 +         set _tmpout;
16191 +         drop mu_x mu_y std_x std_y;
16192 +    run;
16193 +%end;
16194 +%mend EM_TSESM_KLD;
16197 +%macro EM_TSESM_MakeOutClusInput(indata=,
16198 +                   target=,
16199 +                   timeid=,
16200 +                   tsidVar=,
16201 +                   percent=,
16202 +                   outlower=,
16203 +                   outupper=,
16204 +                   esmmethod=,
16205 +                   criterion=,
16206 +                   outdata=);
16208 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16210 +  data &outdata(rename=(_NAME_ =_NAMEID_));
16211 +       set &indata;
16212 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
16213 +  %if &esmmethod eq BEST %then %do;
16214 +      mdlID _MODEL_ &criterion
16216 +  %end;
16217 +  ;
16218 +  run;
16220 +  %let dsid=%sysfunc(open(&outdata));
16221 +       %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
16222 +  %let dsid=%sysfunc(close(&dsid));
16224 +  %if &vn_name > 0 %then %do;
16225 +      proc sort data= &outdata; by _TSID_;
16226 +      run;
16227 +      proc sort data = &EM_USER_TSIDMAP ;by _TSID_;
16228 +      run;
16230 +      data &outdata(drop=_NAMEID_);
16231 +           merge &EM_USER_TSIDMAP &outdata;
16232 +           by _TSID_;
16233 +      run;
16234 +  %end;
16235 +  %else %do;
16236 +      proc sort data= &outdata; by _NAMEID_;
16237 +      run;
16238 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
16239 +      run;
16240 +      data &outdata(drop=_NAMEID_);
16241 +           merge &EM_USER_TSIDMAP &outdata;
16242 +           by _NAMEID_;
16243 +      run;
16244 +  %end;
16246 +%mend EM_TSESM_MakeOutClusInput;
16248 +%macro EM_TSESM_MakeOutSimInput(indata=,
16249 +                   inoutfor=,
16250 +                   target=,
16251 +                   timeid=,
16252 +                   tsidVar=,
16253 +                   esmmethod=,
16254 +                   criterion=,
16255 +                   outdata=);
16258 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16259 +  %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
16261 +   %let _EndTime = ;
16262 +   %let dsid=%sysfunc(open(&EM_USER_TSMETA));
16263 +   %if &dsid > 0 %then %do;
16264 +   %let vn_end =%sysfunc(varnum(&dsid, END));
16265 +   %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
16266 +   %do %while(^%sysfunc(fetch(&dsid)));
16267 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
16268 +   %end;
16269 +   %let dsid = %sysfunc(close(&dsid));
16270 +   %end;
16272 +   %em_varMacro(name=tsesm_crossid, metadata= &EM_DATA_VARIABLESET, key=NAME,
16273 +       where=%nrbquote(ROLE='CROSSID' and USE ne 'N') , nummacro=tsesm_crossidNum);
16275 +   data _out1;
16276 +       set &indata;
16277 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
16278 +           %tsesm_crossid
16279 +   %if &esmmethod eq BEST %then %do;
16280 +      mdlID _MODEL_ &criterion
16281 +   %end;
16282 +   ;
16283 +   run;
16285 +    %let dsid=%sysfunc(open(work._out1));
16286 +    %if &dsid > 0 %then %do;
16287 +      %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
16288 +      %let dsid = %sysfunc(close(&dsid));
16289 +    %end;
16291 +    /*
16292 +    proc print data=_out1(obs=10);
16293 +    run;
16294 +    */
16295 +    %let _existtsid = Y;
16296 +    %if (&vn_tsid = 0)  %then %do;
16297 +    %let _existtsid = N;
16298 +    %goto NO_TSID_SIMINPUT;
16299 +    %end;
16301 +    data _out1;
16302 +        set _out1;
16303 +        where _name_ = "&target";
16304 +    run;
16305 +    %let target2 = &target._;
16306 +    proc transpose data=_out1 out=_out2 prefix=&target2;
16307 +            id _TSID_  ;
16308 +    run;
16309 +    /*
16310 +    proc print data=_out2(obs=11);
16311 +    run;
16312 +    */
16313 +    data _out2;
16314 +       length _index 8.;
16315 +       set _out2;
16316 +       _index=_N_;
16317 +       drop _NAME_ _LABEL_;
16318 +    run;
16321 +   data _out3;
16322 +       length _index 8.;
16323 +        set &inoutfor(where=(_TSID_=1 and &timeid > &_EndTime));
16324 +         _index =_N_;
16325 +        keep &timeid _index;
16327 +   run;
16328 +   /*
16329 +   proc print data=_out2(obs=12);
16330 +   proc print data =_out3(obs=13);
16331 +   run;
16332 +   */
16333 +   data &outdata(drop=_index);
16334 +        merge _out3 _out2;by _index;
16335 +        run;
16338 +  proc transpose data=&outdata out=_tout;
16339 +     id &timeid;
16340 +   run;
16341 +   data _tout;
16342 +        length _TSID_ 8.;
16343 +        set _tout;
16344 +        rename _NAME_= _NAMEID_;
16345 +        _TSID_ = _N_;
16346 +        label _NAME_ = "NAMEID";
16347 +        keep _NAME_ _TSID_;
16349 +   run;
16351 +   data &EM_USER_TSIDMAP;
16352 +        merge  _tout  &EM_USER_TSIDMAP; by _TSID_;
16353 +   run;
16354 +   /*
16355 +   proc print data=_tout(obs=14);
16356 +   run;
16357 +   */
16358 +   proc datasets lib=work nolist;
16359 +      delete  _out1 _tmpout1 _out2 _out3 _tout;
16360 +   run;
16363 +   %NO_TSID_SIMINPUT:
16364 +   %if  &_existtsid eq N %then %do;
16365 +   data &outdata;
16366 +        set &inoutfor(where=(&timeid > &_EndTime));
16367 +   run;
16368 +   %end;
16371 +%mend EM_TSESM_MakeOutSimInput;
16374 +%macro EM_TS_CONVERT_LONG_TO_WIDE(indata=, outdata=, wherevar=, nwherevalue=, targetvar=, timeid=);
16375 +%do i=1 %to &nwherevalue;
16376 +     %if &i = 1 %then %do;
16377 +        data &outdata(drop = &wherevar);
16378 +             set &indata;
16379 +               if &wherevar= &i;
16380 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
16381 +               %else %let newname = &wherevar_&i;
16382 +                rename  &targetvar= &newname;
16383 +                   label &targetvar ="&targetvar._&i";
16384 +           run;
16385 +       %end;
16386 +       %else %do;
16387 +        data _tmp_out(drop = &wherevar);
16388 +             set &indata;
16389 +               if &wherevar= &i;
16390 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
16391 +               %else %let newname = &wherevar_&i;
16392 +                rename  &targetvar= &newname;
16393 +                   label &targetvar ="&targetvar._&i";
16394 +           run;
16395 +             data &outdata;
16396 +                  merge &outdata  _tmp_out; by &timeid;
16397 +         run;
16398 +       %end;
16399 +%end;
16401 +%EM_TS_DELETE_DATA(lib=work, data=_tmp_out);
16403 +%mend EM_TS_CONVERT_LONG_TO_WIDE;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
16405 +/*
16406 +       MACRO: TS Utility macros
16408 +       PURPOSE: TS Utility macros
16409 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
16411 +       HISTORY:
16412 +       NOTE:
16414 +*/
16416 +/*
16417 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
16418 +                          timeid=, timeformat=, timeinformat=);
16419 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
16421 +    %do;
16422 +    %let m_data      = &data;
16423 +    %let m_decdata   = &decdata;
16424 +    %let m_decmeta   = &decmeta;
16425 +    %let m_cmeta     = &cmeta;
16426 +    %let m_outfile   = &outfile;
16427 +    %let m_crossid   = &crossid;
16428 +    %let m_timeid    = &timeid;
16429 +    %let m_timeformat    = &timeformat;
16430 +    %let m_timeinformat    = &timeinformat;
16431 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
16432 +  %end;
16433 +%mend EM_TS_CreateTsMetaDs;
16434 +*/
16435 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
16436 +proc sql;
16437 +      create table _tmp_inds
16438 +      as select distinct &timeid from  &indata;
16439 +quit;
16440 +run;
16441 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
16442 +  id &timeid
16443 +%if &timeinterval ne %then %do;
16444 +    %if &timeformattype eq DATE %then %do;
16445 +        interval=&timeinterval
16446 +    %end;
16447 +    %else %if &timeformattype eq DATETIME  %then %do;
16448 +        %let dttimeinterval= DT&timeinterval;
16449 +         interval=&dttimeinterval
16450 +    %end;
16451 +%end;
16452 +;
16453 +run;
16455 +data &outds;
16456 +     set _tmp_tsmeta;
16457 +     format START &timeformat;
16458 +     format END &timeformat;
16459 +     length APPLY_START_END $8;
16460 +     APPLY_START_END ="No";
16461 +     FORMAT = "&timeformat";
16462 +     ROLE ="TIMEID";
16463 +     rename TIMEID = NAME;
16464 +     rename SEASONALITY= LengthOfCycle;
16465 +     rename INTERVAL = TIMEINTERVAL ;
16466 +     rename FORMAT = TIMEFORMAT;
16467 +     output;
16468 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
16469 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
16470 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
16471 +run;
16473 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
16474 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
16476 +%mend EM_TS_CreateTSMetaData;
16480 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
16482 +/* if updated = Y it will pass the TSMETA created by just the previous node */
16484 +%let _tsmetads = ;
16486 +%if &updated = Y %then %do;
16487 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
16488 +%if %sysfunc(exist(&_tsmetads)) %then %do;
16489 +%goto endline;
16490 +%end;
16491 +%end;
16493 +%if &eminfodata eq %then %do;
16494 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
16495 +    data &EM_DATA_EMINFO;
16496 +         set &EM_IMPORT_DATA_EMINFO;
16497 +    run;
16498 +%end;
16499 +%else %do;
16500 +    %let dsid=%sysfunc(open(&eminfodata));
16501 +    data &EM_DATA_EMINFO;
16502 +         set &eminfodata;
16503 +    run;
16504 +%end;
16505 +%if &dsid > 0 %then %do;
16506 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
16507 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
16508 +    %do %while(^ %sysfunc(fetch(&dsid)));
16509 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
16510 +         %if &_key eq TSMETA %then %do;
16511 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
16512 +         %end;
16513 +    %end;
16514 +    %let dsid = %sysfunc(close(&dsid));
16515 +%end; /* the end of %if &dsid > 0 %then %do; */
16517 +%endline:
16519 +%if &_tsmetads ne %then %do;
16520 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
16521 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
16522 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
16523 +         data &EM_USER_TSMETA;
16524 +                   set &_tsmetads;
16525 +         run;
16526 +    %end;
16527 +%end;
16529 +*proc print data=&EM_DATA_EMINFO;
16530 +*proc print data=&EM_IMPORT_DATA_EMINFO;
16531 +*run;
16532 +%MEND EM_TS_GETTSMETA;
16535 +/*
16536 +%macro EM_GETTSMETAVARS(TimeInterval=);
16537 +%global &TimeInterval;
16538 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
16539 +%if &dsid > 0 %then %do;
16540 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
16541 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
16542 +%do %while(^ %sysfunc(fetch(&dsid)));
16543 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16544 +     %if &_role eq TIMEID %then %do;
16545 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
16546 +     %end;
16547 +%end;
16548 +%let dsid = %sysfunc(close(&dsid));
16549 +%end;
16550 +%MEND EM_GETTSMETAVARS;
16551 +*/
16552 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
16553 +%global &TimeInterval;
16554 +%global &TimeId;
16555 +%global &EndTime;
16556 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
16557 +proc print data=&EM_USER_TSMETA;
16558 +run;
16559 +%if &dsid > 0 %then %do;
16560 +%if &TimeInterval ne %then %do;
16561 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
16562 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
16563 +    %do %while(^ %sysfunc(fetch(&dsid)));
16564 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16565 +        %if &_role eq TIMEID %then %do;
16566 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
16567 +        %end;
16568 +     %end;
16569 +%end;
16570 +%if &TimeId ne %then %do;
16571 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
16572 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
16573 +    %do %while(^ %sysfunc(fetch(&dsid)));
16574 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16575 +        %if &_role eq TIMEID %then %do;
16576 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
16577 +        %end;
16578 +    %end;
16579 +%end;
16581 +%if &EndTime ne %then %do;
16582 +    %let vn_end =%sysfunc(varnum(&dsid, END));
16583 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
16584 +    %do %while(^ %sysfunc(fetch(&dsid)));
16585 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16586 +        %if &_role eq TIMEID %then %do;
16587 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
16588 +        %end;
16589 +     %end;
16590 +%end;
16591 +%let dsid = %sysfunc(close(&dsid));
16592 +%end;
16593 +%MEND EM_TS_GETTSMETAVARS;
16597 +/*------------------------------------------------------------------
16599 +      Macro EM_GETTSIDMAP
16601 +------------------------------------------------------------------+*/
16604 +%macro EM_TS_GETTSIDMAP(updated=);
16606 +%let _tsidmap = ;
16608 +%if &updated = Y %then %do;
16609 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
16610 +%if %sysfunc(exist(&_tsidmap)) %then %do;
16611 +%goto endline;
16612 +%end;
16613 +%end;
16615 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
16616 +%if &dsid > 0 %then %do;
16617 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
16618 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
16619 +%do %while(^ %sysfunc(fetch(&dsid)));
16620 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
16621 +     %if &_key eq TSIDMAP %then %do;
16622 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
16623 +     %end;
16624 +%end;
16626 +%let dsid = %sysfunc(close(&dsid));
16627 +%end;
16629 +%endline:
16631 +%if &_tsidmap ne %then %do;
16633 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
16634 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16636 +%if %sysfunc(exist(&_tsidmap)) %then %do;
16637 +         data &EM_USER_TSIDMAP;
16638 +               set &_tsidmap;
16639 +         run;
16640 +    %end;
16641 +%end;
16642 +%MEND EM_TS_GETTSIDMAP;
16644 +/*------------------------------------------------------------------*/
16649 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
16650 +%global &value;
16653 +%let dsid = %sysfunc(open(&data));
16654 +%if &dsid > 0 %then %do;
16655 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
16656 +    %if &vn_var < 1 %then %do;
16657 +        %let &value = 0;
16658 +        %let dsid = %sysfunc(close(&dsid));
16659 +        %goto endline;
16660 +    %end;
16661 +%let dsid = %sysfunc(close(&dsid));
16662 +%end;
16664 +%let _tmp=_tmpDS;
16665 +proc means data=&data &stat;
16666 +     var &var;
16667 +     output out=&_tmp;
16668 +run;
16670 +%let dsid = %sysfunc(open(&_tmp));
16671 +%if &dsid > 0 %then %do;
16672 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
16673 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
16674 +     %do %while(^%sysfunc(fetch(&dsid)));
16675 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
16676 +         %if &_stat eq &stat %then %do;
16677 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
16678 +          %end;
16679 +      %end;
16680 +%let dsid = %sysfunc(close(&dsid));
16681 +%end;
16682 +proc datasets lib=work nolist;
16683 + delete &_tmp;
16684 +run;
16685 +%endline:
16686 +%MEND EM_TS_GET_STAT;
16689 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
16690 +%global &format;
16691 +%global &informat;
16692 +%let dsid = %sysfunc(open(&data));
16693 +%if &dsid > 0 %then %do;
16694 +%let vn_var =%sysfunc(varnum(&dsid, &var));
16695 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
16696 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
16697 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
16698 +%end;
16699 +%let dsid = %sysfunc(close(&dsid));
16700 +%end;
16701 +%MEND EM_TS_GET_VAR_FORMAT;
16703 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
16704 +      %if &lib eq %then %let lib=work;
16705 +       proc datasets lib=&lib nolist;
16706 +              delete &dsname;
16707 +       run;
16708 +%Mend  EM_TS_DELETE_DATA;
16711 +%macro EM_TS_GetNObs(inds=, nobs=);
16712 +    %global &nobs;
16713 +    %let &nobs=0;
16714 +    data _null_;
16715 +        set &inds end=eof;
16716 +        if eof then call symput("&nobs", _N_);
16717 +    run;
16718 +    quit;
16720 +    /*
16721 +    %let dsid=%sysfunc(open(&outdata));
16722 +    %if dsid > 0 %then %do;
16723 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
16724 +        %let dsid = %sysfunc(close(&dsid));
16725 +     %end;
16726 +    */
16727 +%mend  EM_TS_GetNObs;
16730 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
16731 +%global &time1;
16732 +%global &time2;
16733 +%if &default = Y %then %do;
16734 +   data _null_;
16735 +        set &data end=eof;
16736 +        if _N_ = 1 then  call symput("&time1", DATE);
16737 +        if eof then call symput("&time2", DATE);
16738 +    run;%end;
16739 +%else %do;
16740 +    %let dsid = %sysfunc(open(&data));
16741 +    %if &dsid > 0 %then %do;
16742 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
16743 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
16744 +        %do %while(^%sysfunc(fetch(&dsid)));
16745 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
16746 +             %if &_index eq 1 %then %do;
16747 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
16748 +             %end;
16749 +             %if &_index eq 2 %then %do;
16750 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
16751 +             %end;
16752 +        %end;
16753 +    %let dsid = %sysfunc(close(&dsid));
16754 +    %end;
16755 +%end;
16757 +%MEND EM_TS_GET_TIME_VALUES;
16759 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
16760 +%global &exist;
16761 + %let &exist = N;
16762 +%let dsid = %sysfunc(open(&data));
16763 +%if &dsid > 0 %then %do;
16764 +%let vn_var =%sysfunc(varnum(&dsid, &var));
16765 +%if &vn_var > 0 %then %do;
16766 +    %let &exist = Y;
16767 +%end;
16768 +%let dsid = %sysfunc(close(&dsid));
16769 +%end;
16770 +%MEND EM_TS_GET_VAR_EXIST;
16773 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
16774 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
16775 +      set &intreedata;
16776 +        LENGTH NodeType $32;
16777 +      if _PARENT_ eq " " then delete;
16778 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
16779 +        else NodeType = "CLUSTER";
16780 +        LinkID = _N_;
16781 +run;
16782 +%Mend EM_TS_MakeConstellPlotData;
16787 +%macro EM_TS_CreateIDMap(
16788 +/*-------------------------------------------------------------------------*/
16789 +/*---   Written by Xiangxiang Meng                                         */
16790 +/*-------------------------------------------------------------------------*/
16791 +inDS          =,      /* imported data set in TS data mining               */
16792 +outIDMap      =,      /* output data set of TS ID map                      */
16793 +outDS         =,      /* output data set of TS and TS ID merged            */
16794 +variableSet   =,      /* EM variable set                                   */
16795 +TSIDbyCrossID =Y,
16796 +inEM          =Y
16797 +/*-------------------------------------------------------------------------*/
16798 +);
16800 +%global EM_TS_ERR;
16801 +%let EM_TS_ERR = 0;
16803 +%if &inEM eq Y %then %do;
16804 +    %let num_crossIDVar = &EM_NUM_CROSSID;
16805 +    proc sql noprint;
16806 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
16807 +    quit;
16808 +%end;
16809 +%else %do;
16810 +    proc sql noprint;
16811 +         select count(*) into :num_crossIDVar from &variableSet
16812 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16813 +         ;
16814 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
16815 +         ;
16816 +    quit;
16817 +    %let num_crossIDVar=&num_crossIDVar;
16818 +%end;
16820 +* see if _TSID_ exists;
16822 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
16823 +run;
16825 +proc sql noprint;
16826 +    select count(*) into :has_TSID
16827 +        from _emtscm_contents
16828 +        where upcase(strip(name)) eq '_TSID_'
16829 +    ;
16830 +quit;
16832 +/*-------------------------------------------------------------------------*/
16833 +* Creating TSID map..;
16834 +/*-------------------------------------------------------------------------*/
16836 +%if (&num_crossIDVar gt 0) %then %do;
16838 +    data _emtscm_tmpIDMap;
16839 +        set &variableSet;
16840 +        where  (upcase(strip(level)) eq 'INTERVAL')
16841 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
16842 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
16843 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
16844 +          );
16845 +        _emts_dummy=1;
16846 +        keep name label role _emts_dummy;
16847 +    run;
16849 +    proc sql noprint;
16850 +        * create a string of crossID variable like A,B,C,D..;
16851 +        select distinct name into :crossIDVar separated by ','
16852 +            from &variableSet
16853 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16854 +            order by name
16855 +        ;
16856 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
16857 +            from &variableSet
16858 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16859 +            order by name
16860 +        ;
16861 +        * create the TSID map data set;
16862 +        create table _emtscm_tmp1 as
16863 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
16864 +        ;
16865 +        * create a level list of cross ID variables and time series variables;
16866 +        create table &outIDMap as
16867 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
16868 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
16869 +            where a._emts_dummy eq b._emts_dummy
16870 +            order by a.name, &crossIDVar
16871 +        ;
16872 +    quit;
16874 +    %if &TSIDbyCrossID = Y %then %do;
16875 +        * create unique TSID only by Cross ID;
16876 +        data &outIDMap;
16877 +            length _TSID_ 8;
16878 +            set &outIDMap;
16879 +            by _NAMEID_;
16880 +            if first._NAMEID_
16881 +                then _TSID_=1;
16882 +                else _TSID_+1;
16883 +        run;
16884 +        %if "&outDS" ne "" %then %do;
16885 +            * merge TSID into &inDS;
16886 +            proc sql noprint;
16887 +                create table &outDS as
16888 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
16889 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
16890 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
16891 +                        where %do i = 1 %to &num_crossIDVar;
16892 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
16893 +                              %end;
16894 +                             b._TSID_ is not missing
16895 +                    order by b._TSID_, a.&timeIDVar
16896 +                ;
16897 +            quit;
16898 +        %end;
16899 +    %end;
16900 +    %else %do;
16901 +        * create unique TSID by Cross ID and _NAMEID_;
16902 +        data &outIDMap;
16903 +            length _TSID_ 8;
16904 +            set &outIDMap;
16905 +            _TSID_=_n_;
16906 +        run;
16907 +        %if "&outDS" ne "" %then %do;
16908 +            *no merge in this output;
16909 +            data &outDS;
16910 +                set &inDS;
16911 +            run;
16912 +        %end;
16913 +    %end;
16915 +    proc sort data=&outIDMap;
16916 +        by _NAMEID_ _TSID_;
16917 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
16918 +        format _TSID_ best12. _NAMEID2_ $40.;
16919 +        set &outIDMap;
16920 +        by _NAMEID_;
16921 +        if first._NAMEID_
16922 +            then _emts_ind=1;
16923 +            else _emts_ind+1;
16924 +        drop _emts_ind;
16925 +        rename _NAMEID_=_VARNAME_;
16926 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
16927 +        if _labelID_ eq ' '
16928 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
16929 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
16930 +    run;
16932 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
16934 +%end;
16935 +%else %do; /* if no crossid's the nameid needs to be created */
16937 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
16938 +        length _TSID_ 8;
16939 +        set &variableSet;
16940 +        where  (upcase(strip(level)) eq 'INTERVAL')
16941 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
16942 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
16943 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
16944 +          );
16945 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
16946 +        rename ROLE = _ROLE_;
16947 +        _NAMEID_=strip(name);
16948 +        _VARNAME_=strip(name);
16949 +        if label eq ' '
16950 +            then _LABELID_ = strip(name);
16951 +            else _LABELID_ = strip(label);
16952 +        _TSID_=_n_;
16953 +    run;
16955 +    %if "&outDS" ne "" %then %do;
16956 +        *no merge in this output;
16957 +        data &outDS;
16958 +            set &inDS;
16959 +        run;
16960 +    %end;
16961 +%end;
16963 +data &outIDMap;
16964 +    set &outIDMap;
16965 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
16966 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
16967 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
16968 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
16969 +run;
16971 +proc datasets lib=work nolist;
16972 +    delete _emtscm_:;
16973 +run; quit;
16975 +%mend EM_TS_createIDMap;
16977 +%macro EM_TS_CreateMetaData(
16978 +/*-------------------------------------------------------------------------*/
16979 +  inDS          =,      /* imported data set in TS data mining             */
16980 +  outDS         =,      /* output data set of TS metadata                  */
16981 +  variableSet   =,      /* EM variable set                                 */
16982 +  timeInterval  =,      /* time interval                                   */
16983 +  rc            =       /* return code                                     */
16984 +/*-------------------------------------------------------------------------*/
16985 +);
16987 +%if %eval(
16988 +      &EM_NUM_BINARY_INPUT   +
16989 +      &EM_NUM_ORDINAL_INPUT  +
16990 +      &EM_NUM_NOMINAL_INPUT  +
16991 +      &EM_NUM_BINARY_REJECTED   +
16992 +      &EM_NUM_ORDINAL_REJECTED  +
16993 +      &EM_NUM_NOMINAL_REJECTED  +
16994 +      &EM_NUM_ORDINAL_TARGET  +
16995 +      &EM_NUM_NOMINAL_TARGET +
16996 +      &EM_NUM_BINARY_TARGET
16997 +      ) > 0
16998 +%then %do;
16999 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
17000 +        %put &em_codebar;
17001 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
17002 +        %put &errormsg;
17003 +        %put &em_codebar;
17004 +        %goto ENDLINE;
17005 +%end;
17007 +%global EM_TS_ERR;
17008 +%let EM_TS_ERR = 0;
17010 +%if &timeInterval eq AUTO
17011 +    %then %let timeInterval  = ;
17012 +    %else %let timeInterval  = %upcase(&timeInterval);
17014 +/*-------------------------------------------------------------------------*/
17015 +* check time ID variable;
17016 +/*-------------------------------------------------------------------------*/
17018 +* number of variables in the Variableset with ROLE=TIMEID;
17019 +proc sql noprint;
17020 +    select count(*) into :num_timeID from &variableset
17021 +        where upcase(role) eq 'TIMEID';
17022 +quit;
17024 +/*-------------------------------------------------------------------------*/
17025 +* process only when there is one Time ID, otherwise exception message;
17026 +/*-------------------------------------------------------------------------*/
17028 +%if &num_timeID eq 0 %then %do;
17030 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
17031 +    %let EM_TS_ERR = 11;
17032 +    %put &em_codebar;
17033 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
17034 +    %put &errormsg;
17035 +    %put &em_codebar;
17036 +    %goto tscm_endline;
17038 +%end;
17039 +%else %if &num_timeID gt 1 %then %do;
17041 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
17042 +    %let EM_TS_ERR = 12;
17043 +    %put &em_codebar;
17044 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
17045 +    %put &errormsg;
17046 +    %put &em_codebar;
17047 +    %goto tscm_endline;
17049 +%end;
17050 +%else %do;
17051 +    *** proceed when there is one Time ID;
17053 +    data _null_;
17054 +        set &variableset(where=(upcase(role)='TIMEID'));
17055 +        call symput('timeIDFormat',     strip(format));
17056 +        call symput('timeID',           strip(upcase(name)      ));
17057 +        call symput('timeIDLevel',      strip(upcase(level))     );
17058 +        call symput('timeIDFormatType', strip(upcase(formattype)));
17059 +    run;
17061 +    *** exception message if the time ID is not an interval variable;
17062 +    %if &timeIDLevel ne INTERVAL %then %do;
17063 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
17064 +        %let EM_TS_ERR = 13;
17065 +        %put &em_codebar;
17066 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
17067 +        %put &errormsg;
17068 +        %put &em_codebar;
17069 +        %goto tscm_endline;
17070 +    %end;
17072 +    %if (&timeIDFormatType ne DATETIME) and
17073 +        (&timeIDFormatType ne DATE) and
17074 +        (&timeIDFormatType ne TIME) and
17075 +        (&timeIDFormatType ne USER)
17076 +    %then %do;
17077 +        *** sequential format-type of time ID;
17079 +        %let timeInterval = DAY;
17080 +        %let timeIDFormatType = SEQ;
17082 +        proc sql noprint;
17083 +            create table _emtscm_inds as
17084 +                 select distinct &timeID from &inDS(keep=&timeID)
17085 +                 where &timeID is not missing;
17086 +            select count(*) into :num_nonInteger from _emtscm_inds
17087 +                where &timeID ne int(&timeID);
17088 +        quit;
17090 +        %if &num_nonInteger gt 0 %then %do;
17091 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
17092 +            %let EM_TS_ERR = 14;
17093 +            %put &em_codebar;
17094 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
17095 +            %put &errormsg;
17096 +            %put &em_codebar;
17097 +            %goto tscm_endline;
17098 +        %end;
17099 +    %end;
17100 +    %else %do;
17101 +        *** date, datetime, time format-type of time ID;
17103 +        *** must have a format;
17104 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
17105 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
17106 +            %let EM_TS_ERR = 15;
17107 +            %put &em_codebar;
17108 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
17109 +            %put &errormsg;
17110 +            %put &em_codebar;
17111 +            %goto tscm_endline;
17112 +        %end;
17114 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
17115 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
17116 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
17117 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
17118 +                %let EM_TS_ERR = 16;
17119 +                %put &em_codebar;
17120 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
17121 +                %put &errormsg;
17122 +                %put &em_codebar;
17123 +                %goto tscm_endline;
17124 +            %end;
17125 +        %end;
17127 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
17128 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
17129 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
17130 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
17131 +                %let EM_TS_ERR = 17;
17132 +                %put &em_codebar;
17133 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
17134 +                %put &errormsg;
17135 +                %put &em_codebar;
17136 +                %goto tscm_endline;
17137 +            %end;
17138 +        %end;
17140 +        *** the AUTO function is currently turned off for TIME timeID variable;
17141 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
17142 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
17143 +            %let EM_TS_ERR = 18;
17144 +            %put &em_codebar;
17145 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
17146 +            %put &errormsg;
17147 +            %put &em_codebar;
17148 +            %goto tscm_endline;
17149 +        %end;
17151 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
17152 +            %then %let timeInterval =DT&timeInterval;
17154 +        proc sql noprint;
17155 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
17156 +                where &timeID is not missing;
17157 +        quit;
17158 +    %end;
17160 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
17161 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
17162 +    run;
17164 +    %let hasValidInterval = 0;
17165 +    %let hasLengthOne     = 0;
17167 +    proc sql noprint;
17168 +        create table _emtscm_label as
17169 +            select name,label
17170 +            from dictionary.columns
17171 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
17172 +        ;
17173 +        create table _emtscm_meta2 as
17174 +            select a.*, b.label
17175 +            from _emtscm_meta as a, _emtscm_label as b
17176 +            where upcase(a.timeID) eq upcase(b.name)
17177 +        ;
17178 +    quit;
17180 +    data &outDS;
17181 +        set _emtscm_meta2;
17182 +        format
17183 +            timeformat      $30.
17184 +            role            $10.
17185 +            start           &timeIDformat
17186 +            end             &timeIDformat
17187 +            apply_start_end $8.
17188 +        ;
17189 +        rename
17190 +            timeID      = name
17191 +            seasonality = lengthOfCycle
17192 +            interval    = timeinterval
17193 +        ;
17194 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
17196 +        role            = "TIMEID";
17197 +        apply_start_end = 'N';
17198 +        timeformat      = symget('timeIDformat');
17199 +        timeformattype  = symget('timeIDformatType');
17201 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
17202 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
17203 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
17204 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
17205 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
17206 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
17207 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
17208 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
17209 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
17210 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
17212 +        if timeformattype eq 'SEQ' then do;
17213 +            timeformat='BEST12.';
17214 +            seasonality=1;
17215 +        end;
17217 +        call symput('_tinterval',interval);
17219 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
17221 +        if upcase(timeformattype) eq 'DATE' and
17222 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
17223 +            then call symput('hasValidInterval',1);
17225 +        if upcase(timeformattype) eq 'DATETIME' and
17226 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
17227 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
17228 +            then call symput('hasValidInterval',1);
17230 +        if upcase(timeformattype) eq 'TIME' and
17231 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
17232 +            then call symput('hasValidInterval',1);
17234 +        if upcase(timeformattype) eq 'SEQ'
17235 +            then call symput('hasValidInterval',1);
17237 +        if upcase(timeformattype) eq 'USER'
17238 +            then call symput('hasValidInterval',1);
17240 +        if start eq end
17241 +            then call symput('hasLengthOne',1);
17242 +    run;
17244 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
17246 +    *** detect any missing time interval after running PROC TIMEID;
17247 +    %if &_tinterval eq %then %do;
17248 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
17249 +        %let EM_TS_ERR = 19;
17250 +        %put &em_codebar;
17251 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
17252 +        %put &errormsg;
17253 +        %put &em_codebar;
17254 +        %goto tscm_endline;
17255 +    %end;
17257 +    *** detect any missing time interval after running PROC TIMEID;
17258 +    %if &hasValidInterval eq 0 %then %do;
17259 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
17260 +        %let EM_TS_ERR = 20;
17261 +        %put &em_codebar;
17262 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
17263 +        %put &errormsg;
17264 +        %put &em_codebar;
17265 +        %goto tscm_endline;
17266 +    %end;
17268 +    %if &hasLengthOne eq 1 %then %do;
17269 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
17270 +        %let EM_TS_ERR = 21;
17271 +        %put &em_codebar;
17272 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
17273 +        %put &errormsg;
17274 +        %put &em_codebar;
17275 +        %goto tscm_endline;
17276 +    %end;
17278 +%end;
17280 +%tscm_endline:;
17282 +%mend EM_TS_CreateMetaData;
17285 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
17287 +data _null_;
17288 +    set &tsmeta;
17289 +    call symput('_timeidFormatType', timeformattype);
17290 +    call symput('_timeid', strip(name));
17291 +    call symput('_seqstartnum',strip(put(start,best12.)));
17292 +run;
17294 +proc contents data=&inDS noprint
17295 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
17296 +run; quit;
17298 +data _null_;
17299 +    set _emts_tmpp1;
17300 +    call symput('_timeIDlabel',label);
17301 +run;
17303 +%if &_timeidFormatType eq SEQ
17304 +%then %do;
17305 +    proc sql noprint;
17306 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
17307 +    quit;
17308 +    %let _dummystarttime=&_dummystarttime;
17310 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
17311 +        set &inDS;
17312 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
17313 +        drop &_timeid;
17314 +        label _tsdp_tmpID = "&_timeIDlabel";
17316 +    run;
17317 +%end;
17319 +%mend;
17321 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
17323 +data _null_;
17324 +    set &tsmeta;
17325 +    call symput('_timeidFormatType', timeformattype);
17326 +    call symput('_timeidFormat', timeformat);
17327 +    call symput('_timeid', strip(name));
17328 +    call symput('_timeinterval',strip(upcase(timeinterval)));
17329 +run;
17331 +/* manually change time ID format to a longer enough time format */
17332 +/* because proc timeid returns time5. for second time interval */
17333 +/* which is not long enough for transpose with time unit as seconds */
17334 +%if &_timeinterval eq SECOND
17335 +%then %do;
17336 +    %let _timeIDformat = %str(time8.);
17337 +%end;
17339 +proc contents data=&inDS noprint
17340 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
17341 +run; quit;
17343 +data _null_;
17344 +    set _emts_tmpp1;
17345 +    call symput('_timeIDlabel',label);
17346 +run;
17348 +%if &_timeidFormatType eq TIME
17349 +%then %do;
17350 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
17351 +        set &inDS;
17352 +        _tsdp_tmpID = timepart(&_timeID);
17353 +        format _tsdp_tmpID &_timeidFormat;
17354 +        label  _tsdp_tmpID = "&_timeIDlabel";
17355 +        drop &_timeid;
17356 +    run;
17357 +%end;
17359 +%mend;
17361 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
17363 + proc sql noprint;
17364 +     create table _tmptimetable as
17365 +         select distinct &timeidvar as DATE from &inDS
17366 +         where &timeIDVar is not missing
17367 +         order by &timeIDVar;
17368 + quit;
17370 +%if &compare eq Y %then %do;
17371 +    * compare with the existing time table;
17372 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
17373 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
17374 +    run;
17376 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
17378 +    %if &_diffobs > 0 %then %do; /* create it again */
17379 +        data &outDS(keep=DATE _INDEX_);
17380 +            set _tmptimetable end = _eof_;
17381 +            if _N_ = 1
17382 +                then _INDEX_ = 1;
17383 +                else _INDEX_ = 0;
17384 +            if _eof_ then _INDEX_= 2;
17385 +        run;
17386 +    %end;
17388 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
17389 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
17390 +%end;
17391 +%else %do;
17392 +    * create a new time table directly;
17393 +    data &outDS(keep=DATE _INDEX_);
17394 +        set _tmptimetable end = _eof_;
17395 +        if _N_ = 1
17396 +            then _INDEX_ = 1;
17397 +            else _INDEX_ = 0;
17398 +        if _eof_ then _INDEX_= 2;
17399 +    run;
17401 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
17402 +%end;
17404 +* assign a defult format BEST12. for sequential time ID;
17406 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
17408 +%let _nodatefmt=N;
17410 +data _null_;
17411 +    set _tmpcontents;
17412 +    where upcase(name) eq 'DATE';
17413 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
17414 +run;
17416 +%if "&_nodatefmt" eq "Y" %then %do;
17417 +    data &outDS;
17418 +        set &outDS;
17419 +        format date best12.;
17420 +    run;
17421 +%end;
17423 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
17425 +%mend;
17429 +%macro EM_TS_Transpose(
17430 +/*-------------------------------------------------------------------------*/
17431 +  inDS          =,      /* imported data set in TS data mining             */
17432 +  inIDMap       =,      /* input TS ID map                                 */
17433 +  variableSet   =,      /* variable set                                    */
17434 +  transposeBy   =,      /* byTSID or byTimeID                              */
17435 +  outDS         =,      /* output transposed data set                      */
17436 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
17437 +  inEM          =Y,
17438 +  timePrefix    =_T
17439 +/*-------------------------------------------------------------------------*/
17440 +);
17442 +%let timePrefix = &timePrefix;
17444 +%if  &EM_NUM_CROSSID > 0 %then %do;
17446 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
17447 +    set &inIDMap;
17448 +    drop _NAMEID_;
17449 +    run;
17450 +%let inIDMap=_emtstp_map0;
17452 +%end;
17454 +proc sql noprint;
17455 +    * number of TS Variables to be transposed;
17456 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
17457 +    ;
17458 +    * number of TS Variables to be transposed;
17459 +    select max(_TSID_) into :num_TSID from &inIDMap
17460 +    ;
17461 +    * name list of TS Variables;
17462 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
17463 +        from &inIDMap
17464 +        order by _NAMEID_
17465 +    ;
17466 +    * total number of time series =max(_TSID_)*&num_TSVar;
17467 +    * and the number of digits of this variable is &num_digits;
17468 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
17469 +        from &inIDMap
17470 +    ;
17471 +      * Time ID variable;
17472 +    select name into:timeIDVar from &variableset
17473 +        where upcase(role) eq 'TIMEID'
17474 +    ;
17475 +quit;
17476 +%let num_digits = &num_digits;
17477 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
17479 +/*-------------------------------------------------------------------------*/
17481 +* get number of cross IDs and also the TIME ID variable name;
17482 +%if &inEM eq Y %then %do;
17483 +    %let num_crossIDVar = &EM_NUM_CROSSID;
17484 +    %let crossIDVar     = %EM_CROSSID;
17485 +%end;
17486 +%else %do;
17487 +    proc sql noprint;
17488 +        * number of cross ID;
17489 +        select count(*) into :num_crossIDVar
17490 +            from &variableSet
17491 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17492 +        ;
17493 +        * create a string of crossID variable like A B C D..;
17494 +        select distinct name into :crossIDVar separated by ' '
17495 +            from &variableSet
17496 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17497 +            order by name
17498 +        ;
17499 +    quit;
17500 +    %let num_crossIDVar=&num_crossIDVar;
17501 +%end;
17503 +/*-------------------------------------------------------------------------*/
17505 +%if (&num_crossIDVar gt 0) %then %do;
17507 +    data _emtstp_tmpDat;
17508 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
17509 +        _NAMEID_ = cats("_TS_",_TSID_);
17510 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
17511 +    run;
17513 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
17515 +        * update the ID maps;
17516 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
17517 +            by _NAMEID_ _TSID_;
17518 +        data &outIDMap;
17519 +            set _emtstp_tmpmap;
17520 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
17521 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
17522 +        run;
17524 +        * get the names for the new variables;
17525 +        proc sql noprint;
17526 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
17527 +            ;
17528 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
17529 +            ;
17530 +        quit;
17532 +        * data must be sorted before transposed;
17533 +        proc sort data=_emtstp_tmpDat;
17534 +            by &timeIDvar;
17535 +        run;
17537 +        %do i = 1 %to &num_TSVar;
17538 +            %let i = &i;
17539 +            * transpose one cross-type time series data by TSID;
17540 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
17541 +                id _NAMEID_;
17542 +                by &timeIDVar;
17543 +                var &&&TSVar&i;
17544 +            run;
17545 +        %end;
17547 +        * merge all vertical time series, rename and label them;
17548 +        data &outDS;
17549 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
17550 +            by &timeIDVar;
17551 +            rename
17552 +                %do i = 1 %to &num_TSVar;
17553 +                    %do j = 1 %to &num_TSID;
17554 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
17555 +                        /* %put &i &j &num1 &num_TSID; */
17556 +                        _V_&i._TS_&j = &&&tsname&num1
17557 +                    %end;
17558 +                %end;
17559 +            ;
17560 +            label
17561 +                %do i = 1 %to &num_TSVar;
17562 +                    %do j = 1 %to &num_TSID;
17563 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
17564 +                        /* %put &i &j &num1 &num_TSID; */
17565 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
17566 +                    %end;
17567 +                %end;
17568 +            ;
17569 +        run;
17570 +    %end;
17571 +    %else %do;
17573 +        * update the ID maps;
17574 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
17575 +            by _NAMEID_ _TSID_;
17576 +        data &outIDMap;
17577 +            set _emtstp_tmpmap;
17578 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
17579 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
17580 +        run;
17582 +        proc sql noprint;
17583 +            * get the roles for the new variables;
17584 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
17585 +                from &inIDMap
17586 +                order by _NAMEID_
17587 +            ;
17588 +            * get the length of the time series;
17589 +            select count(distinct &timeIDvar) into :num_T
17590 +                from _emtstp_tmpDat
17591 +            ;
17592 +        quit;
17594 +        * data must be sorted before transposed;
17595 +        proc sort data=_emtstp_tmpDat;
17596 +            by _TSID_ &crossIDVar &timeIDvar;
17597 +        run;
17599 +        %do i = 1 %to &num_TSVar;
17600 +            %let i = &i;
17601 +            * transpose one cross-type time series data by TIMEID;
17602 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
17603 +                by _TSID_ &crossIDVar;
17604 +                var &&&TSVar&i;
17605 +            run;
17606 +        %end;
17608 +        * stack all horizontal time series;
17609 +        data &outDS;
17610 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
17611 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
17612 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
17613 +            %do i=1 %to &num_TSVar;
17614 +                if in&i then do;
17615 +                    _NAMEID_ ="&&&TSVar&i";
17616 +                    _ROLE_   ="&&&TSRole&i";
17617 +                end;
17618 +            %end;
17619 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
17620 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
17621 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
17622 +        run;
17623 +    %end;
17624 +%end;
17625 +%else %do;
17627 +    proc sql noprint;
17628 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
17629 +            order by _NAMEID_
17630 +        ;
17631 +    quit;
17633 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
17634 +        * transpose the panel-type time series data by TSID;
17635 +        proc sort data=&inDS out=_emtstp_tmpDat;
17636 +            by &timeIDvar;
17637 +        proc transpose data=_emtstp_tmpDat
17638 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
17639 +            by &timeIDVar;
17640 +            var &panelTSVar;
17641 +        run;
17642 +        proc datasets lib=work nolist;
17643 +            modify _emtstp_tmpDat2;
17644 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
17645 +            run; quit;
17646 +    %end;
17647 +    %else %do;
17648 +        * transpose the panel-type time series data by TIMEID;
17649 +        proc sort data=&inDS out=_emtstp_tmpDat;
17650 +            by &timeIDvar;
17651 +        data _emtstp_tmpDat;
17652 +            set _emtstp_tmpDat;
17653 +            _tmp_ind=_n_;
17654 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
17655 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
17656 +            ID _tmp_ind;
17657 +            var &panelTSVar;
17658 +        run;
17659 +    %end;
17661 +      * merge ID maps to the transpose data set;
17662 +      proc sql noprint;
17663 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
17664 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
17665 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
17666 +          ;
17667 +      quit;
17669 +      * update the TS ID map;
17670 +      data &outIDMap;
17671 +          set &inIDMap;
17672 +      run;
17673 +%end;
17675 +proc datasets lib=work nolist;
17676 +    delete _emtstp:;
17677 +run; quit;
17679 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_TRAIN.SOURCE.
17681 +/*----------------------------------------------------------------------------------+
17682 + |
17683 + |   Title :  TS ESM Forecasting Node
17684 + |
17685 + |
17686 + |   SUPPORT: Taiyeong Lee (taiyeong.lee@sas.com)
17687 + |
17688 + +-----------------------------------------------------------------------------------*/
17690 +%macro EM_TSESM_TRAIN;
17692 +   /*---------- Check and assign the input data set --------------------------*/
17694 +    %let _IMPORT_DATA  = ;
17695 +    %let _IMPORT_CMETA = ;
17696 +    %let _DATA_EMINFO  = ;
17697 +    %let _EXPORT_DATA  = ;
17698 +    %let _FILE_CDELTA  = ;
17700 +    %if &EM_IMPORT_DATA ne  %then %do;
17701 +           %let _IMPORT_DATA   = &EM_IMPORT_DATA;
17702 +           %let _IMPORT_CMETA  = &EM_IMPORT_DATA_CMETA;
17703 +           %let _DATA_EMINFO   = &EM_IMPORT_DATA_EMINFO;
17704 +           %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
17705 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
17707 +    %end;
17708 +    %else %if &EM_IMPORT_TRANSACTION ne  %then %do;
17709 +           %let _IMPORT_DATA   = &EM_IMPORT_TRANSACTION;
17710 +           %let _IMPORT_CMETA  = &EM_IMPORT_TRANSACTION_CMETA;
17711 +           %let _DATA_EMINFO   = &EM_IMPORT_TRANSACTION_EMINFO;
17712 +           %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
17713 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRANSACTION;
17714 +    %end;
17715 +    %else %do;
17716 +           %let  EMEXCEPTIONSTRING = exception.server.tsdm.noinputdata;
17717 +           %goto ENDLINE;
17718 +    %end;
17719 +/*-------------  check time id variable -----------------------------*/
17720 +%local _numTimeIDs;
17721 +%let _numTimeIDs=0;
17723 +proc sql noprint;
17724 +    select count(*) into :_numTimeIDs
17725 +    from &EM_DATA_VARIABLESET
17726 +    where upcase(role) eq 'TIMEID' and upcase(strip(level)) eq 'INTERVAL' and upcase(strip(use)) in ('Y' 'D');
17727 +quit;
17729 +%if &_numTimeIDs eq 0 %then %do;
17731 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
17732 +    %put &em_codebar;
17733 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
17734 +    %put &errormsg;
17735 +    %put &em_codebar;
17736 +    %goto ENDLINE;
17738 +%end;
17739 +%else %if &_numTimeIDs gt 1 %then %do;
17741 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
17742 +    %put &em_codebar;
17743 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
17744 +    %put &errormsg;
17745 +    %put &em_codebar;
17746 +    %goto ENDLINE;
17748 +%end;
17750 +   %let _nivars = %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED);
17751 +   %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17752 +        %if &_nivars < 1 %then %do;
17753 +              %put &em_codebar;
17754 +              %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.need1intervalrejectinput_ERR , NOQUOTE));
17755 +              %put &errormsg;
17756 +              %put &em_codebar;
17757 +              %let  EMEXCEPTIONSTRING = exception.server.tsdm.need1intervalrejectinput;
17758 +              %goto ENDLINE;
17759 +         %end;
17761 +   %end;
17762 +   %else %do;
17764 +        /* will forecast a target variable (with crossids) or variables (panel) */
17766 +        %if &EM_NUM_INTERVAL_TARGET < 1 %then %do;
17767 +             %put &em_codebar;
17768 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.USE1INTERVALTARGET_ERR , NOQUOTE));
17769 +             %put &errormsg;
17770 +             %put &em_codebar;
17771 +             %let EMEXCEPTIONSTRING = exception.server.tsdm.USE1INTERVALTARGET;
17772 +             %goto ENDLINE;
17773 +        %end;
17775 +        %if (&EM_NUM_CROSSID > 0) and (&EM_NUM_INTERVAL_TARGET > 1) %then %do;
17777 +             %put &em_codebar;
17778 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.csidonly1inttarget_err , NOQUOTE));
17779 +             %put &errormsg;
17780 +             %put &em_codebar;
17781 +             %let EMEXCEPTIONSTRING = exception.server.tsdm.csidonly1inttarget;
17782 +             %goto ENDLINE;
17783 +        %end;
17785 +    %end;
17787 +    %if  &EM_PROPERTY_STARTSUM > &EM_PROPERTY_FCLEAD %then %do;
17789 +             %put &em_codebar;
17790 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.startsumlessflead_err , NOQUOTE));
17791 +             %put &errormsg;
17792 +             %put &em_codebar;
17793 +             %let  EMEXCEPTIONSTRING =exception.server.tsdm.startsumlessflead;
17794 +             %goto ENDLINE;
17795 +    %end;
17797 +   /* Check strictly positive seq for &EM_PROPERTY_FCMETHOD eq WINTERS or MULTSEASONAL */
17799 +%macro TSESM_input_varlist(varlist);
17800 +   %local outlist i;
17801 +   %let i = 2;
17802 +   %let outlist = %scan(&varlist, 1, ' ' );
17804 +   %do %while (%scan(&varlist, &i, ' ' ) ne );
17806 +      %let outlist = &outlist  %str(,) %scan(&varlist, &i, ' ' );
17807 +      %let i  = %eval(&i+1);
17808 +   %end;
17810 +   &outlist
17811 +%mend TSESM_input_varlist;
17813 +    %if  &EM_PROPERTY_FCMETHOD eq WINTERS or &EM_PROPERTY_FCMETHOD eq MULTSEASONAL %then %do;
17814 +       %let _tsseq_flag = 0;
17816 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17817 +          proc sql noprint;
17818 +             select min(min( %TSESM_input_varlist(%EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED)),100 )  into :_tsseq_min from &_IMPORT_DATA;
17819 +          quit;
17820 +          %if %sysfunc(floor(&_tsseq_min))  < 0 %then  %let  _tsseq_flag = 1;
17821 +       %end;
17822 +       %else %do;
17823 +         proc sql noprint;
17824 +            select min(min( %TSESM_input_varlist(%EM_TARGET)),100 ) into :_tsseq_min from &_IMPORT_DATA;
17825 +         quit;
17826 +         %if %sysfunc(floor(&_tsseq_min))  < 0 %then  %let  _tsseq_flag = 1;
17827 +       %end;
17828 +       %if &_tsseq_flag = 1 %then %do;
17829 +             %put &em_codebar;
17830 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.strictpositive_err , NOQUOTE));
17831 +             %put &errormsg;
17832 +             %put &em_codebar;
17833 +             %let  EMEXCEPTIONSTRING =exception.server.tsdm.strictpositive;
17834 +             %goto ENDLINE;
17835 +       %end;
17836 +    %end;
17840 +   /* When Forecast Input Time Series is Yes, Output Data Type is always Default */
17841 +   %let _EXPORTDATA = &EM_PROPERTY_EXPORTDATA;
17842 +   %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17843 +      %let _EXPORTDATA = DEFAULT   ;
17844 +      %let EM_PROPERTY_EXPORTDATA  = DEFAULT   ;
17846 +   %end;
17848 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
17849 +    %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
17851 +    /*---- EM_TS_CreateMetadata do validation of Time ID and return EM_TS_ERR   ----------------------------*/
17853 +    %EM_TS_CreateMetadata(inDS=&_IMPORT_DATA, outDS =&EM_USER_TSMETA, variableSet =&EM_DATA_VARIABLESET, timeInterval=&EM_PROPERTY_TIMEINTERVAL, rc=);
17855 +    %if &EM_TS_ERR > 0 %then  %do;
17857 +       %let EM_TS_ERR = 0;
17858 +       %goto ENDLINE;
17859 +    %end;
17861 +    /*----- Get time interval ---------------------------*/
17863 +    %EM_TS_GETTSMETAVARS(TimeInterval=_timeinterval);
17865 +    /*--- _EXPORT_DATA will be used as an input data becuase  _TSID_  is needed to run TS ESM Node */
17867 +    %EM_TS_CreateIDMap(inDS=&_IMPORT_DATA, outIDMap =&EM_USER_TSIDMAP, outDS =&_EXPORT_DATA, variableSet =&EM_DATA_VARIABLESET, TSIDbyCrossID =Y);
17869 +    /*----------- Modify TSID MAP --------------------------------*/
17871 +    %if (&EM_NUM_CROSSID > 0) %then %do;
17872 +         %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17873 +             data &EM_USER_TSIDMAP;
17874 +                  set &EM_USER_TSIDMAP;
17875 +                  if upcase(strip(_ROLE_)) ="INPUT" then output;
17876 +             run;
17877 +         %end;
17878 +         %else %do;
17879 +             data &EM_USER_TSIDMAP;
17880 +                  set &EM_USER_TSIDMAP;
17881 +                  if upcase(strip(_ROLE_)) ="TARGET" then output;
17882 +             run;
17883 +         %end;
17884 +    %end;
17885 +    %else %do;
17886 +         %if &_EXPORTDATA ne DEFAULT  %then %do;
17888 +             %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17889 +                 data &EM_USER_TSIDMAP;
17890 +                      set &EM_USER_TSIDMAP; retain _tmptsid 0;
17891 +                      if upcase(strip(_ROLE_)) ="INPUT" then do; _tmptsid=_tmptsid+1; _TSID_=_tmptsid;output;end;
17892 +                      drop _tmptsid;
17893 +                 run;
17894 +             %end;
17895 +             %else %do;
17896 +                 data &EM_USER_TSIDMAP;
17897 +                      set &EM_USER_TSIDMAP; retain _tmptsid 0;
17898 +                      if upcase(strip(_ROLE_)) ="TARGET" then do; _tmptsid=_tmptsid+1; _TSID_=_tmptsid;output;end;
17899 +                      drop _tmptsid;
17900 +                 run;
17902 +             %end;
17903 +         %end;
17904 +    %end;
17909 +    %let _tsidVar = ;
17910 +    %let _existsgmtvar = N;
17912 +    %if %EM_CROSSID ne %then %do;
17913 +        %let _tsidVar =_TSID_ ;
17914 +        /*---------  check Segmentvar : may not need implement, will decided at the next version -----------
17915 +                     So the _segment_ related codes have not been removed in other source codes
17916 +         ---------------------------------------------------------------------------------------------------
17917 +        %let j=1;
17918 +        %do %while(%scan(%EM_CROSSID, &j) ne );
17919 +            %let _csvar=%scan(%EM_CROSSID, &j);
17920 +            %if &_csvar = _SEGMENT_ %then %let _existsgmtvar =Y;
17921 +            %let j=%eval(&j+1);
17922 +        %end;
17923 +        %if &_existsgmtvar = Y %then %let _tsidVar = _SEGMENT_;
17924 +        +-------------------------------------------*/
17925 +    %end;
17927 +    /*----------- Forecasting ----------------------------------*/
17929 +    %EM_GETNAME(KEY=OUTEST, TYPE=DATA);
17930 +    %EM_GETNAME(KEY=OUTDATA, TYPE=DATA);
17931 +    %EM_GETNAME(KEY=OUTFORCST, TYPE=DATA);
17932 +    %EM_GETNAME(KEY=OUTSTAT, TYPE=DATA);
17933 +    %EM_GETNAME(KEY=OUTSUM, TYPE=DATA);
17934 +    %EM_GETNAME(KEY=OUTCLUS, TYPE=DATA);
17935 +    %EM_GETNAME(KEY=OUTLIER, TYPE=DATA);
17936 +    %EM_GETNAME(KEY=OUTPRED, TYPE=DATA);
17937 +    %EM_GETNAME(KEY=OUTKLD, TYPE=DATA);
17938 +    %EM_GETNAME(KEY=OUTLIERDS, TYPE=DATA);
17941 +    %if &EM_PROPERTY_FCMETHOD ne BEST %then %do;
17943 +       %if &EM_PROPERTY_SEASONALITY eq DEFAULT %then %do;
17944 +           %if ( &_timeinterval eq YEAR ) or ( &_timeinterval eq DTYEAR ) %then %do;
17945 +               %if (&EM_PROPERTY_FCMETHOD eq ADDSEASONAL ) or (&EM_PROPERTY_FCMETHOD eq MULTSEASONAL)
17946 +                   or (&EM_PROPERTY_FCMETHOD eq ADDWINTERS) or (&EM_PROPERTY_FCMETHOD eq WINTERS) %then %do;
17947 +                   %let  EMEXCEPTIONSTRING =exception.server.tsdm.requirenonseasonalmodel;
17948 +                   %goto ENDLINE;
17949 +               %end;
17950 +           %end;
17951 +       %end;
17953 +       %EM_TSESM_Forecast(indata=&_EXPORT_DATA,
17954 +                          method=&EM_PROPERTY_FCMETHOD,
17955 +                          timeinterval=&_timeinterval,
17956 +                          timeid=%EM_TIMEID ,
17957 +                          target=%EM_TARGET ,
17958 +                          tsidvar = &_tsidVar,
17959 +                          lead=&EM_PROPERTY_FCLEAD,
17960 +                          back=&EM_PROPERTY_FCBACK,
17961 +                          startsum=&EM_PROPERTY_STARTSUM,
17962 +                          seasonality=&EM_PROPERTY_SEASONALITY,
17963 +                          alpha=&EM_PROPERTY_ALPHA,
17964 +                          accumulate=&EM_PROPERTY_ACCUMULATE,
17965 +                          extendedvalue = &EM_PROPERTY_EXTENDEDVALUE,
17966 +                          outest=&EM_USER_OUTEST,
17967 +                          outdata=&EM_USER_OUTDATA,
17968 +                          outfor =&EM_USER_OUTFORCST ,
17969 +                          outstat = &EM_USER_OUTSTAT ,
17970 +                          outsum=&EM_USER_OUTSUM
17971 +                          );
17972 +    %end;
17973 +    %else %do;
17974 +           %let n_model = 0;
17975 +           %if &EM_PROPERTY_SIMPLE eq Y %then %let n_model = %eval(&n_model+1);
17976 +           %if &EM_PROPERTY_DOUBLE eq Y %then %let n_model = %eval(&n_model+1);
17977 +           %if &EM_PROPERTY_LINEAR eq Y %then %let n_model = %eval(&n_model+1);
17978 +           %if &EM_PROPERTY_DAMPTREND eq Y %then %let n_model = %eval(&n_model+1);
17979 +           %if (&_timeinterval ne YEAR ) and ( &_timeinterval ne DTYEAR ) %then %do;
17980 +               %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then  %let n_model = %eval(&n_model+1);
17981 +               %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %let n_model = %eval(&n_model+1);
17982 +               %if (&EM_PROPERTY_ADDWINTERS eq Y) %then   %let n_model = %eval(&n_model+1);
17983 +               %if (&EM_PROPERTY_WINTERS eq Y) %then      %let n_model = %eval(&n_model+1);
17984 +           %end;
17985 +           %if &n_model eq 0 %then %do;
17986 +                %let  EMEXCEPTIONSTRING =exception.server.tsdm.zerocandidatemodel;
17987 +                %GOTO ENDLINE;
17988 +           %end;
17990 +       %EM_TSESM_Best_Forecast(indata=&_EXPORT_DATA,
17991 +                          method=&EM_PROPERTY_FCMETHOD,
17992 +                          criterion=&EM_PROPERTY_BESTCRIT,
17993 +                          timeinterval=&_timeinterval,
17994 +                          timeid=%EM_TIMEID ,
17995 +                          target=%EM_TARGET ,
17996 +                          tsidvar = &_tsidVar,
17997 +                          lead=&EM_PROPERTY_FCLEAD,
17998 +                          back=&EM_PROPERTY_FCBACK,
17999 +                          startsum=&EM_PROPERTY_STARTSUM,
18000 +                          seasonality=&EM_PROPERTY_SEASONALITY,
18001 +                          alpha=&EM_PROPERTY_ALPHA,
18002 +                          accumulate=&EM_PROPERTY_ACCUMULATE,
18003 +                          extendedvalue = &EM_PROPERTY_EXTENDEDVALUE,
18004 +                          outest=&EM_USER_OUTEST,
18005 +                          outdata=&EM_USER_OUTDATA,
18006 +                          outfor =&EM_USER_OUTFORCST ,
18007 +                          outstat = &EM_USER_OUTSTAT ,
18008 +                          outsum=&EM_USER_OUTSUM
18009 +                         );
18010 +    %end;
18012 +    %EM_TS_Time2Seq(inDS=&EM_USER_OUTFORCST,tsmeta=&EM_USER_TSMETA);
18013 +    %EM_TS_Time2Seq(inDS=&EM_USER_OUTDATA,tsmeta=&EM_USER_TSMETA);
18014 +    %EM_TS_Time2Seq(inDS=&_EXPORT_DATA,tsmeta=&EM_USER_TSMETA);
18017 +    %EM_TSESM_MakeOutlierIndex(indata=&EM_USER_OUTFORCST,
18018 +                               timeid=%EM_TIMEID,
18019 +                               outoutlier=&EM_USER_OUTLIER,
18020 +                               outlierds=&EM_USER_OUTLIERDS,
18021 +                               outdata=&EM_USER_OUTFORCST
18022 +                               );
18024 +    %EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
18025 +                          target=%EM_TARGET,
18026 +                          timeid=%EM_TIMEID,
18027 +                          outdata=&EM_USER_OUTPRED
18028 +                         );
18031 +    %ENDLINE:
18032 +%mend EM_TSESM_TRAIN;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM2_VARIABLESET.
      WHERE UPCASE(role)='TIMEID';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK._EMTSCM_INDS created, with 215 rows and 1 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of time vectors processed: 1
NOTE: There were 215 observations read from the data set WORK._EMTSCM_INDS.
NOTE: The data set WORK._EMTSCM_META has 1 observations and 24 variables.
NOTE: PROCEDURE TIMEID used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK._EMTSCM_LABEL created, with 1 rows and 2 columns.
 
NOTE: Table WORK._EMTSCM_META2 created, with 1 rows and 25 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      379:48    399:62    415:122   425:137   435:136   445:152
NOTE: There were 1 observations read from the data set WORK._EMTSCM_META2.
NOTE: The data set EMWS5.TSESM2_TSMETA has 1 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The file WORK._EM_TSCM: (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM2_TSMETA.
NOTE: The PROCEDURE PRINT printed page 2.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTSCM_CONTENTS has 6 observations and 1 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 5 observations read from the data set EMWS5.TSESM2_VARIABLESET.
      WHERE (UPCASE(STRIP(level))='INTERVAL') and (((UPCASE(STRIP(role))='INPUT') and UPCASE(STRIP(use)) in ('D', 'Y')) or ((UPCASE(STRIP(role))='REJECTED') and (UPCASE(STRIP(use))='Y')) or ((UPCASE(STRIP(role))='TARGET') and UPCASE(STRIP(use)) in ('D',
      'Y')));
NOTE: The data set EMWS5.TSESM2_TSIDMAP has 5 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 215 observations read from the data set EMWS5.TSDP2_TRAIN.
NOTE: The data set EMWS5.TSESM2_TRAIN has 215 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Variable _varname_ is uninitialized.
NOTE: There were 5 observations read from the data set EMWS5.TSESM2_TSIDMAP.
NOTE: The data set EMWS5.TSESM2_TSIDMAP has 5 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK._EMTSCM_CONTENTS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_INDS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_LABEL (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META2 (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 215 observations read from the data set EMWS5.TSESM2_TRAIN.
NOTE: The data set WORK._TMPDATA has 215 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 215 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT1 has 221 observations and 6 variables.
NOTE: The data set WORK._OUTEST1 has 1 observations and 8 variables.
NOTE: The data set WORK._OUTFOR1 has 221 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT1 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM1 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 215 observations read from the data set EMWS5.TSESM2_TRAIN.
NOTE: The data set WORK._TMPDATA has 215 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 215 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT2 has 221 observations and 6 variables.
NOTE: The data set WORK._OUTEST2 has 1 observations and 8 variables.
NOTE: The data set WORK._OUTFOR2 has 221 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT2 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM2 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 215 observations read from the data set EMWS5.TSESM2_TRAIN.
NOTE: The data set WORK._TMPDATA has 215 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 215 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT3 has 221 observations and 6 variables.
NOTE: The data set WORK._OUTEST3 has 2 observations and 8 variables.
NOTE: The data set WORK._OUTFOR3 has 221 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT3 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM3 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 215 observations read from the data set EMWS5.TSESM2_TRAIN.
NOTE: The data set WORK._TMPDATA has 215 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 215 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT4 has 221 observations and 6 variables.
NOTE: The data set WORK._OUTEST4 has 3 observations and 8 variables.
NOTE: The data set WORK._OUTFOR4 has 221 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT4 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM4 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 215 observations read from the data set EMWS5.TSESM2_TRAIN.
NOTE: The data set WORK._TMPDATA has 215 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 215 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT5 has 221 observations and 6 variables.
NOTE: The data set WORK._OUTEST5 has 3 observations and 8 variables.
NOTE: The data set WORK._OUTFOR5 has 221 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT5 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM5 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 215 observations read from the data set EMWS5.TSESM2_TRAIN.
NOTE: The data set WORK._TMPDATA has 215 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 215 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT6 has 221 observations and 6 variables.
NOTE: The data set WORK._OUTEST6 has 2 observations and 8 variables.
NOTE: The data set WORK._OUTFOR6 has 221 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT6 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM6 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 215 observations read from the data set EMWS5.TSESM2_TRAIN.
NOTE: The data set WORK._TMPDATA has 215 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 215 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT7 has 221 observations and 6 variables.
NOTE: The data set WORK._OUTEST7 has 2 observations and 8 variables.
NOTE: The data set WORK._OUTFOR7 has 221 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT7 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM7 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 215 observations read from the data set EMWS5.TSESM2_TRAIN.
NOTE: The data set WORK._TMPDATA has 215 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 215 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT8 has 221 observations and 6 variables.
NOTE: The data set WORK._OUTEST8 has 3 observations and 8 variables.
NOTE: The data set WORK._OUTFOR8 has 221 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT8 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM8 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
NOTE: Table WORK.TSSTAT created, with 8 rows and 58 columns.
 
NOTE: Table WORK.TSEST created, with 17 rows and 9 columns.
 
NOTE: Table WORK.TSFOR created, with 1768 rows and 9 columns.
 
NOTE: Table WORK.TSOUT created, with 1768 rows and 7 columns.
 
NOTE: Table WORK.TSSUM created, with 40 rows and 20 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 8 observations read from the data set WORK.TSSTAT.
NOTE: The data set WORK.BESTMDL has 8 observations and 58 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 8 observations read from the data set WORK.BESTMDL.
NOTE: The data set WORK.BESTMDL has 1 observations and 58 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK.BESTID created, with 1 rows and 4 columns.
 
NOTE: Table EMWS5.TSESM2_OUTFORCST created, with 221 rows and 11 columns.
 
NOTE: Table EMWS5.TSESM2_OUTSTAT created, with 1 rows and 59 columns.
 
NOTE: Table EMWS5.TSESM2_OUTEST created, with 2 rows and 10 columns.
 
NOTE: Table EMWS5.TSESM2_OUTSUM created, with 1 rows and 22 columns.
 
NOTE: PROC SQL statements are executed immediately; The RUN statement has no effect.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK.BESTMDL.
NOTE: The data set WORK._TMPDS1 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS2 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS3 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS4 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS5 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS6 has 1 observations and 58 variables.
NOTE: The data set WORK._TMPDS7 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS8 has 0 observations and 58 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 221 observations read from the data set WORK._OUT1.
NOTE: The data set EMWS5.TSESM2_OUTDATA has 221 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: There were 221 observations read from the data set WORK._OUT1.
NOTE: The data set EMWS5.TSESM2_OUTDATA has 221 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: There were 221 observations read from the data set WORK._OUT2.
NOTE: The data set EMWS5.TSESM2_OUTDATA has 221 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: There were 221 observations read from the data set WORK._OUT3.
NOTE: The data set EMWS5.TSESM2_OUTDATA has 221 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: There were 221 observations read from the data set WORK._OUT4.
NOTE: The data set EMWS5.TSESM2_OUTDATA has 221 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: There were 221 observations read from the data set WORK._OUT5.
NOTE: The data set EMWS5.TSESM2_OUTDATA has 221 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: There were 221 observations read from the data set WORK._OUT6.
NOTE: The data set EMWS5.TSESM2_OUTDATA has 221 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: There were 221 observations read from the data set WORK._OUT7.
NOTE: The data set EMWS5.TSESM2_OUTDATA has 221 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: There were 221 observations read from the data set WORK._OUT8.
NOTE: The data set EMWS5.TSESM2_OUTDATA has 221 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
WARNING: The variable mdlID in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable _MODEL_ in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable MSE in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: The data set EMWS5.TSESM2_OUTDATA has 221 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 2 observations read from the data set EMWS5.TSESM2_OUTEST.
NOTE: The data set EMWS5.TSESM2_OUTEST has 2 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTFORCST.
NOTE: The data set EMWS5.TSESM2_OUTFORCST has 221 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM2_OUTSTAT.
NOTE: The data set EMWS5.TSESM2_OUTSTAT has 1 observations and 58 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM2_OUTSUM.
NOTE: The data set EMWS5.TSESM2_OUTSUM has 1 observations and 20 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM2_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM2_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM2_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTFORCST.
NOTE: The data set EMWS5.TSESM2_OUTFORCST has 221 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
WARNING: The variable _TSID_ in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable _SEGMENT_ in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable _NAMEID_ in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTFORCST.
NOTE: The data set EMWS5.TSESM2_OUTLIER has 215 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 215 observations read from the data set EMWS5.TSESM2_OUTLIER.
NOTE: The data set EMWS5.TSESM2_OUTLIERDS has 16 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
WARNING: The variable _TSID_ in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTFORCST.
NOTE: The data set EMWS5.TSESM2_OUTPRED has 6 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
18036
18037
18038  *------------------------------------------------------------*;
18039  * End TRAIN: TSESM2;
18040  *------------------------------------------------------------*;
 
18041  *------------------------------------------------------------*;
18042  * Close any missing semi colons;
18043  *------------------------------------------------------------*;
18044  ;
18045  ;
18046  ;
18047  ;
18048  quit;
18049  *------------------------------------------------------------*;
18050  * Close any unbalanced quotes;
18051  *------------------------------------------------------------*;
18052  /*; *"; *'; */
18053  ;
18054  run;
18055  quit;
18056  /* Reset EM Options */
18057  options formchar="|----|+|---+=|-/\<>*";
18058  options nocenter ls=256 ps=10000;
18059  goptions reset=all device=GIF NODISPLAY;
 
*------------------------------------------------------------*
* Score Log
Date:                December 19, 2019
Time:                14:31:55
*------------------------------------------------------------*
18161  %let EMEXCEPTIONSTRING=;
18162  *------------------------------------------------------------*;
18163  * SCORE: TSESM2;
18164  *------------------------------------------------------------*;
18165  %let EM_ACTION = SCORE;
18166  %let syscc = 0;
18167
18168  %macro EM_TSESM_MAIN;
18169
18170     filename temp catalog 'sashelp.emtsdm.tsesm_macros.source';
18171     %include temp;
18172     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
18173     %include temp;
18174     filename temp;
18175
18176     %if %upcase(&EM_ACTION) = CREATE %then %do;
18177         filename temp catalog 'sashelp.emtsdm.tsesm_create.source';
18178         %include temp;
18179         filename temp;
18180         %EM_TSESM_CREATE;
18181     %end;
18182     %else
18183     %if %upcase(&EM_ACTION) = TRAIN %then %do;
18184          filename temp catalog 'sashelp.emtsdm.tsesm_train.source';
18185             %include temp;
18186             filename temp;
18187          %EM_TSESM_TRAIN;
18188     %end;
18189     %else
18190     %if %upcase(&EM_ACTION) = SCORE %then %do;
18191             filename temp catalog 'sashelp.emtsdm.tsesm_score.source';
18192             %include temp;
18193             filename temp;
18194           %EM_TSESM_SCORE;
18195     %end;
18196     %else
18197     %if %upcase(&EM_ACTION) = REPORT %then %do;
18198             filename temp catalog 'sashelp.emtsdm.tsesm_report.source';
18199             %include temp;
18200             filename temp;
18201            %EM_TSESM_REPORT;
18202     %end;
18203  %mend EM_TSESM_MAIN;
18204  %EM_TSESM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_MACROS.SOURCE.
18205 +/*----------------------------------------------------------------------------------+
18206 + |
18207 + |   Title :  Time Series data Mining Forcating Macros
18208 + |
18209 + |   SUPPORT: Ruiwen Zhang (Ruiwen.Zhang@sas.com)
18210 + |
18211 + |
18212 + +-----------------------------------------------------------------------------------*/
18215 +%macro EM_TSESM_Forecast(indata=,
18216 +                method=,
18217 +                timeinterval=,
18218 +                timeid= ,
18219 +                target= ,
18220 +                tsidvar=,
18221 +                lead=,
18222 +                back=,
18223 +                startsum=,
18224 +                accumulate=,
18225 +                seasonality=,
18226 +                alpha=,
18227 +                extendedvalue=,
18228 +                outest = ,
18229 +                outdata = ,
18230 +                outfor = ,
18231 +                outstat = ,
18232 +                outsum=
18233 +   );
18236 +   %if &tsidvar eq _SEGMENT_ %then %do;
18237 +       proc sort data=&indata out=_tmpdata;
18238 +            by  &tsidvar %EM_CROSSID &timeid ;
18239 +       run;
18240 +       proc timeseries  data =_tmpdata out=_tmpdata;
18241 +            by  &tsidvar %EM_CROSSID;
18242 +            id &timeid interval=&timeinterval accumulate=&accumulate;
18243 +            var &target / ;
18244 +       run;
18245 +       proc esm data =_tmpdata
18246 +   %end;
18247 +   %else %do;
18248 +       proc sort data= &indata out=_tmpdata;
18249 +            by  &tsidvar %EM_CROSSID &timeid ;
18250 +       run;
18251 +       proc esm data = _tmpdata
18252 +   %end;
18253 +            lead=&lead  back=&back startsum=&startsum
18255 +   %if &seasonality ne DEFAULT %then %do;
18256 +            seasonality = &seasonality
18257 +   %end;
18260 +            out=&outdata
18261 +            outest=&outest
18262 +            outfor =&outfor
18263 +            outstat=&outstat
18264 +            outsum= &outsum
18265 +       ;
18266 +        id &timeid  interval = &timeinterval   accumulate=&accumulate ;
18268 +        %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18269 +            %if &target ne %then %do;
18270 +            forecast &target   /  model = none alpha=&alpha;
18271 +            %end;
18272 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18273 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /  model = &method alpha=&alpha use=&extendedvalue;
18274 +            %end;
18275 +        %end;
18276 +        %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
18277 +            %if &target ne %then %do;
18278 +            forecast &target /  model =&method alpha=&alpha;
18279 +            %end;
18280 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18281 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
18282 +            %end;
18283 +        %end;
18284 +        %else %do; /* for KLD, FORECAST Cluster , SIMILARITY */
18285 +            forecast &target /*%EM_INTERVAL_INPUT*/ /  model = &method alpha=&alpha use=predict;
18286 +        %end;
18288 +   %if &tsidvar ne %then %do;
18289 +        by &tsidvar %EM_CROSSID ;
18290 +   %end;
18291 +   run;
18292 +%mend EM_TSESM_Forecast;
18295 +%macro EM_TSESM_CreateOutFor(indata=,
18296 +                            target=,
18297 +                            timeid=,
18298 +                            tsidVar=,
18299 +                            percent=,
18300 +                            outdata=);
18302 +  %let lowerBound = L&percent;
18303 +  %let upperBound = U&percent;
18305 +  data ds_fore(rename=(&target=FORECAST)  drop=_TYPE_)
18306 +       ds_resid(rename=(&target=RESIDUAL) drop=_TYPE_)
18307 +       ds_act(rename=(&target=ACTUAL) drop=_TYPE_)
18308 +       ds_lower(rename=(&target=LBOUND)  drop=_TYPE_)
18309 +       ds_upper(rename=(&target=UBOUND) drop=_TYPE_)
18310 +       ds_std(rename=(&target=STD) drop=_TYPE_);
18311 +     set &indata;
18312 +       if _TYPE_="FORECAST" then output ds_fore;
18313 +       if _TYPE_="RESIDUAL" then output ds_resid;
18314 +       if _TYPE_="ACTUAL" then output ds_act;
18315 +       if _TYPE_="&lowerBound" then output ds_lower;
18316 +       if _TYPE_="&upperBound" then output ds_upper;
18317 +       if _TYPE_="STD" then output ds_std;
18318 +  run;
18320 +  data &outdata;
18321 +       merge ds_fore ds_resid ds_act ds_lower ds_upper ds_std;
18322 +       by &tsidVar &timeid;
18323 +       label  FORECAST = "Forecast";
18324 +       label  ACTUAL = "Actual";
18325 +       label  RESIDUAL = "Residual";
18326 +       label  LBOUND = "Lower Bound";
18327 +       label  UBOUND = "Upper Bound";
18328 +       label   STD = "Standard Deviation";
18329 +  run;
18330 +%mend EM_TSESM_CreateOutFor;
18333 +%macro EM_TSESM_CreateOutExpand(indata=,
18334 +                       target=,
18335 +                       timeid=,
18336 +                       tsidVar=,
18337 +                       percent=,
18338 +                       outlower=,
18339 +                       outupper=,
18340 +                       outdata=);
18342 +  %let lowerBound = L&percent;
18343 +  %let upperBound = U&percent;
18345 +  /*proc print data=&indata(obs=200);
18346 +  run;
18347 +  */
18349 +  data ds_fore(drop=&target)
18350 +       ds_lower(drop=&target)
18351 +       ds_upper(drop=&target)
18352 +       ds_act;
18353 +     set &indata;
18354 +       if _TYPE_="FORECAST" and _LEAD_  > 0 then output ds_fore;
18355 +       if _TYPE_="&lowerBound" and  _LEAD_  > 0 then output ds_lower;
18356 +       if _TYPE_="&upperBound" and  _LEAD_  > 0 then output ds_upper;
18357 +       if _TYPE_="ACTUAL" then output ds_act;
18358 +  run;
18360 +  /*
18361 +  proc print data = ds_fore;
18362 +  proc print data=ds_act;
18363 +  run;
18364 +  */
18365 +  data &outdata;
18366 +       merge ds_act ds_fore;
18367 +       by &tsidVar &timeid;
18368 +  run;
18370 +  data &outlower;
18371 +       merge ds_act ds_lower;
18372 +       by &tsidVar &timeid;
18373 +  run;
18375 +  data &outupper;
18376 +       merge ds_act ds_upper;
18377 +       by &tsidVar &timeid;
18378 +  run;
18379 +  /*
18380 +  proc print data=&outdata(obs=300);
18381 +  proc print data=&outlower(obs=300);
18382 +  proc print data=&outupper(obs=300);
18383 +  run;
18384 +  */
18385 +%mend EM_TSESM_CreateOutExpand;
18389 +%macro EM_TSESM_MakeOutClus(indata=,
18390 +                   target=,
18391 +                   timeid=,
18392 +                   tsidVar=,
18393 +                   percent=,
18394 +                   outlower=,
18395 +                   outupper=,
18396 +                   outdata=);
18399 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
18401 +  data &outdata(rename=(_NAME_ =_NAMEID_));
18402 +       set &indata;
18403 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD;
18404 +  run;
18406 +  %let dsid=%sysfunc(open(&outdata));
18407 +  %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
18408 +  %let dsid=%sysfunc(close(&dsid));
18410 +  %if &vn_name > 0 %then %do;
18411 +      data &outdata(drop=_NAMEID_);
18412 +           merge &EM_USER_TSIDMAP &outdata;
18413 +           by _TSID_;
18414 +      run;
18415 +  %end;
18416 +  %else %do;
18417 +      proc sort data= &outdata; by _NAMEID_;
18418 +      run;
18419 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
18420 +      run;
18421 +      data &outdata(drop=_NAMEID_);
18422 +           merge &EM_USER_TSIDMAP &outdata;
18423 +           by _NAMEID_;
18424 +      run;
18425 +  %end;
18427 +%mend EM_TSESM_MakeOutClus;
18430 +%macro EM_TSESM_CreateOutEst(indata=,
18431 +                    target=,
18432 +                    timeid=,
18433 +                    outdata=);
18435 +%mend EM_TSESM_CreateOutEst;
18438 +%macro EM_TSESM_Best_Forecast(indata=,
18439 +                method=,
18440 +                timeinterval=,
18441 +                timeid= ,
18442 +                target= ,
18443 +                tsidvar=,
18444 +                lead=,
18445 +                back=,
18446 +                startsum=,
18447 +                accumulate=,
18448 +                seasonality=,
18449 +                alpha=,
18450 +                criterion=,
18451 +                extendedvalue=,
18452 +                outest = ,
18453 +                outdata = ,
18454 +                outfor = ,
18455 +                outstat = ,
18456 +                outsum=
18457 +   );
18459 +   %let _indata = &indata;
18461 +   %if &tsidvar eq _SEGMENT_ %then %do;
18462 +       proc sort data=&indata out=_tmpdata;
18463 +            by  &tsidvar %EM_CROSSID &timeid ;
18464 +       run;
18465 +       proc timeseries  data =_tmpdata out=_tmpdata;
18466 +            by  &tsidvar %EM_CROSSID ;
18467 +            id &timeid interval=&timeinterval accumulate=&accumulate;
18468 +            var &target / ;
18469 +       run;
18470 +       %let _indata = _tmpdata;
18471 +   %end;
18473 +   %let n_model = 0;
18475 +   %if &EM_PROPERTY_SIMPLE eq Y %then %do;
18477 +       %let n_model = %eval(&n_model+1);
18479 +       %let _ds_out =_out&n_model;
18480 +       %let _ds_outest =_outest&n_model;
18481 +       %let _ds_outfor =_outfor&n_model;
18482 +       %let _ds_outstat =_outstat&n_model;
18483 +       %let _ds_outsum=_outsum&n_model;
18485 +       %EM_TSESM_ESM(method=SIMPLE,
18486 +        timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18487 +        lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18488 +        out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18489 +        );
18491 +   %end;
18492 +   %if &EM_PROPERTY_DOUBLE eq Y %then %do;
18494 +       %let n_model = %eval(&n_model+1);
18496 +       %let _ds_out =_out&n_model;
18497 +       %let _ds_outest =_outest&n_model;
18498 +       %let _ds_outfor =_outfor&n_model;
18499 +       %let _ds_outstat =_outstat&n_model;
18500 +       %let _ds_outsum=_outsum&n_model;
18502 +       %EM_TSESM_ESM(method=DOUBLE,
18503 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18504 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18505 +             out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18506 +       );
18507 +   %end;
18509 +   %if &EM_PROPERTY_LINEAR eq Y %then %do;
18511 +       %let n_model = %eval(&n_model+1);
18512 +       %let _ds_out =_out&n_model;
18513 +       %let _ds_outest =_outest&n_model;
18514 +       %let _ds_outfor =_outfor&n_model;
18515 +       %let _ds_outstat =_outstat&n_model;
18516 +       %let _ds_outsum=_outsum&n_model;
18518 +       %EM_TSESM_ESM(method=LINEAR,
18519 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18520 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18521 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18522 +        );
18523 +   %end;
18525 +   %if &EM_PROPERTY_DAMPTREND eq Y %then %do;
18527 +       %let n_model = %eval(&n_model+1);
18529 +       %let _ds_out =_out&n_model;
18530 +       %let _ds_outest =_outest&n_model;
18531 +       %let _ds_outfor =_outfor&n_model;
18532 +       %let _ds_outstat =_outstat&n_model;
18533 +       %let _ds_outsum=_outsum&n_model;
18535 +       %EM_TSESM_ESM(method=DAMPTREND,
18536 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18537 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18538 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18539 +            );
18540 +   %end;
18541 +   /*------- Seasonal model ------*/
18543 +   %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do;
18545 +   %if (&EM_PROPERTY_WINTERS eq Y) %then %do;
18547 +       %let n_model = %eval(&n_model+1);
18549 +       %let _ds_out =_out&n_model;
18550 +       %let _ds_outest =_outest&n_model;
18551 +       %let _ds_outfor =_outfor&n_model;
18552 +       %let _ds_outstat =_outstat&n_model;
18553 +       %let _ds_outsum=_outsum&n_model;
18555 +       %EM_TSESM_ESM(method=WINTERS,
18556 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18557 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18558 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18559 +        );
18560 +   %end;
18562 +   %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then %do;
18564 +       %let n_model = %eval(&n_model+1);
18566 +       %let _ds_out =_out&n_model;
18567 +       %let _ds_outest =_outest&n_model;
18568 +       %let _ds_outfor =_outfor&n_model;
18569 +       %let _ds_outstat =_outstat&n_model;
18570 +       %let _ds_outsum=_outsum&n_model;
18572 +       %EM_TSESM_ESM(method=ADDSEASONAL,
18573 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18574 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18575 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18576 +       );
18577 +   %end;
18579 +   %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %do;
18581 +       %let n_model = %eval(&n_model+1);
18583 +       %let _ds_out =_out&n_model;
18584 +       %let _ds_outest =_outest&n_model;
18585 +       %let _ds_outfor =_outfor&n_model;
18586 +       %let _ds_outstat =_outstat&n_model;
18587 +       %let _ds_outsum=_outsum&n_model;
18589 +       %EM_TSESM_ESM(method=MULTSEASONAL,
18590 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18591 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18592 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18593 +       );
18594 +   %end;
18596 +   %if (&EM_PROPERTY_ADDWINTERS eq Y) %then %do;
18598 +       %let n_model = %eval(&n_model+1);
18600 +       %let _ds_out =_out&n_model;
18601 +       %let _ds_outest =_outest&n_model;
18602 +       %let _ds_outfor =_outfor&n_model;
18603 +       %let _ds_outstat =_outstat&n_model;
18604 +       %let _ds_outsum=_outsum&n_model;
18606 +       %EM_TSESM_ESM(method=ADDWINTERS,
18607 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18608 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18609 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18610 +            );
18611 +   %end;
18614 +   %end; /* end of %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do; */
18615 +   /*-------- end of seasonal model  ------------------------------------------------------*/
18617 +   %if &n_model eq 0 %then %do;
18619 +       /*---- %PUT  ERROR:THE NUMBER OF CANDIDATE MODELS IS ZERO;  */
18620 +       %let  EMEXCEPTIONSTRING = exception.server.tsdm.zerocandidatemodel;
18621 +   %end;
18622 +   %else %do;
18623 +         %EM_TSESM_BestModelSel(crit=&criterion,
18624 +                               n_mdl=&n_model,
18625 +                               tsidvar=&tsidvar,
18626 +                               timeid=&timeid,
18627 +                               out=&outdata,
18628 +                               outest=&outest,
18629 +                               outfor =&outfor,
18630 +                               outstat=&outstat,
18631 +                               outsum=&outsum
18632 +                  );
18633 +   %end;
18635 +%mend EM_TSESM_Best_Forecast;
18638 +%macro EM_TSESM_ESM(method= ,
18639 +           timeinterval=,
18640 +           timeid= ,
18641 +           target= ,
18642 +           tsidvar=,
18643 +           lead=,
18644 +           back=,
18645 +           startsum=,
18646 +           accumulate=,
18647 +           seasonality=,
18648 +           alpha=,
18649 +           out= ,
18650 +           outest= ,
18651 +           outfor= ,
18652 +           outstat= ,
18653 +           outsum=
18654 +           );
18656 +       proc sort data= &_indata out=_tmpdata;
18657 +            by  &tsidvar %EM_CROSSID &timeid ;
18658 +       run;
18659 +       proc esm data = _tmpdata  lead=&lead    back=&back  startsum=&startsum
18661 +       %if &seasonality ne DEFAULT %then %do;
18662 +                     seasonality = &seasonality
18663 +       %end;
18664 +            out=&out
18665 +            outest=&outest
18666 +            outfor =&outfor
18667 +            outstat=&outstat
18668 +            outsum= &outsum
18669 +            ;
18670 +       id &timeid  interval = &timeinterval  accumulate=&accumulate  ;
18672 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18673 +            %if &target ne %then %do;
18674 +            forecast &target   /  model = none alpha=&alpha;
18675 +            %end;
18676 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18677 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha use=&extendedvalue;
18678 +            %end;
18679 +       %end;
18680 +       %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
18681 +            %if &target ne %then %do;
18682 +            forecast &target /  model =&method alpha=&alpha;
18683 +            %end;
18684 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18685 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
18686 +            %end;
18687 +       %end;
18688 +       %else %do;   /*----- CLUSTER INPUT , KLD, SIMILARITY INPUT ------*/
18689 +            %if &target ne %then %do;
18690 +            forecast &target   /  model = &method alpha=&alpha;
18691 +            %end;
18692 +            /*
18693 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18694 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha;
18695 +            %end;
18696 +            */
18697 +       %end;
18699 +       %if &tsidvar ne %then %do;
18700 +        by &tsidvar %EM_CROSSID;
18701 +       %end;
18702 +       run;
18704 +%mend EM_TSESM_ESM;
18708 +%macro EM_TSESM_BestModelSel(crit=,
18709 +                    n_mdl=,
18710 +                    tsidvar=_TSID_,
18711 +                    timeid=MNTH_YR,
18712 +                    out=&_outdata,
18713 +                    outest=&_outest,
18714 +                    outfor =&_outfor,
18715 +                    outstat=&_outstat,
18716 +                    outsum=&_outsum
18717 +    );
18719 +   %let statbls=select *, 1 as mdlID from _outstat1;
18720 +   %let estbls=select *,  1 as mdlID from _outest1;
18721 +   %let fortbls=select *, 1 as mdlID from _outfor1;
18722 +   %let outbls=select *,  1 as mdlID from _out1;
18723 +   %let sumtbls=select *, 1 as mdlID from _outsum1;
18724 +   %do i=2 %to &n_mdl;
18725 +      %let statbls=&statbls union all select *, &i as mdlID from _outstat&i;
18726 +        %let estbls=&estbls union all select *, &i as mdlID from _outest&i;
18727 +        %let fortbls=&fortbls union all select *, &i as mdlID from _outfor&i;
18728 +        %let outbls=&outbls union all select *, &i as mdlID from _out&i;
18729 +        %let sumtbls=&sumtbls union all select *, &i as mdlID from _outsum&i;
18730 +   %end;
18732 +   %let dsid=%sysfunc(open(_out1));
18733 +   %let vn_tsid = 0;
18735 +   %if &dsid > 0 %then %do;
18736 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
18737 +         %let dsid = %sysfunc(close(&dsid));
18738 +   %end;
18740 +   %if &vn_tsid <= 0  %then %do;
18741 +       %let tsidvar=_NAME_;
18742 +   %end;
18744 +  /*
18745 +  %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18746 +     %let tsidvar=_NAME_;
18747 +   %end;
18748 +  */
18750 +   proc sql;
18751 +     create table tsstat as &statbls;
18752 +     create table tsest  as &estbls;
18753 +     create table tsfor  as &fortbls;
18754 +     create table tsout  as &outbls;
18755 +     create table tssum  as &sumtbls;
18756 +   quit;
18758 +    proc sort data=tsstat out=bestmdl;
18759 +        by &tsidvar &crit mdlID;
18760 +    run;
18762 +    * when multiple BEST model found;
18763 +    * use the one with smallest model ID;
18764 +    data bestmdl;
18765 +        set bestmdl;
18766 +        by &tsIDvar;
18767 +        if first.&tsIDVar;
18768 +    run;
18770 +   proc sql;
18771 +      create table bestID as
18772 +        select distinct(tsest.&tsidvar), _model_, &crit, bestmdl.mdlID
18773 +        from bestmdl,tsest
18774 +        where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar;
18776 +      create table &outfor
18777 +        as select tsfor.*, _model_, &crit from tsfor, bestID
18778 +        where tsfor.&tsidvar=bestID.&tsidvar and tsfor.mdlID=bestID.mdlID order by &tsidvar, &timeid;
18780 +        create table &outstat
18781 +        as select tsstat.*, _model_ from tsstat, bestID
18782 +      where tsstat.&tsidvar=bestID.&tsidvar and tsstat.mdlID=bestID.mdlID order by &tsidvar;
18784 +        create table &outest
18785 +        as select tsest.*, &crit from bestmdl, tsest
18786 +      where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar order by &tsidvar;
18788 +      create table &outsum
18789 +        as select tssum.*, _model_, &crit from tssum, bestID
18790 +      where tssum.&tsidvar=bestID.&tsidvar and tssum.mdlID=bestID.mdlID order by &tsidvar;
18792 +      /*
18793 +      %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18794 +        create table &out
18795 +          as select tsout.*, _model_, &crit from tsout, bestID
18796 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
18797 +      %end;
18798 +      */
18800 +      %if &tsidvar eq _TSID_ %then %do;
18802 +         create table &out
18803 +          as select tsout.*, _model_, &crit from tsout, bestID
18804 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
18806 +      %end;
18807 + run;
18808 +quit;
18810 + /*%if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
18812 + %if &tsidvar = _NAME_ %then %do;
18813 +      data
18814 +            %let i=1;
18815 +            %do i=1 %to &n_mdl;
18816 +               %let _tmpdsname = _tmpds&i;
18817 +                    &_tmpdsname
18818 +            %end;
18819 +        ;
18820 +         set work.Bestmdl;
18821 +            %let i=1;
18822 +            %do i=1 %to &n_mdl;
18823 +               %let _tmpdsname = _tmpds&i;
18824 +                  if mdlID = &i then output &_tmpdsname;
18825 +            %end;
18826 +      run;
18828 +      data &out;
18829 +           set _out1;
18830 +           keep &timeid %EM_TARGET;
18831 +      run;
18832 +      %let i=1;
18833 +      %do i=1 %to &n_mdl;
18834 +          %let _tmpdsname = _tmpds&i;
18835 +          %let _outdsname = _out&i;
18837 +          data &out;
18838 +               set &out;
18839 +               set &_outdsname(keep=
18840 +               %let dsid=%sysfunc(open(&_tmpdsname));
18841 +               %if &dsid > 0 %then %do;
18842 +                  %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
18843 +                  %do %while(^%sysfunc(fetch(&dsid)));
18844 +                     %let _name  = %sysfunc(getvarc(&dsid, &vn_name));
18845 +                          &_name
18846 +                  %end;
18847 +                  %let dsid = %sysfunc(close(&dsid));
18848 +               %end;
18849 +               );
18850 +           run;
18851 +       %end;
18853 +%end;
18855 +data &out;
18856 +     set  &out;
18857 +      drop mdlID _MODEL_ &crit;
18858 +data &outest;
18859 +      set  &outest;
18860 +      drop mdlID &crit;
18861 +data &outfor;
18862 +     set &outfor;
18863 +     drop mdlID &crit;
18864 +data &outstat;
18865 +     set &outstat;
18866 +     drop mdlID;
18867 +data &outsum;
18868 +     set &outsum;
18869 +     drop mdlID &crit;
18870 +run;
18872 +%mend EM_TSESM_BestModelSel;
18876 +%macro EM_TSESM_MakeOutlierIndex(indata=,
18877 +                        target=,
18878 +                        timeid=,
18879 +                        outoutlier=,
18880 +                        outlierds=,
18881 +                        outdata=);
18882 +%let label_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlier, noquote));
18883 +%let str_Actual_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actualoutlier, noquote));
18884 +%let str_Actual = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actual, noquote));
18885 +data &outdata;
18886 +     set &indata;
18887 +     length OutlierIndex 8.;
18888 +     length Outlier  $40;
18889 +     label  OutlierIndex = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlierindex, noquote))";
18890 +     label  Outlier = "&label_Outlier";
18891 +   /*  if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&label_Outlier";end;
18892 +       else  do; OutlierIndex=0; outlier =" "; end; */
18893 +     if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&str_Actual_Outlier";end;
18894 +       else  do; OutlierIndex=0; outlier ="&str_Actual"; end;
18895 +run;
18897 +data  &outoutlier;
18898 +      set  &outdata;
18899 +      keep &timeid _TSID_ _SEGMENT_ _NAME_ _NAMEID_ OUTLIERINDEX OUTLIER PREDICT;
18900 +      if ACTUAL = . then delete;
18901 +run;
18903 +data &outlierds;
18904 +     set &outoutlier;
18905 +     if OUTLIERINDEX = 0 then delete;
18906 +     Drop OUTLIERINDEX;
18907 +run;
18909 +%mend  EM_TSESM_MakeOutlierIndex;
18912 +%macro EM_TSESM_MakeSmoothedOutds(indata=,
18913 +                         inoutlierds=,
18914 +                         target=,
18915 +                         timeid=,
18916 +                         tsidvar=_TSID_,
18917 +                         replace=,
18918 +                         outdata=);
18921 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
18924 +%let dsid=%sysfunc(open(&indata));
18925 +%let vn_tsid = 0;
18926 +%if &dsid > 0 %then %do;
18927 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
18928 +         %let dsid = %sysfunc(close(&dsid));
18929 +%end;
18931 +%if &vn_tsid <= 0  %then %do;
18932 +    %let tsidvar=_NAME_;
18933 +%end;
18935 +%if &tsidvar = _TSID_ %then %do;
18936 +/* %if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
18937 + /*    data &outdata;
18938 +          merge &indata &inoutlierds;
18939 +          by _TSID_ &timeid;
18940 +          if OutlierIndex > 0 then
18941 +          %if &replace eq PREDICT %then %do;
18942 +             &target = PREDICT;
18943 +          %end;
18944 +          %else %do;
18945 +             &target = .;
18946 +          %end;
18947 +           Drop Predict _NAME_ OutlierIndex;
18948 +     run;     */
18949 +  %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
18950 +     %if &dsid > 0 %then %do;
18951 +         %let vn_nameid =%sysfunc(varnum(&dsid, _VARNAME_));
18952 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
18953 +         %let i = 1;
18954 +              %do %while(^%sysfunc(fetch(&dsid)));
18955 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
18956 +                  %let _vartsid= %sysfunc(getvarn(&dsid, &vn_tsid));
18957 +                  %if &i eq 1 %then %do;
18958 +                      data _tmpoutlier;
18959 +                           set &inoutlierds;
18960 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid then output;
18961 +                      run;
18962 +                      data &outdata;
18963 +                           merge &indata _tmpoutlier;
18964 +                           by _TSID_ &timeid ;
18965 +                           if OutlierIndex  > 0 then
18966 +                              %if &replace eq PREDICT %then %do;
18967 +                                &_varname = PREDICT;
18968 +                              %end;
18969 +                              %else %do;
18970 +                                &_varname = .;
18971 +                              %end;
18972 +                            Drop Predict _NAME_  OutlierIndex Outlier;
18973 +                      run;
18974 +                   %end;
18975 +                   %else %do;
18976 +                      data _tmpoutlier;
18977 +                           set &inoutlierds;
18978 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid  then output;
18979 +                      run;
18980 +                      data &outdata;
18981 +                           merge &outdata _tmpoutlier;
18982 +                           by _TSID_ &timeid ;
18983 +                           if OutlierIndex  > 0 then
18984 +                              %if &replace eq PREDICT %then %do;
18985 +                                &_varname = PREDICT;
18986 +                              %end;
18987 +                              %else %do;
18988 +                                &_varname = .;
18989 +                              %end;
18990 +                           Drop Predict _NAME_  OutlierIndex Outlier;
18991 +                      run;
18992 +                   %end;
18993 +                   %let i = %eval(&i+1);
18995 +              %end;
18996 +           %let dsid = %sysfunc(close(&dsid));
18997 +      %end;
18998 +%end;
18999 +%else %do;  /*  %if &tsidvar = _NAME_ %then %do; */
19001 +     %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
19002 +     %if &dsid > 0 %then %do;
19003 +         %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
19004 +         %let i = 1;
19005 +              %do %while(^%sysfunc(fetch(&dsid)));
19006 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
19007 +                  %if &i eq 1 %then %do;
19008 +                      data _tmpoutlier;
19009 +                           set &inoutlierds;
19010 +                           if _NAME_ ="&_varname"  then output;
19011 +                      run;
19012 +                      data &outdata;
19013 +                           merge &indata _tmpoutlier;
19014 +                           by &timeid;
19015 +                           if OutlierIndex  > 0 then
19016 +                              %if &replace eq PREDICT %then %do;
19017 +                                &_varname = PREDICT;
19018 +                              %end;
19019 +                              %else %do;
19020 +                                &_varname = .;
19021 +                              %end;
19022 +                            Drop Predict _NAME_ OutlierIndex Outlier;
19023 +                      run;
19024 +                   %end;
19025 +                   %else %do;
19026 +                      data _tmpoutlier;
19027 +                           set &inoutlierds;
19028 +                           if _NAME_ ="&_varname"  then output;
19029 +                      run;
19030 +                      data &outdata;
19031 +                           merge &outdata _tmpoutlier;
19032 +                           by &timeid;
19033 +                           if OutlierIndex  > 0 then
19034 +                              %if &replace eq PREDICT %then %do;
19035 +                                &_varname = PREDICT;
19036 +                              %end;
19037 +                              %else %do;
19038 +                                &_varname = .;
19039 +                              %end;
19040 +                           Drop Predict _NAME_ OutlierIndex Outlier;
19041 +                      run;
19042 +                   %end;
19043 +                   %let i = %eval(&i+1);
19045 +              %end;
19046 +           %let dsid = %sysfunc(close(&dsid));
19047 +      %end;
19048 +      %else %do;
19049 +            /* this block is added 09022011*/
19050 +            /* works for wide table in which each time series has a column */
19052 +            proc transpose data=&indata out=_tmpdata1;
19053 +                by &timeID;
19054 +            run;
19056 +            proc sql;
19057 +                create table _tmpdata2 as
19058 +                    select a.*, b.outlierindex, b.outlier, b.predict
19059 +                        from _tmpdata1 as a left join &inoutlierds as b
19060 +                            on a.&timeID eq b.&timeID and a._name_ eq b._name_
19061 +                        order by a.&timeID, a._name_
19062 +                    ;
19063 +            quit;
19065 +            data _tmpdata2;
19066 +                set _tmpdata2;
19067 +                if outlierindex eq 1 then
19068 +                    if &replace eq PREDICT then col1=predict; else col1=.;
19069 +            run;
19071 +            proc transpose data=_tmpdata2 out=_tmpdata3(drop=_name_ _label_);
19072 +                by &timeID;
19073 +                ID _name_;
19074 +                var col1;
19075 +            proc sort data=&inoutlierds out=_tmpoutlier;
19076 +                by &timeID _name_;
19077 +            proc transpose data=_tmpoutlier out=_tmpdata4(drop=_name_ _label_) prefix=Outlier_;
19078 +                by &timeID;
19079 +                ID _name_;
19080 +                var outlier;
19081 +            run;
19083 +            data &outdata;
19084 +                merge _tmpdata3 _tmpdata4;
19085 +                by &timeID;
19086 +            run;
19087 +      %end;
19088 +%end;
19089 +%mend EM_TSESM_MakeSmoothedOutds;
19091 +%Macro EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
19092 +                  insumdata=&EM_USER_OUTSUM,
19093 +                target=&_targetVar,
19094 +                timeid=&_timeidVar,
19095 +                futurepoint=1,
19096 +                outKLD=&EM_USER_OUTKLD
19097 +                );
19099 +%if &futurepoint > 0 %then %do;
19101 +proc sort data=&indata out=_tmptimeid;
19102 +     by &timeid;
19103 +run;
19105 +data _tmptimeid(keep=&timeid);
19106 +      set _tmptimeid; by &timeid;
19107 +      if first.&timeid then output;
19108 +run;
19110 +%let _targetTime =;
19111 +%let dsid=%sysfunc(open(work._tmptimeid));
19112 +%if &dsid > 0 %then %do;
19113 +    %let vn_timeid =%sysfunc(varnum(&dsid, &timeid));
19114 +    %let i = 1;
19115 +    %do %while(^%sysfunc(fetch(&dsid)));
19116 +       %if &i eq &futurepoint %then %do;
19117 +       %let _targetTime  = %sysfunc(getvarn(&dsid, &vn_timeid));
19118 +       %end;
19119 +       %let i = %eval(&i+1);
19120 +    %end;
19121 +    %let dsid = %sysfunc(close(&dsid));
19122 +%end;
19124 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
19125 +   set &indata;
19126 +   if &timeid eq &_targetTime then output;
19127 +run;
19129 +%end;  /* end of %if &futurepoint > 0 %then %do; */
19130 +%else %do;
19133 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
19134 +   set &insumdata;
19135 +run;
19138 +%end;
19140 +%EM_TSESM_KLD(indata=work._tmpKLD, outdata=&outKLD);
19142 +/* Merge TSIDMAP  */
19144 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19145 +data &outKLD(rename=(_NAME_ =_NAMEID_));
19146 +       set &outKLD;
19147 +run;
19149 +%let dsid=%sysfunc(open(&outKLD));
19150 +%let vn_name =%sysfunc(varnum(&dsid, _TSID_));
19151 +%let dsid=%sysfunc(close(&dsid));
19153 +%if &vn_name > 0 %then %do;
19154 +      data &outKLD(drop=_NAMEID_);
19155 +           merge &EM_USER_TSIDMAP &outKLD;
19156 +           by _TSID_;
19157 +      run;
19158 +%end;
19159 +%else %do;
19160 +      proc sort data= &outKLD; by _NAMEID_;
19161 +      run;
19162 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
19163 +      run;
19164 +      data &outKLD(drop=_NAMEID_);
19165 +           merge &EM_USER_TSIDMAP &outKLD;
19166 +           by _NAMEID_;
19167 +      run;
19168 +%end;
19170 +/* delete _tmptimeid  _tmpKLD */
19171 +%Mend  EM_TSESM_MakeOutKLD;
19174 +%Macro EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
19175 +                 target=&_targetVar,
19176 +                 timeid=&_timeidVar,
19177 +                 outdata=&EM_USER_OUTPRED
19178 +                 );
19180 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19181 +%let _EndTime = ;
19182 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19183 +%if &dsid > 0 %then %do;
19184 +    %let vn_end =%sysfunc(varnum(&dsid, END));
19185 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
19186 +    %do %while(^%sysfunc(fetch(&dsid)));
19187 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19188 +       /*--------------------------------------------------------
19189 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
19190 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
19191 +        ---------------------------------------------------------*/
19192 +    %end;
19193 +    %let dsid = %sysfunc(close(&dsid));
19194 +%end;
19196 +data &outdata(keep= _TSID_ _NAME_  &timeid PREDICT LOWER UPPER STD);
19197 +     set &indata;
19198 +     if &timeid > &_EndTime then output;
19199 +run;
19200 +%Mend  EM_TSESM_MakeOutPred;
19203 +%macro EM_TSESM_KLD(indata=work._tmp, outdata=_out);
19205 +%let std_x = ;
19206 +%let mu_y = ;
19208 +%let dsid=%sysfunc(open(&indata));
19209 +%if &dsid > 0 %then %do;
19210 +    %let vn_pred =%sysfunc(varnum(&dsid, PREDICT));
19211 +    %let vn_std  = %sysfunc(varnum(&dsid, STD));
19212 +    %let i=1;
19213 +    %do %while(^%sysfunc(fetch(&dsid)));
19214 +        %let _pred  = %sysfunc(getvarn(&dsid, &vn_pred));
19215 +        %let _std  = %sysfunc(getvarn(&dsid, &vn_std));
19216 +        %let _tsid = _TSID&i.;
19217 +        /* create new data set */
19218 +            %if &i = 1 %then %do;
19219 +            data _tmpindata;
19220 +                set &indata;
19221 +                  mu_x = &_pred;
19222 +                  std_x = &_std;
19223 +                  rename predict = mu_y;
19224 +                  rename std = std_y;
19225 +            run;
19226 +        data _tmpout;
19227 +                 set _tmpindata;
19228 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
19229 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
19230 +             &_tsid= (KLD1+KLD2)/2;
19231 +             if &_tsid < 0 then &_tsid = 0;
19232 +                   drop KLD1 KLD2;
19233 +         run;
19234 +             %end;
19235 +         %else %do;
19236 +         data _tmpindata;
19237 +                  set _tmpout;
19238 +                  mu_x = &_pred;
19239 +                  std_x = &_std;
19241 +             run;
19242 +         data _tmpout;
19243 +                 set _tmpindata;
19244 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
19245 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
19246 +             &_tsid= (KLD1+KLD2)/2;
19247 +             if &_tsid < 0 then &_tsid = 0;
19248 +                   drop KLD1 KLD2;
19249 +         run;
19251 +         %end;
19252 +             %let i = %eval(&i+1);
19254 +    %end;
19255 +    %let dsid = %sysfunc(close(&dsid));
19256 +    data &outdata;
19257 +         set _tmpout;
19258 +         drop mu_x mu_y std_x std_y;
19259 +    run;
19260 +%end;
19261 +%mend EM_TSESM_KLD;
19264 +%macro EM_TSESM_MakeOutClusInput(indata=,
19265 +                   target=,
19266 +                   timeid=,
19267 +                   tsidVar=,
19268 +                   percent=,
19269 +                   outlower=,
19270 +                   outupper=,
19271 +                   esmmethod=,
19272 +                   criterion=,
19273 +                   outdata=);
19275 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19277 +  data &outdata(rename=(_NAME_ =_NAMEID_));
19278 +       set &indata;
19279 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
19280 +  %if &esmmethod eq BEST %then %do;
19281 +      mdlID _MODEL_ &criterion
19283 +  %end;
19284 +  ;
19285 +  run;
19287 +  %let dsid=%sysfunc(open(&outdata));
19288 +       %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
19289 +  %let dsid=%sysfunc(close(&dsid));
19291 +  %if &vn_name > 0 %then %do;
19292 +      proc sort data= &outdata; by _TSID_;
19293 +      run;
19294 +      proc sort data = &EM_USER_TSIDMAP ;by _TSID_;
19295 +      run;
19297 +      data &outdata(drop=_NAMEID_);
19298 +           merge &EM_USER_TSIDMAP &outdata;
19299 +           by _TSID_;
19300 +      run;
19301 +  %end;
19302 +  %else %do;
19303 +      proc sort data= &outdata; by _NAMEID_;
19304 +      run;
19305 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
19306 +      run;
19307 +      data &outdata(drop=_NAMEID_);
19308 +           merge &EM_USER_TSIDMAP &outdata;
19309 +           by _NAMEID_;
19310 +      run;
19311 +  %end;
19313 +%mend EM_TSESM_MakeOutClusInput;
19315 +%macro EM_TSESM_MakeOutSimInput(indata=,
19316 +                   inoutfor=,
19317 +                   target=,
19318 +                   timeid=,
19319 +                   tsidVar=,
19320 +                   esmmethod=,
19321 +                   criterion=,
19322 +                   outdata=);
19325 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19326 +  %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19328 +   %let _EndTime = ;
19329 +   %let dsid=%sysfunc(open(&EM_USER_TSMETA));
19330 +   %if &dsid > 0 %then %do;
19331 +   %let vn_end =%sysfunc(varnum(&dsid, END));
19332 +   %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
19333 +   %do %while(^%sysfunc(fetch(&dsid)));
19334 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19335 +   %end;
19336 +   %let dsid = %sysfunc(close(&dsid));
19337 +   %end;
19339 +   %em_varMacro(name=tsesm_crossid, metadata= &EM_DATA_VARIABLESET, key=NAME,
19340 +       where=%nrbquote(ROLE='CROSSID' and USE ne 'N') , nummacro=tsesm_crossidNum);
19342 +   data _out1;
19343 +       set &indata;
19344 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
19345 +           %tsesm_crossid
19346 +   %if &esmmethod eq BEST %then %do;
19347 +      mdlID _MODEL_ &criterion
19348 +   %end;
19349 +   ;
19350 +   run;
19352 +    %let dsid=%sysfunc(open(work._out1));
19353 +    %if &dsid > 0 %then %do;
19354 +      %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
19355 +      %let dsid = %sysfunc(close(&dsid));
19356 +    %end;
19358 +    /*
19359 +    proc print data=_out1(obs=10);
19360 +    run;
19361 +    */
19362 +    %let _existtsid = Y;
19363 +    %if (&vn_tsid = 0)  %then %do;
19364 +    %let _existtsid = N;
19365 +    %goto NO_TSID_SIMINPUT;
19366 +    %end;
19368 +    data _out1;
19369 +        set _out1;
19370 +        where _name_ = "&target";
19371 +    run;
19372 +    %let target2 = &target._;
19373 +    proc transpose data=_out1 out=_out2 prefix=&target2;
19374 +            id _TSID_  ;
19375 +    run;
19376 +    /*
19377 +    proc print data=_out2(obs=11);
19378 +    run;
19379 +    */
19380 +    data _out2;
19381 +       length _index 8.;
19382 +       set _out2;
19383 +       _index=_N_;
19384 +       drop _NAME_ _LABEL_;
19385 +    run;
19388 +   data _out3;
19389 +       length _index 8.;
19390 +        set &inoutfor(where=(_TSID_=1 and &timeid > &_EndTime));
19391 +         _index =_N_;
19392 +        keep &timeid _index;
19394 +   run;
19395 +   /*
19396 +   proc print data=_out2(obs=12);
19397 +   proc print data =_out3(obs=13);
19398 +   run;
19399 +   */
19400 +   data &outdata(drop=_index);
19401 +        merge _out3 _out2;by _index;
19402 +        run;
19405 +  proc transpose data=&outdata out=_tout;
19406 +     id &timeid;
19407 +   run;
19408 +   data _tout;
19409 +        length _TSID_ 8.;
19410 +        set _tout;
19411 +        rename _NAME_= _NAMEID_;
19412 +        _TSID_ = _N_;
19413 +        label _NAME_ = "NAMEID";
19414 +        keep _NAME_ _TSID_;
19416 +   run;
19418 +   data &EM_USER_TSIDMAP;
19419 +        merge  _tout  &EM_USER_TSIDMAP; by _TSID_;
19420 +   run;
19421 +   /*
19422 +   proc print data=_tout(obs=14);
19423 +   run;
19424 +   */
19425 +   proc datasets lib=work nolist;
19426 +      delete  _out1 _tmpout1 _out2 _out3 _tout;
19427 +   run;
19430 +   %NO_TSID_SIMINPUT:
19431 +   %if  &_existtsid eq N %then %do;
19432 +   data &outdata;
19433 +        set &inoutfor(where=(&timeid > &_EndTime));
19434 +   run;
19435 +   %end;
19438 +%mend EM_TSESM_MakeOutSimInput;
19441 +%macro EM_TS_CONVERT_LONG_TO_WIDE(indata=, outdata=, wherevar=, nwherevalue=, targetvar=, timeid=);
19442 +%do i=1 %to &nwherevalue;
19443 +     %if &i = 1 %then %do;
19444 +        data &outdata(drop = &wherevar);
19445 +             set &indata;
19446 +               if &wherevar= &i;
19447 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
19448 +               %else %let newname = &wherevar_&i;
19449 +                rename  &targetvar= &newname;
19450 +                   label &targetvar ="&targetvar._&i";
19451 +           run;
19452 +       %end;
19453 +       %else %do;
19454 +        data _tmp_out(drop = &wherevar);
19455 +             set &indata;
19456 +               if &wherevar= &i;
19457 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
19458 +               %else %let newname = &wherevar_&i;
19459 +                rename  &targetvar= &newname;
19460 +                   label &targetvar ="&targetvar._&i";
19461 +           run;
19462 +             data &outdata;
19463 +                  merge &outdata  _tmp_out; by &timeid;
19464 +         run;
19465 +       %end;
19466 +%end;
19468 +%EM_TS_DELETE_DATA(lib=work, data=_tmp_out);
19470 +%mend EM_TS_CONVERT_LONG_TO_WIDE;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
19472 +/*
19473 +       MACRO: TS Utility macros
19475 +       PURPOSE: TS Utility macros
19476 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
19478 +       HISTORY:
19479 +       NOTE:
19481 +*/
19483 +/*
19484 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
19485 +                          timeid=, timeformat=, timeinformat=);
19486 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
19488 +    %do;
19489 +    %let m_data      = &data;
19490 +    %let m_decdata   = &decdata;
19491 +    %let m_decmeta   = &decmeta;
19492 +    %let m_cmeta     = &cmeta;
19493 +    %let m_outfile   = &outfile;
19494 +    %let m_crossid   = &crossid;
19495 +    %let m_timeid    = &timeid;
19496 +    %let m_timeformat    = &timeformat;
19497 +    %let m_timeinformat    = &timeinformat;
19498 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
19499 +  %end;
19500 +%mend EM_TS_CreateTsMetaDs;
19501 +*/
19502 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
19503 +proc sql;
19504 +      create table _tmp_inds
19505 +      as select distinct &timeid from  &indata;
19506 +quit;
19507 +run;
19508 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
19509 +  id &timeid
19510 +%if &timeinterval ne %then %do;
19511 +    %if &timeformattype eq DATE %then %do;
19512 +        interval=&timeinterval
19513 +    %end;
19514 +    %else %if &timeformattype eq DATETIME  %then %do;
19515 +        %let dttimeinterval= DT&timeinterval;
19516 +         interval=&dttimeinterval
19517 +    %end;
19518 +%end;
19519 +;
19520 +run;
19522 +data &outds;
19523 +     set _tmp_tsmeta;
19524 +     format START &timeformat;
19525 +     format END &timeformat;
19526 +     length APPLY_START_END $8;
19527 +     APPLY_START_END ="No";
19528 +     FORMAT = "&timeformat";
19529 +     ROLE ="TIMEID";
19530 +     rename TIMEID = NAME;
19531 +     rename SEASONALITY= LengthOfCycle;
19532 +     rename INTERVAL = TIMEINTERVAL ;
19533 +     rename FORMAT = TIMEFORMAT;
19534 +     output;
19535 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
19536 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
19537 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
19538 +run;
19540 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
19541 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
19543 +%mend EM_TS_CreateTSMetaData;
19547 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
19549 +/* if updated = Y it will pass the TSMETA created by just the previous node */
19551 +%let _tsmetads = ;
19553 +%if &updated = Y %then %do;
19554 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
19555 +%if %sysfunc(exist(&_tsmetads)) %then %do;
19556 +%goto endline;
19557 +%end;
19558 +%end;
19560 +%if &eminfodata eq %then %do;
19561 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19562 +    data &EM_DATA_EMINFO;
19563 +         set &EM_IMPORT_DATA_EMINFO;
19564 +    run;
19565 +%end;
19566 +%else %do;
19567 +    %let dsid=%sysfunc(open(&eminfodata));
19568 +    data &EM_DATA_EMINFO;
19569 +         set &eminfodata;
19570 +    run;
19571 +%end;
19572 +%if &dsid > 0 %then %do;
19573 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
19574 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
19575 +    %do %while(^ %sysfunc(fetch(&dsid)));
19576 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19577 +         %if &_key eq TSMETA %then %do;
19578 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
19579 +         %end;
19580 +    %end;
19581 +    %let dsid = %sysfunc(close(&dsid));
19582 +%end; /* the end of %if &dsid > 0 %then %do; */
19584 +%endline:
19586 +%if &_tsmetads ne %then %do;
19587 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
19588 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19589 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
19590 +         data &EM_USER_TSMETA;
19591 +                   set &_tsmetads;
19592 +         run;
19593 +    %end;
19594 +%end;
19596 +*proc print data=&EM_DATA_EMINFO;
19597 +*proc print data=&EM_IMPORT_DATA_EMINFO;
19598 +*run;
19599 +%MEND EM_TS_GETTSMETA;
19602 +/*
19603 +%macro EM_GETTSMETAVARS(TimeInterval=);
19604 +%global &TimeInterval;
19605 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19606 +%if &dsid > 0 %then %do;
19607 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19608 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
19609 +%do %while(^ %sysfunc(fetch(&dsid)));
19610 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19611 +     %if &_role eq TIMEID %then %do;
19612 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19613 +     %end;
19614 +%end;
19615 +%let dsid = %sysfunc(close(&dsid));
19616 +%end;
19617 +%MEND EM_GETTSMETAVARS;
19618 +*/
19619 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
19620 +%global &TimeInterval;
19621 +%global &TimeId;
19622 +%global &EndTime;
19623 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19624 +proc print data=&EM_USER_TSMETA;
19625 +run;
19626 +%if &dsid > 0 %then %do;
19627 +%if &TimeInterval ne %then %do;
19628 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19629 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19630 +    %do %while(^ %sysfunc(fetch(&dsid)));
19631 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19632 +        %if &_role eq TIMEID %then %do;
19633 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19634 +        %end;
19635 +     %end;
19636 +%end;
19637 +%if &TimeId ne %then %do;
19638 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
19639 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19640 +    %do %while(^ %sysfunc(fetch(&dsid)));
19641 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19642 +        %if &_role eq TIMEID %then %do;
19643 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
19644 +        %end;
19645 +    %end;
19646 +%end;
19648 +%if &EndTime ne %then %do;
19649 +    %let vn_end =%sysfunc(varnum(&dsid, END));
19650 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19651 +    %do %while(^ %sysfunc(fetch(&dsid)));
19652 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19653 +        %if &_role eq TIMEID %then %do;
19654 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19655 +        %end;
19656 +     %end;
19657 +%end;
19658 +%let dsid = %sysfunc(close(&dsid));
19659 +%end;
19660 +%MEND EM_TS_GETTSMETAVARS;
19664 +/*------------------------------------------------------------------
19666 +      Macro EM_GETTSIDMAP
19668 +------------------------------------------------------------------+*/
19671 +%macro EM_TS_GETTSIDMAP(updated=);
19673 +%let _tsidmap = ;
19675 +%if &updated = Y %then %do;
19676 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
19677 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19678 +%goto endline;
19679 +%end;
19680 +%end;
19682 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19683 +%if &dsid > 0 %then %do;
19684 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
19685 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
19686 +%do %while(^ %sysfunc(fetch(&dsid)));
19687 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19688 +     %if &_key eq TSIDMAP %then %do;
19689 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
19690 +     %end;
19691 +%end;
19693 +%let dsid = %sysfunc(close(&dsid));
19694 +%end;
19696 +%endline:
19698 +%if &_tsidmap ne %then %do;
19700 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
19701 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19703 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19704 +         data &EM_USER_TSIDMAP;
19705 +               set &_tsidmap;
19706 +         run;
19707 +    %end;
19708 +%end;
19709 +%MEND EM_TS_GETTSIDMAP;
19711 +/*------------------------------------------------------------------*/
19716 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
19717 +%global &value;
19720 +%let dsid = %sysfunc(open(&data));
19721 +%if &dsid > 0 %then %do;
19722 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
19723 +    %if &vn_var < 1 %then %do;
19724 +        %let &value = 0;
19725 +        %let dsid = %sysfunc(close(&dsid));
19726 +        %goto endline;
19727 +    %end;
19728 +%let dsid = %sysfunc(close(&dsid));
19729 +%end;
19731 +%let _tmp=_tmpDS;
19732 +proc means data=&data &stat;
19733 +     var &var;
19734 +     output out=&_tmp;
19735 +run;
19737 +%let dsid = %sysfunc(open(&_tmp));
19738 +%if &dsid > 0 %then %do;
19739 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
19740 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
19741 +     %do %while(^%sysfunc(fetch(&dsid)));
19742 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
19743 +         %if &_stat eq &stat %then %do;
19744 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
19745 +          %end;
19746 +      %end;
19747 +%let dsid = %sysfunc(close(&dsid));
19748 +%end;
19749 +proc datasets lib=work nolist;
19750 + delete &_tmp;
19751 +run;
19752 +%endline:
19753 +%MEND EM_TS_GET_STAT;
19756 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
19757 +%global &format;
19758 +%global &informat;
19759 +%let dsid = %sysfunc(open(&data));
19760 +%if &dsid > 0 %then %do;
19761 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19762 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
19763 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
19764 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
19765 +%end;
19766 +%let dsid = %sysfunc(close(&dsid));
19767 +%end;
19768 +%MEND EM_TS_GET_VAR_FORMAT;
19770 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
19771 +      %if &lib eq %then %let lib=work;
19772 +       proc datasets lib=&lib nolist;
19773 +              delete &dsname;
19774 +       run;
19775 +%Mend  EM_TS_DELETE_DATA;
19778 +%macro EM_TS_GetNObs(inds=, nobs=);
19779 +    %global &nobs;
19780 +    %let &nobs=0;
19781 +    data _null_;
19782 +        set &inds end=eof;
19783 +        if eof then call symput("&nobs", _N_);
19784 +    run;
19785 +    quit;
19787 +    /*
19788 +    %let dsid=%sysfunc(open(&outdata));
19789 +    %if dsid > 0 %then %do;
19790 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
19791 +        %let dsid = %sysfunc(close(&dsid));
19792 +     %end;
19793 +    */
19794 +%mend  EM_TS_GetNObs;
19797 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
19798 +%global &time1;
19799 +%global &time2;
19800 +%if &default = Y %then %do;
19801 +   data _null_;
19802 +        set &data end=eof;
19803 +        if _N_ = 1 then  call symput("&time1", DATE);
19804 +        if eof then call symput("&time2", DATE);
19805 +    run;%end;
19806 +%else %do;
19807 +    %let dsid = %sysfunc(open(&data));
19808 +    %if &dsid > 0 %then %do;
19809 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
19810 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
19811 +        %do %while(^%sysfunc(fetch(&dsid)));
19812 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
19813 +             %if &_index eq 1 %then %do;
19814 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
19815 +             %end;
19816 +             %if &_index eq 2 %then %do;
19817 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
19818 +             %end;
19819 +        %end;
19820 +    %let dsid = %sysfunc(close(&dsid));
19821 +    %end;
19822 +%end;
19824 +%MEND EM_TS_GET_TIME_VALUES;
19826 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
19827 +%global &exist;
19828 + %let &exist = N;
19829 +%let dsid = %sysfunc(open(&data));
19830 +%if &dsid > 0 %then %do;
19831 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19832 +%if &vn_var > 0 %then %do;
19833 +    %let &exist = Y;
19834 +%end;
19835 +%let dsid = %sysfunc(close(&dsid));
19836 +%end;
19837 +%MEND EM_TS_GET_VAR_EXIST;
19840 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
19841 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
19842 +      set &intreedata;
19843 +        LENGTH NodeType $32;
19844 +      if _PARENT_ eq " " then delete;
19845 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
19846 +        else NodeType = "CLUSTER";
19847 +        LinkID = _N_;
19848 +run;
19849 +%Mend EM_TS_MakeConstellPlotData;
19854 +%macro EM_TS_CreateIDMap(
19855 +/*-------------------------------------------------------------------------*/
19856 +/*---   Written by Xiangxiang Meng                                         */
19857 +/*-------------------------------------------------------------------------*/
19858 +inDS          =,      /* imported data set in TS data mining               */
19859 +outIDMap      =,      /* output data set of TS ID map                      */
19860 +outDS         =,      /* output data set of TS and TS ID merged            */
19861 +variableSet   =,      /* EM variable set                                   */
19862 +TSIDbyCrossID =Y,
19863 +inEM          =Y
19864 +/*-------------------------------------------------------------------------*/
19865 +);
19867 +%global EM_TS_ERR;
19868 +%let EM_TS_ERR = 0;
19870 +%if &inEM eq Y %then %do;
19871 +    %let num_crossIDVar = &EM_NUM_CROSSID;
19872 +    proc sql noprint;
19873 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
19874 +    quit;
19875 +%end;
19876 +%else %do;
19877 +    proc sql noprint;
19878 +         select count(*) into :num_crossIDVar from &variableSet
19879 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19880 +         ;
19881 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
19882 +         ;
19883 +    quit;
19884 +    %let num_crossIDVar=&num_crossIDVar;
19885 +%end;
19887 +* see if _TSID_ exists;
19889 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
19890 +run;
19892 +proc sql noprint;
19893 +    select count(*) into :has_TSID
19894 +        from _emtscm_contents
19895 +        where upcase(strip(name)) eq '_TSID_'
19896 +    ;
19897 +quit;
19899 +/*-------------------------------------------------------------------------*/
19900 +* Creating TSID map..;
19901 +/*-------------------------------------------------------------------------*/
19903 +%if (&num_crossIDVar gt 0) %then %do;
19905 +    data _emtscm_tmpIDMap;
19906 +        set &variableSet;
19907 +        where  (upcase(strip(level)) eq 'INTERVAL')
19908 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
19909 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
19910 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
19911 +          );
19912 +        _emts_dummy=1;
19913 +        keep name label role _emts_dummy;
19914 +    run;
19916 +    proc sql noprint;
19917 +        * create a string of crossID variable like A,B,C,D..;
19918 +        select distinct name into :crossIDVar separated by ','
19919 +            from &variableSet
19920 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19921 +            order by name
19922 +        ;
19923 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
19924 +            from &variableSet
19925 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19926 +            order by name
19927 +        ;
19928 +        * create the TSID map data set;
19929 +        create table _emtscm_tmp1 as
19930 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
19931 +        ;
19932 +        * create a level list of cross ID variables and time series variables;
19933 +        create table &outIDMap as
19934 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
19935 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
19936 +            where a._emts_dummy eq b._emts_dummy
19937 +            order by a.name, &crossIDVar
19938 +        ;
19939 +    quit;
19941 +    %if &TSIDbyCrossID = Y %then %do;
19942 +        * create unique TSID only by Cross ID;
19943 +        data &outIDMap;
19944 +            length _TSID_ 8;
19945 +            set &outIDMap;
19946 +            by _NAMEID_;
19947 +            if first._NAMEID_
19948 +                then _TSID_=1;
19949 +                else _TSID_+1;
19950 +        run;
19951 +        %if "&outDS" ne "" %then %do;
19952 +            * merge TSID into &inDS;
19953 +            proc sql noprint;
19954 +                create table &outDS as
19955 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
19956 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
19957 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
19958 +                        where %do i = 1 %to &num_crossIDVar;
19959 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
19960 +                              %end;
19961 +                             b._TSID_ is not missing
19962 +                    order by b._TSID_, a.&timeIDVar
19963 +                ;
19964 +            quit;
19965 +        %end;
19966 +    %end;
19967 +    %else %do;
19968 +        * create unique TSID by Cross ID and _NAMEID_;
19969 +        data &outIDMap;
19970 +            length _TSID_ 8;
19971 +            set &outIDMap;
19972 +            _TSID_=_n_;
19973 +        run;
19974 +        %if "&outDS" ne "" %then %do;
19975 +            *no merge in this output;
19976 +            data &outDS;
19977 +                set &inDS;
19978 +            run;
19979 +        %end;
19980 +    %end;
19982 +    proc sort data=&outIDMap;
19983 +        by _NAMEID_ _TSID_;
19984 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
19985 +        format _TSID_ best12. _NAMEID2_ $40.;
19986 +        set &outIDMap;
19987 +        by _NAMEID_;
19988 +        if first._NAMEID_
19989 +            then _emts_ind=1;
19990 +            else _emts_ind+1;
19991 +        drop _emts_ind;
19992 +        rename _NAMEID_=_VARNAME_;
19993 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
19994 +        if _labelID_ eq ' '
19995 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
19996 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
19997 +    run;
19999 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
20001 +%end;
20002 +%else %do; /* if no crossid's the nameid needs to be created */
20004 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
20005 +        length _TSID_ 8;
20006 +        set &variableSet;
20007 +        where  (upcase(strip(level)) eq 'INTERVAL')
20008 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
20009 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
20010 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
20011 +          );
20012 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
20013 +        rename ROLE = _ROLE_;
20014 +        _NAMEID_=strip(name);
20015 +        _VARNAME_=strip(name);
20016 +        if label eq ' '
20017 +            then _LABELID_ = strip(name);
20018 +            else _LABELID_ = strip(label);
20019 +        _TSID_=_n_;
20020 +    run;
20022 +    %if "&outDS" ne "" %then %do;
20023 +        *no merge in this output;
20024 +        data &outDS;
20025 +            set &inDS;
20026 +        run;
20027 +    %end;
20028 +%end;
20030 +data &outIDMap;
20031 +    set &outIDMap;
20032 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
20033 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
20034 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
20035 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
20036 +run;
20038 +proc datasets lib=work nolist;
20039 +    delete _emtscm_:;
20040 +run; quit;
20042 +%mend EM_TS_createIDMap;
20044 +%macro EM_TS_CreateMetaData(
20045 +/*-------------------------------------------------------------------------*/
20046 +  inDS          =,      /* imported data set in TS data mining             */
20047 +  outDS         =,      /* output data set of TS metadata                  */
20048 +  variableSet   =,      /* EM variable set                                 */
20049 +  timeInterval  =,      /* time interval                                   */
20050 +  rc            =       /* return code                                     */
20051 +/*-------------------------------------------------------------------------*/
20052 +);
20054 +%if %eval(
20055 +      &EM_NUM_BINARY_INPUT   +
20056 +      &EM_NUM_ORDINAL_INPUT  +
20057 +      &EM_NUM_NOMINAL_INPUT  +
20058 +      &EM_NUM_BINARY_REJECTED   +
20059 +      &EM_NUM_ORDINAL_REJECTED  +
20060 +      &EM_NUM_NOMINAL_REJECTED  +
20061 +      &EM_NUM_ORDINAL_TARGET  +
20062 +      &EM_NUM_NOMINAL_TARGET +
20063 +      &EM_NUM_BINARY_TARGET
20064 +      ) > 0
20065 +%then %do;
20066 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
20067 +        %put &em_codebar;
20068 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
20069 +        %put &errormsg;
20070 +        %put &em_codebar;
20071 +        %goto ENDLINE;
20072 +%end;
20074 +%global EM_TS_ERR;
20075 +%let EM_TS_ERR = 0;
20077 +%if &timeInterval eq AUTO
20078 +    %then %let timeInterval  = ;
20079 +    %else %let timeInterval  = %upcase(&timeInterval);
20081 +/*-------------------------------------------------------------------------*/
20082 +* check time ID variable;
20083 +/*-------------------------------------------------------------------------*/
20085 +* number of variables in the Variableset with ROLE=TIMEID;
20086 +proc sql noprint;
20087 +    select count(*) into :num_timeID from &variableset
20088 +        where upcase(role) eq 'TIMEID';
20089 +quit;
20091 +/*-------------------------------------------------------------------------*/
20092 +* process only when there is one Time ID, otherwise exception message;
20093 +/*-------------------------------------------------------------------------*/
20095 +%if &num_timeID eq 0 %then %do;
20097 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
20098 +    %let EM_TS_ERR = 11;
20099 +    %put &em_codebar;
20100 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
20101 +    %put &errormsg;
20102 +    %put &em_codebar;
20103 +    %goto tscm_endline;
20105 +%end;
20106 +%else %if &num_timeID gt 1 %then %do;
20108 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
20109 +    %let EM_TS_ERR = 12;
20110 +    %put &em_codebar;
20111 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
20112 +    %put &errormsg;
20113 +    %put &em_codebar;
20114 +    %goto tscm_endline;
20116 +%end;
20117 +%else %do;
20118 +    *** proceed when there is one Time ID;
20120 +    data _null_;
20121 +        set &variableset(where=(upcase(role)='TIMEID'));
20122 +        call symput('timeIDFormat',     strip(format));
20123 +        call symput('timeID',           strip(upcase(name)      ));
20124 +        call symput('timeIDLevel',      strip(upcase(level))     );
20125 +        call symput('timeIDFormatType', strip(upcase(formattype)));
20126 +    run;
20128 +    *** exception message if the time ID is not an interval variable;
20129 +    %if &timeIDLevel ne INTERVAL %then %do;
20130 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
20131 +        %let EM_TS_ERR = 13;
20132 +        %put &em_codebar;
20133 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
20134 +        %put &errormsg;
20135 +        %put &em_codebar;
20136 +        %goto tscm_endline;
20137 +    %end;
20139 +    %if (&timeIDFormatType ne DATETIME) and
20140 +        (&timeIDFormatType ne DATE) and
20141 +        (&timeIDFormatType ne TIME) and
20142 +        (&timeIDFormatType ne USER)
20143 +    %then %do;
20144 +        *** sequential format-type of time ID;
20146 +        %let timeInterval = DAY;
20147 +        %let timeIDFormatType = SEQ;
20149 +        proc sql noprint;
20150 +            create table _emtscm_inds as
20151 +                 select distinct &timeID from &inDS(keep=&timeID)
20152 +                 where &timeID is not missing;
20153 +            select count(*) into :num_nonInteger from _emtscm_inds
20154 +                where &timeID ne int(&timeID);
20155 +        quit;
20157 +        %if &num_nonInteger gt 0 %then %do;
20158 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
20159 +            %let EM_TS_ERR = 14;
20160 +            %put &em_codebar;
20161 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
20162 +            %put &errormsg;
20163 +            %put &em_codebar;
20164 +            %goto tscm_endline;
20165 +        %end;
20166 +    %end;
20167 +    %else %do;
20168 +        *** date, datetime, time format-type of time ID;
20170 +        *** must have a format;
20171 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
20172 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
20173 +            %let EM_TS_ERR = 15;
20174 +            %put &em_codebar;
20175 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
20176 +            %put &errormsg;
20177 +            %put &em_codebar;
20178 +            %goto tscm_endline;
20179 +        %end;
20181 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
20182 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
20183 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
20184 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
20185 +                %let EM_TS_ERR = 16;
20186 +                %put &em_codebar;
20187 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
20188 +                %put &errormsg;
20189 +                %put &em_codebar;
20190 +                %goto tscm_endline;
20191 +            %end;
20192 +        %end;
20194 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
20195 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
20196 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
20197 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
20198 +                %let EM_TS_ERR = 17;
20199 +                %put &em_codebar;
20200 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
20201 +                %put &errormsg;
20202 +                %put &em_codebar;
20203 +                %goto tscm_endline;
20204 +            %end;
20205 +        %end;
20207 +        *** the AUTO function is currently turned off for TIME timeID variable;
20208 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
20209 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
20210 +            %let EM_TS_ERR = 18;
20211 +            %put &em_codebar;
20212 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
20213 +            %put &errormsg;
20214 +            %put &em_codebar;
20215 +            %goto tscm_endline;
20216 +        %end;
20218 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
20219 +            %then %let timeInterval =DT&timeInterval;
20221 +        proc sql noprint;
20222 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
20223 +                where &timeID is not missing;
20224 +        quit;
20225 +    %end;
20227 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
20228 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
20229 +    run;
20231 +    %let hasValidInterval = 0;
20232 +    %let hasLengthOne     = 0;
20234 +    proc sql noprint;
20235 +        create table _emtscm_label as
20236 +            select name,label
20237 +            from dictionary.columns
20238 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
20239 +        ;
20240 +        create table _emtscm_meta2 as
20241 +            select a.*, b.label
20242 +            from _emtscm_meta as a, _emtscm_label as b
20243 +            where upcase(a.timeID) eq upcase(b.name)
20244 +        ;
20245 +    quit;
20247 +    data &outDS;
20248 +        set _emtscm_meta2;
20249 +        format
20250 +            timeformat      $30.
20251 +            role            $10.
20252 +            start           &timeIDformat
20253 +            end             &timeIDformat
20254 +            apply_start_end $8.
20255 +        ;
20256 +        rename
20257 +            timeID      = name
20258 +            seasonality = lengthOfCycle
20259 +            interval    = timeinterval
20260 +        ;
20261 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
20263 +        role            = "TIMEID";
20264 +        apply_start_end = 'N';
20265 +        timeformat      = symget('timeIDformat');
20266 +        timeformattype  = symget('timeIDformatType');
20268 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
20269 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
20270 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
20271 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
20272 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
20273 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
20274 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
20275 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
20276 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
20277 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
20279 +        if timeformattype eq 'SEQ' then do;
20280 +            timeformat='BEST12.';
20281 +            seasonality=1;
20282 +        end;
20284 +        call symput('_tinterval',interval);
20286 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
20288 +        if upcase(timeformattype) eq 'DATE' and
20289 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
20290 +            then call symput('hasValidInterval',1);
20292 +        if upcase(timeformattype) eq 'DATETIME' and
20293 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
20294 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
20295 +            then call symput('hasValidInterval',1);
20297 +        if upcase(timeformattype) eq 'TIME' and
20298 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
20299 +            then call symput('hasValidInterval',1);
20301 +        if upcase(timeformattype) eq 'SEQ'
20302 +            then call symput('hasValidInterval',1);
20304 +        if upcase(timeformattype) eq 'USER'
20305 +            then call symput('hasValidInterval',1);
20307 +        if start eq end
20308 +            then call symput('hasLengthOne',1);
20309 +    run;
20311 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
20313 +    *** detect any missing time interval after running PROC TIMEID;
20314 +    %if &_tinterval eq %then %do;
20315 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
20316 +        %let EM_TS_ERR = 19;
20317 +        %put &em_codebar;
20318 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
20319 +        %put &errormsg;
20320 +        %put &em_codebar;
20321 +        %goto tscm_endline;
20322 +    %end;
20324 +    *** detect any missing time interval after running PROC TIMEID;
20325 +    %if &hasValidInterval eq 0 %then %do;
20326 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
20327 +        %let EM_TS_ERR = 20;
20328 +        %put &em_codebar;
20329 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
20330 +        %put &errormsg;
20331 +        %put &em_codebar;
20332 +        %goto tscm_endline;
20333 +    %end;
20335 +    %if &hasLengthOne eq 1 %then %do;
20336 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
20337 +        %let EM_TS_ERR = 21;
20338 +        %put &em_codebar;
20339 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
20340 +        %put &errormsg;
20341 +        %put &em_codebar;
20342 +        %goto tscm_endline;
20343 +    %end;
20345 +%end;
20347 +%tscm_endline:;
20349 +%mend EM_TS_CreateMetaData;
20352 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
20354 +data _null_;
20355 +    set &tsmeta;
20356 +    call symput('_timeidFormatType', timeformattype);
20357 +    call symput('_timeid', strip(name));
20358 +    call symput('_seqstartnum',strip(put(start,best12.)));
20359 +run;
20361 +proc contents data=&inDS noprint
20362 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20363 +run; quit;
20365 +data _null_;
20366 +    set _emts_tmpp1;
20367 +    call symput('_timeIDlabel',label);
20368 +run;
20370 +%if &_timeidFormatType eq SEQ
20371 +%then %do;
20372 +    proc sql noprint;
20373 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
20374 +    quit;
20375 +    %let _dummystarttime=&_dummystarttime;
20377 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20378 +        set &inDS;
20379 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
20380 +        drop &_timeid;
20381 +        label _tsdp_tmpID = "&_timeIDlabel";
20383 +    run;
20384 +%end;
20386 +%mend;
20388 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
20390 +data _null_;
20391 +    set &tsmeta;
20392 +    call symput('_timeidFormatType', timeformattype);
20393 +    call symput('_timeidFormat', timeformat);
20394 +    call symput('_timeid', strip(name));
20395 +    call symput('_timeinterval',strip(upcase(timeinterval)));
20396 +run;
20398 +/* manually change time ID format to a longer enough time format */
20399 +/* because proc timeid returns time5. for second time interval */
20400 +/* which is not long enough for transpose with time unit as seconds */
20401 +%if &_timeinterval eq SECOND
20402 +%then %do;
20403 +    %let _timeIDformat = %str(time8.);
20404 +%end;
20406 +proc contents data=&inDS noprint
20407 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20408 +run; quit;
20410 +data _null_;
20411 +    set _emts_tmpp1;
20412 +    call symput('_timeIDlabel',label);
20413 +run;
20415 +%if &_timeidFormatType eq TIME
20416 +%then %do;
20417 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20418 +        set &inDS;
20419 +        _tsdp_tmpID = timepart(&_timeID);
20420 +        format _tsdp_tmpID &_timeidFormat;
20421 +        label  _tsdp_tmpID = "&_timeIDlabel";
20422 +        drop &_timeid;
20423 +    run;
20424 +%end;
20426 +%mend;
20428 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
20430 + proc sql noprint;
20431 +     create table _tmptimetable as
20432 +         select distinct &timeidvar as DATE from &inDS
20433 +         where &timeIDVar is not missing
20434 +         order by &timeIDVar;
20435 + quit;
20437 +%if &compare eq Y %then %do;
20438 +    * compare with the existing time table;
20439 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
20440 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
20441 +    run;
20443 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
20445 +    %if &_diffobs > 0 %then %do; /* create it again */
20446 +        data &outDS(keep=DATE _INDEX_);
20447 +            set _tmptimetable end = _eof_;
20448 +            if _N_ = 1
20449 +                then _INDEX_ = 1;
20450 +                else _INDEX_ = 0;
20451 +            if _eof_ then _INDEX_= 2;
20452 +        run;
20453 +    %end;
20455 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
20456 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20457 +%end;
20458 +%else %do;
20459 +    * create a new time table directly;
20460 +    data &outDS(keep=DATE _INDEX_);
20461 +        set _tmptimetable end = _eof_;
20462 +        if _N_ = 1
20463 +            then _INDEX_ = 1;
20464 +            else _INDEX_ = 0;
20465 +        if _eof_ then _INDEX_= 2;
20466 +    run;
20468 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20469 +%end;
20471 +* assign a defult format BEST12. for sequential time ID;
20473 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
20475 +%let _nodatefmt=N;
20477 +data _null_;
20478 +    set _tmpcontents;
20479 +    where upcase(name) eq 'DATE';
20480 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
20481 +run;
20483 +%if "&_nodatefmt" eq "Y" %then %do;
20484 +    data &outDS;
20485 +        set &outDS;
20486 +        format date best12.;
20487 +    run;
20488 +%end;
20490 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
20492 +%mend;
20496 +%macro EM_TS_Transpose(
20497 +/*-------------------------------------------------------------------------*/
20498 +  inDS          =,      /* imported data set in TS data mining             */
20499 +  inIDMap       =,      /* input TS ID map                                 */
20500 +  variableSet   =,      /* variable set                                    */
20501 +  transposeBy   =,      /* byTSID or byTimeID                              */
20502 +  outDS         =,      /* output transposed data set                      */
20503 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
20504 +  inEM          =Y,
20505 +  timePrefix    =_T
20506 +/*-------------------------------------------------------------------------*/
20507 +);
20509 +%let timePrefix = &timePrefix;
20511 +%if  &EM_NUM_CROSSID > 0 %then %do;
20513 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
20514 +    set &inIDMap;
20515 +    drop _NAMEID_;
20516 +    run;
20517 +%let inIDMap=_emtstp_map0;
20519 +%end;
20521 +proc sql noprint;
20522 +    * number of TS Variables to be transposed;
20523 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
20524 +    ;
20525 +    * number of TS Variables to be transposed;
20526 +    select max(_TSID_) into :num_TSID from &inIDMap
20527 +    ;
20528 +    * name list of TS Variables;
20529 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
20530 +        from &inIDMap
20531 +        order by _NAMEID_
20532 +    ;
20533 +    * total number of time series =max(_TSID_)*&num_TSVar;
20534 +    * and the number of digits of this variable is &num_digits;
20535 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
20536 +        from &inIDMap
20537 +    ;
20538 +      * Time ID variable;
20539 +    select name into:timeIDVar from &variableset
20540 +        where upcase(role) eq 'TIMEID'
20541 +    ;
20542 +quit;
20543 +%let num_digits = &num_digits;
20544 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
20546 +/*-------------------------------------------------------------------------*/
20548 +* get number of cross IDs and also the TIME ID variable name;
20549 +%if &inEM eq Y %then %do;
20550 +    %let num_crossIDVar = &EM_NUM_CROSSID;
20551 +    %let crossIDVar     = %EM_CROSSID;
20552 +%end;
20553 +%else %do;
20554 +    proc sql noprint;
20555 +        * number of cross ID;
20556 +        select count(*) into :num_crossIDVar
20557 +            from &variableSet
20558 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20559 +        ;
20560 +        * create a string of crossID variable like A B C D..;
20561 +        select distinct name into :crossIDVar separated by ' '
20562 +            from &variableSet
20563 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20564 +            order by name
20565 +        ;
20566 +    quit;
20567 +    %let num_crossIDVar=&num_crossIDVar;
20568 +%end;
20570 +/*-------------------------------------------------------------------------*/
20572 +%if (&num_crossIDVar gt 0) %then %do;
20574 +    data _emtstp_tmpDat;
20575 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
20576 +        _NAMEID_ = cats("_TS_",_TSID_);
20577 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
20578 +    run;
20580 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20582 +        * update the ID maps;
20583 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20584 +            by _NAMEID_ _TSID_;
20585 +        data &outIDMap;
20586 +            set _emtstp_tmpmap;
20587 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20588 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20589 +        run;
20591 +        * get the names for the new variables;
20592 +        proc sql noprint;
20593 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
20594 +            ;
20595 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
20596 +            ;
20597 +        quit;
20599 +        * data must be sorted before transposed;
20600 +        proc sort data=_emtstp_tmpDat;
20601 +            by &timeIDvar;
20602 +        run;
20604 +        %do i = 1 %to &num_TSVar;
20605 +            %let i = &i;
20606 +            * transpose one cross-type time series data by TSID;
20607 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
20608 +                id _NAMEID_;
20609 +                by &timeIDVar;
20610 +                var &&&TSVar&i;
20611 +            run;
20612 +        %end;
20614 +        * merge all vertical time series, rename and label them;
20615 +        data &outDS;
20616 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
20617 +            by &timeIDVar;
20618 +            rename
20619 +                %do i = 1 %to &num_TSVar;
20620 +                    %do j = 1 %to &num_TSID;
20621 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20622 +                        /* %put &i &j &num1 &num_TSID; */
20623 +                        _V_&i._TS_&j = &&&tsname&num1
20624 +                    %end;
20625 +                %end;
20626 +            ;
20627 +            label
20628 +                %do i = 1 %to &num_TSVar;
20629 +                    %do j = 1 %to &num_TSID;
20630 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20631 +                        /* %put &i &j &num1 &num_TSID; */
20632 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
20633 +                    %end;
20634 +                %end;
20635 +            ;
20636 +        run;
20637 +    %end;
20638 +    %else %do;
20640 +        * update the ID maps;
20641 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20642 +            by _NAMEID_ _TSID_;
20643 +        data &outIDMap;
20644 +            set _emtstp_tmpmap;
20645 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20646 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20647 +        run;
20649 +        proc sql noprint;
20650 +            * get the roles for the new variables;
20651 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
20652 +                from &inIDMap
20653 +                order by _NAMEID_
20654 +            ;
20655 +            * get the length of the time series;
20656 +            select count(distinct &timeIDvar) into :num_T
20657 +                from _emtstp_tmpDat
20658 +            ;
20659 +        quit;
20661 +        * data must be sorted before transposed;
20662 +        proc sort data=_emtstp_tmpDat;
20663 +            by _TSID_ &crossIDVar &timeIDvar;
20664 +        run;
20666 +        %do i = 1 %to &num_TSVar;
20667 +            %let i = &i;
20668 +            * transpose one cross-type time series data by TIMEID;
20669 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
20670 +                by _TSID_ &crossIDVar;
20671 +                var &&&TSVar&i;
20672 +            run;
20673 +        %end;
20675 +        * stack all horizontal time series;
20676 +        data &outDS;
20677 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
20678 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
20679 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
20680 +            %do i=1 %to &num_TSVar;
20681 +                if in&i then do;
20682 +                    _NAMEID_ ="&&&TSVar&i";
20683 +                    _ROLE_   ="&&&TSRole&i";
20684 +                end;
20685 +            %end;
20686 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
20687 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
20688 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
20689 +        run;
20690 +    %end;
20691 +%end;
20692 +%else %do;
20694 +    proc sql noprint;
20695 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
20696 +            order by _NAMEID_
20697 +        ;
20698 +    quit;
20700 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20701 +        * transpose the panel-type time series data by TSID;
20702 +        proc sort data=&inDS out=_emtstp_tmpDat;
20703 +            by &timeIDvar;
20704 +        proc transpose data=_emtstp_tmpDat
20705 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
20706 +            by &timeIDVar;
20707 +            var &panelTSVar;
20708 +        run;
20709 +        proc datasets lib=work nolist;
20710 +            modify _emtstp_tmpDat2;
20711 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
20712 +            run; quit;
20713 +    %end;
20714 +    %else %do;
20715 +        * transpose the panel-type time series data by TIMEID;
20716 +        proc sort data=&inDS out=_emtstp_tmpDat;
20717 +            by &timeIDvar;
20718 +        data _emtstp_tmpDat;
20719 +            set _emtstp_tmpDat;
20720 +            _tmp_ind=_n_;
20721 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
20722 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
20723 +            ID _tmp_ind;
20724 +            var &panelTSVar;
20725 +        run;
20726 +    %end;
20728 +      * merge ID maps to the transpose data set;
20729 +      proc sql noprint;
20730 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
20731 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
20732 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
20733 +          ;
20734 +      quit;
20736 +      * update the TS ID map;
20737 +      data &outIDMap;
20738 +          set &inIDMap;
20739 +      run;
20740 +%end;
20742 +proc datasets lib=work nolist;
20743 +    delete _emtstp:;
20744 +run; quit;
20746 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_SCORE.SOURCE.
20748 +/*----------------------------------------------------------------------------------+
20749 + |
20750 + |   Title :  TS ESM Node
20751 + |
20752 + |   SUPPORT: Taiyeong Lee (Taiyeong.Lee@sas.com)
20753 + |
20754 + +-----------------------------------------------------------------------------------*/
20756 +%macro EM_TSESM_SCORE;
20758 +    /* the case when Targets and Inputs have the same format, apply the format to the output statistics*/
20759 +    /* defect S1014292 */
20760 +    %global  _seriesFormat;
20761 +    %let _seriesFormat =;
20762 +    proc sql noprint;
20763 +        select count(distinct format) into :_numSeriesFormat
20764 +        from &EM_DATA_VARIABLESET
20765 +        where upcase(role) eq 'TARGET' or upcase(role) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D');
20766 +    quit;
20767 +    %if &_numSeriesFormat = 1 %then %do;
20768 +        proc sql noprint;
20769 +            select distinct format into :_seriesFormat
20770 +            from &EM_DATA_VARIABLESET
20771 +            where upcase(role) eq 'TARGET' or upcase(role) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D');
20772 +        quit;
20773 +    %end;
20775 +   /* When Forecast Input Time Series is Yes, Output Data Type is always Default */
20776 +   %let _EXPORTDATA = &EM_PROPERTY_EXPORTDATA;
20777 +   %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
20778 +      %let _EXPORTDATA = DEFAULT  ;
20779 +   %end;
20782 +    %EM_GETNAME(KEY=OUTFORCST, TYPE=DATA);
20783 +    %EM_GETNAME(KEY=FORCSTPLOTDS, TYPE=DATA);
20786 +%if &EM_PROPERTY_PLOTLENGTH ne MAX %then %do;
20789 +    %if &EM_PROPERTY_PLOTLENGTH eq DEFAULT %then %do;
20790 +        %let _nobs = 0;
20791 +        %let dsid=%sysfunc(open(&EM_USER_OUTFORCST));
20792 +        %if dsid > 0 %then %do;
20793 +            %let _nobs = %sysfunc(attrn(&dsid, NOBS));
20794 +            %let dsid = %sysfunc(close(&dsid));
20795 +        %end;
20797 +        %if &_nobs > 20000 %then %let _PLOTLENGTH = 3;
20798 +        %else %let _PLOTLENGTH = MAX;
20800 +    %end;
20801 +    %else %do;
20802 +        %let _PLOTLENGTH = &EM_PROPERTY_PLOTLENGTH;
20803 +    %end;
20805 +    %if &_PLOTLENGTH ne MAX %then %do;
20806 +         %let _timeidvar =%EM_TIMEID;
20807 +         data _tmptimeds;
20808 +            set   &EM_USER_OUTFORCST ;
20809 +            keep=&_timeidvar;
20810 +         run;
20811 +         proc sql;
20812 +              create table _tmptimeds2
20813 +              as
20814 +             select distinct(_tmptimeds.&_timeidvar) from _tmptimeds;
20815 +         run;
20816 +         quit;
20818 +         proc sort data=_tmptimeds2   out= _tmptimeds2  ;
20819 +              by descending &_timeidvar;
20820 +         run;
20821 +         %let _nplot =%sysevalf(&EM_PROPERTY_FCLEAD * (1+ &_PLOTLENGTH));
20823 +         %let _ntimeid = 0;
20824 +         %let dsid=%sysfunc(open(work._tmptimeds2));
20825 +         %if dsid > 0 %then %do;
20826 +             %let _ntimeid = %sysfunc(attrn(&dsid, NOBS));
20827 +             %let dsid = %sysfunc(close(&dsid));
20828 +         %end;
20829 +         %if &_ntimeid > &_nplot %then %do;
20830 +             data _null_;
20831 +                 set _tmptimeds2;
20832 +                 if _N_ eq &_nplot then do;
20833 +                 call symput("_start", &_timeidvar);
20834 +                 end;
20835 +             run;
20837 +             data &EM_USER_FORCSTPLOTDS;
20838 +               set  &EM_USER_OUTFORCST;
20839 +               if &_timeidvar >= &_start then output;
20840 +             run;
20841 +         %end;
20842 +         %else %do;
20843 +               data &EM_USER_FORCSTPLOTDS;
20844 +                    set  &EM_USER_OUTFORCST;
20845 +               run;
20846 +         %end;
20847 +    %end; /* end of %if &_PLOTLENGTH ne MAX %then %do; */
20848 +    %else %do;
20849 +         data &EM_USER_FORCSTPLOTDS;
20850 +              set  &EM_USER_OUTFORCST;
20851 +         run;
20852 +    %end;
20854 +%end; /* end of ne MAX */
20855 +%else %do;
20856 +    data &EM_USER_FORCSTPLOTDS;
20857 +         set  &EM_USER_OUTFORCST;
20858 +    run;
20859 +%end;  /* end of eq Max  */
20861 +/* Apply series format */
20862 +    /* defect S1014292 */
20863 +%if &_seriesFormat ^= %then %do;
20865 +    data &EM_USER_FORCSTPLOTDS;
20866 +         set  &EM_USER_FORCSTPLOTDS;
20867 +         format ACTUAL &_seriesFormat;
20868 +         format PREDICT &_seriesFormat;
20869 +         format LOWER &_seriesFormat;
20870 +         format UPPER &_seriesFormat;
20871 +         format ERROR &_seriesFormat;
20872 +         format STD &_seriesFormat;
20873 +    run;
20876 +%end;
20878 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptimeds);
20879 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptimeds2);
20883 +/* moved from training macro by ruzhan */
20885 +   %EM_GETNAME(KEY=OUTPRED, TYPE=DATA);
20886 +   %EM_GETNAME(KEY=OUTSUM, TYPE=DATA);
20887 +   %EM_GETNAME(KEY=OUTDATA, TYPE=DATA);
20888 +   %EM_GETNAME(KEY=OUTLIER, TYPE=DATA);
20889 +   %EM_GETNAME(KEY=OUTKLD, TYPE=DATA);
20890 +   %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
20892 +/* Apply series format */
20893 +    /* defect S1014292 */
20894 +%if &_seriesFormat ^= %then %do;
20896 +    data &EM_USER_OUTSUM;
20897 +        set  &EM_USER_OUTSUM;
20898 +        format MIN &_seriesFormat;
20899 +        format MAX &_seriesFormat;
20900 +        format MEAN &_seriesFormat;
20901 +        format STDDEV &_seriesFormat;
20902 +        format PREDICT &_seriesFormat;
20903 +        format LOWER &_seriesFormat;
20904 +        format UPPER &_seriesFormat;
20905 +        format STD &_seriesFormat;
20906 +        %let _lead_num_ = 1;
20907 +        %do %while (&_lead_num_ <= &em_property_FCLead);
20908 +            %let _FCLead_ = _LEAD&_lead_num_._;
20909 +            format &_FCLead_ &_seriesFormat;
20910 +            %let _lead_num_ = %eval(&_lead_num_ +1);
20911 +        %end;
20913 +    run;
20916 +%end;
20919 +   /*---------- Check and assign the input data set --------------------------*/
20922 +    %let _EXPORT_DATA  = ;
20923 +    %let _FILE_CDELTA  = ;
20925 +    %if &EM_IMPORT_DATA ne  %then %do;
20927 +           %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
20928 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
20930 +    %end;
20931 +    %else %if &EM_IMPORT_TRANSACTION ne  %then %do;
20933 +           %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
20934 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRANSACTION;
20935 +    %end;
20936 +    %else %do;
20937 +           %let  EMEXCEPTIONSTRING = exception.server.tsdm.noinputdata;
20938 +           %goto ENDLINE;
20939 +    %end;
20943 +   %if &_EXPORTDATA eq KLD %then %do;
20944 +       %if  &EM_PROPERTY_CLUSLEADPOINT > %eval(&EM_PROPERTY_FCLEAD-&EM_PROPERTY_FCBACK) %then %do;
20945 +           %put &em_codebar;
20946 +           %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.invalidleadpointforkld_err, NOQUOTE));
20947 +           %put &errormsg;
20948 +           %put &em_codebar;
20949 +           %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidleadpointforkld;
20950 +           %goto ENDLINE;
20951 +       %end;
20952 +       %else %do;
20953 +            %let _clusLeadPoint =  &EM_PROPERTY_CLUSLEADPOINT;
20954 +       %end;
20955 +       %EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
20956 +                            target=%EM_TARGET,
20957 +                            timeid=%EM_TIMEID,
20958 +                            futurepoint=&_clusLeadPoint,
20959 +                            outKLD=&EM_USER_OUTKLD
20960 +                            );
20962 +       data &_EXPORT_DATA;
20963 +           set &EM_USER_OUTKLD;
20964 +       run;
20965 +   %end;
20966 +    %else %if &_EXPORTDATA eq FORECAST %then %do;
20968 +              %EM_TSESM_MakeOutClusInput(indata=&EM_USER_OUTSUM,
20969 +                                         esmmethod=&EM_PROPERTY_FCMETHOD,
20970 +                                         criterion=&EM_PROPERTY_BESTCRIT,
20971 +                                         outdata= &_EXPORT_DATA);
20972 +    %end;
20973 +    %else %if &_EXPORTDATA eq SIMILARITY %then %do;
20975 +              %EM_TSESM_MakeOutSimInput(indata=&EM_USER_OUTSUM,
20976 +                                        inoutfor=&EM_USER_OUTDATA,
20977 +                                        target=%EM_TARGET,
20978 +                                        timeid=%EM_TIMEID,
20979 +                                        esmmethod=&EM_PROPERTY_FCMETHOD,
20980 +                                        criterion=&EM_PROPERTY_BESTCRIT,
20981 +                                        outdata= &_EXPORT_DATA
20982 +                                       );
20983 +    %end;
20984 +    %else %do;
20986 +             data &_EXPORT_DATA;
20987 +                  set &EM_USER_OUTDATA;
20988 +             run;
20990 +        * number of outliers;
20991 +        /* this block is added 09022011 */
20992 +        proc sql noprint;
20993 +            select count(*) into :_has_outlier from &EM_USER_OUTLIER where outlierindex eq 1;
20994 +        quit;
20996 +        %if &EM_PROPERTY_SMOOTHOUTLIER eq Y and &_has_outlier gt 0 %then %do;
20997 +            /* this block is moved from below 09022011 */
20998 +            %EM_TSESM_MakeSmoothedOutds(indata=&_EXPORT_DATA,
20999 +                                        inoutlierds=&EM_USER_OUTLIER,
21000 +                                        target=%EM_TARGET,
21001 +                                        timeid=%EM_TIMEID,
21002 +                                        replace=&EM_PROPERTY_OUTLIERREPLACE,
21003 +                                        outdata=&_EXPORT_DATA
21004 +                                        );
21006 +            * in this type of output DO NOT keep outlier flags;
21007 +            /* this block is added 09022011 */
21008 +            %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
21009 +                data &_EXPORT_DATA;
21010 +                    set &_EXPORT_DATA;
21011 +                    drop outlier:;
21012 +                run;
21013 +            %end;
21015 +        %end;
21016 +    %end;
21018 +   /*--------------- Modify and export columnsMeta ------------------------------------*/
21021 +      data _null_;
21022 +       length string $34;
21023 +       filename X "&_FILE_CDELTA";
21024 +       file X;
21027 +      %if (&_EXPORTDATA eq KLD)
21028 +       or (&_EXPORTDATA eq FORECAST)
21029 +       or (&_EXPORTDATA eq SIMILARITY)
21030 +      %then %do;
21032 +         %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
21033 +         %if &dsid > 0 %then %do;
21034 +            %let nvar = %sysfunc(attrn(&dsid, NVAR));
21035 +            %do i = 1 %to &nvar;  /* not 1= _NAMEID_   2=_TSID_ */
21036 +                 %let varname = %sysfunc(varname(&dsid, &i));
21038 +                      %if ~(( &varname eq _TSID_ ) or ( &varname eq _NAMEID_ ) ) %then  %do;
21039 +                          put "if UPCASE(STRIP(NAME)) eq UPCASE(STRIP('&varname')) then ROLE='CROSSID';";
21040 +                      %end;
21041 +             %end;
21043 +             %if (&_EXPORTDATA eq SIMILARITY)   %then %do;
21044 +                  put "if upcase(strip(ROLE)) eq 'TARGET' then ROLE = 'INPUT'; ";
21045 +             %end;
21047 +             %let dsid = %sysfunc(close(&dsid));
21048 +           %end;
21049 +           put "if UPCASE(STRIP(NAME)) eq '_TSID_' then ROLE='ID';";
21050 +           put "if UPCASE(STRIP(NAME)) eq '_VARNAME_' then ROLE='REJECTED';";
21051 +           put "if UPCASE(STRIP(NAME)) eq '_ROLE_' then ROLE='REJECTED';";
21052 +           put "if UPCASE(STRIP(NAME)) eq '_NAMEID_' then ROLE='ID';";
21054 +    %end;
21055 +    %else %do;
21056 +           put "if UPCASE(STRIP(NAME)) eq '_TSID_' then ROLE='ID';";
21057 +    %end;
21060 +    run;
21065 +    %ENDLINE:
21066 +%mend EM_TSESM_SCORE;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTFORCST.
NOTE: The data set EMWS5.TSESM2_FORCSTPLOTDS has 221 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_FORCSTPLOTDS.
NOTE: The data set EMWS5.TSESM2_FORCSTPLOTDS has 221 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The file WORK._TMPTIMEDS (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The file WORK._TMPTIMEDS2 (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM2_OUTSUM.
NOTE: The data set EMWS5.TSESM2_OUTSUM has 1 observations and 20 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: The data set EMWS5.TSESM2_TRAIN has 221 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Variable string is uninitialized.
NOTE: The file X is:
      Filename=F:\WQD7005\MalaysiaStockPrediction-master\SAS\Mildstone5\Milestone5-Insight\Workspaces\EMWS5\TSESM2\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=19Dec2019:14:31:54,
      Create Time=19Dec2019:12:28:30
 
NOTE: 1 record was written to the file X.
      The minimum record length was 50.
      The maximum record length was 50.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
21069
21070
21071  *------------------------------------------------------------*;
21072  * End SCORE: TSESM2;
21073  *------------------------------------------------------------*;
 
21075  *------------------------------------------------------------*;
21076  * TSESM2: Computing metadata for TRAIN data;
21077  *------------------------------------------------------------*;
 
*------------------------------------------------------------*
* Report Log
Date:                December 19, 2019
Time:                14:31:55
*------------------------------------------------------------*
21447  %let EMEXCEPTIONSTRING=;
21448  *------------------------------------------------------------*;
21449  * REPORT: TSESM2;
21450  *------------------------------------------------------------*;
21451  %let EM_ACTION = REPORT;
21452  %let syscc = 0;
21453
21454  %macro EM_TSESM_MAIN;
21455
21456     filename temp catalog 'sashelp.emtsdm.tsesm_macros.source';
21457     %include temp;
21458     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
21459     %include temp;
21460     filename temp;
21461
21462     %if %upcase(&EM_ACTION) = CREATE %then %do;
21463         filename temp catalog 'sashelp.emtsdm.tsesm_create.source';
21464         %include temp;
21465         filename temp;
21466         %EM_TSESM_CREATE;
21467     %end;
21468     %else
21469     %if %upcase(&EM_ACTION) = TRAIN %then %do;
21470          filename temp catalog 'sashelp.emtsdm.tsesm_train.source';
21471             %include temp;
21472             filename temp;
21473          %EM_TSESM_TRAIN;
21474     %end;
21475     %else
21476     %if %upcase(&EM_ACTION) = SCORE %then %do;
21477             filename temp catalog 'sashelp.emtsdm.tsesm_score.source';
21478             %include temp;
21479             filename temp;
21480           %EM_TSESM_SCORE;
21481     %end;
21482     %else
21483     %if %upcase(&EM_ACTION) = REPORT %then %do;
21484             filename temp catalog 'sashelp.emtsdm.tsesm_report.source';
21485             %include temp;
21486             filename temp;
21487            %EM_TSESM_REPORT;
21488     %end;
21489  %mend EM_TSESM_MAIN;
21490  %EM_TSESM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_MACROS.SOURCE.
21491 +/*----------------------------------------------------------------------------------+
21492 + |
21493 + |   Title :  Time Series data Mining Forcating Macros
21494 + |
21495 + |   SUPPORT: Ruiwen Zhang (Ruiwen.Zhang@sas.com)
21496 + |
21497 + |
21498 + +-----------------------------------------------------------------------------------*/
21501 +%macro EM_TSESM_Forecast(indata=,
21502 +                method=,
21503 +                timeinterval=,
21504 +                timeid= ,
21505 +                target= ,
21506 +                tsidvar=,
21507 +                lead=,
21508 +                back=,
21509 +                startsum=,
21510 +                accumulate=,
21511 +                seasonality=,
21512 +                alpha=,
21513 +                extendedvalue=,
21514 +                outest = ,
21515 +                outdata = ,
21516 +                outfor = ,
21517 +                outstat = ,
21518 +                outsum=
21519 +   );
21522 +   %if &tsidvar eq _SEGMENT_ %then %do;
21523 +       proc sort data=&indata out=_tmpdata;
21524 +            by  &tsidvar %EM_CROSSID &timeid ;
21525 +       run;
21526 +       proc timeseries  data =_tmpdata out=_tmpdata;
21527 +            by  &tsidvar %EM_CROSSID;
21528 +            id &timeid interval=&timeinterval accumulate=&accumulate;
21529 +            var &target / ;
21530 +       run;
21531 +       proc esm data =_tmpdata
21532 +   %end;
21533 +   %else %do;
21534 +       proc sort data= &indata out=_tmpdata;
21535 +            by  &tsidvar %EM_CROSSID &timeid ;
21536 +       run;
21537 +       proc esm data = _tmpdata
21538 +   %end;
21539 +            lead=&lead  back=&back startsum=&startsum
21541 +   %if &seasonality ne DEFAULT %then %do;
21542 +            seasonality = &seasonality
21543 +   %end;
21546 +            out=&outdata
21547 +            outest=&outest
21548 +            outfor =&outfor
21549 +            outstat=&outstat
21550 +            outsum= &outsum
21551 +       ;
21552 +        id &timeid  interval = &timeinterval   accumulate=&accumulate ;
21554 +        %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
21555 +            %if &target ne %then %do;
21556 +            forecast &target   /  model = none alpha=&alpha;
21557 +            %end;
21558 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21559 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /  model = &method alpha=&alpha use=&extendedvalue;
21560 +            %end;
21561 +        %end;
21562 +        %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
21563 +            %if &target ne %then %do;
21564 +            forecast &target /  model =&method alpha=&alpha;
21565 +            %end;
21566 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21567 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
21568 +            %end;
21569 +        %end;
21570 +        %else %do; /* for KLD, FORECAST Cluster , SIMILARITY */
21571 +            forecast &target /*%EM_INTERVAL_INPUT*/ /  model = &method alpha=&alpha use=predict;
21572 +        %end;
21574 +   %if &tsidvar ne %then %do;
21575 +        by &tsidvar %EM_CROSSID ;
21576 +   %end;
21577 +   run;
21578 +%mend EM_TSESM_Forecast;
21581 +%macro EM_TSESM_CreateOutFor(indata=,
21582 +                            target=,
21583 +                            timeid=,
21584 +                            tsidVar=,
21585 +                            percent=,
21586 +                            outdata=);
21588 +  %let lowerBound = L&percent;
21589 +  %let upperBound = U&percent;
21591 +  data ds_fore(rename=(&target=FORECAST)  drop=_TYPE_)
21592 +       ds_resid(rename=(&target=RESIDUAL) drop=_TYPE_)
21593 +       ds_act(rename=(&target=ACTUAL) drop=_TYPE_)
21594 +       ds_lower(rename=(&target=LBOUND)  drop=_TYPE_)
21595 +       ds_upper(rename=(&target=UBOUND) drop=_TYPE_)
21596 +       ds_std(rename=(&target=STD) drop=_TYPE_);
21597 +     set &indata;
21598 +       if _TYPE_="FORECAST" then output ds_fore;
21599 +       if _TYPE_="RESIDUAL" then output ds_resid;
21600 +       if _TYPE_="ACTUAL" then output ds_act;
21601 +       if _TYPE_="&lowerBound" then output ds_lower;
21602 +       if _TYPE_="&upperBound" then output ds_upper;
21603 +       if _TYPE_="STD" then output ds_std;
21604 +  run;
21606 +  data &outdata;
21607 +       merge ds_fore ds_resid ds_act ds_lower ds_upper ds_std;
21608 +       by &tsidVar &timeid;
21609 +       label  FORECAST = "Forecast";
21610 +       label  ACTUAL = "Actual";
21611 +       label  RESIDUAL = "Residual";
21612 +       label  LBOUND = "Lower Bound";
21613 +       label  UBOUND = "Upper Bound";
21614 +       label   STD = "Standard Deviation";
21615 +  run;
21616 +%mend EM_TSESM_CreateOutFor;
21619 +%macro EM_TSESM_CreateOutExpand(indata=,
21620 +                       target=,
21621 +                       timeid=,
21622 +                       tsidVar=,
21623 +                       percent=,
21624 +                       outlower=,
21625 +                       outupper=,
21626 +                       outdata=);
21628 +  %let lowerBound = L&percent;
21629 +  %let upperBound = U&percent;
21631 +  /*proc print data=&indata(obs=200);
21632 +  run;
21633 +  */
21635 +  data ds_fore(drop=&target)
21636 +       ds_lower(drop=&target)
21637 +       ds_upper(drop=&target)
21638 +       ds_act;
21639 +     set &indata;
21640 +       if _TYPE_="FORECAST" and _LEAD_  > 0 then output ds_fore;
21641 +       if _TYPE_="&lowerBound" and  _LEAD_  > 0 then output ds_lower;
21642 +       if _TYPE_="&upperBound" and  _LEAD_  > 0 then output ds_upper;
21643 +       if _TYPE_="ACTUAL" then output ds_act;
21644 +  run;
21646 +  /*
21647 +  proc print data = ds_fore;
21648 +  proc print data=ds_act;
21649 +  run;
21650 +  */
21651 +  data &outdata;
21652 +       merge ds_act ds_fore;
21653 +       by &tsidVar &timeid;
21654 +  run;
21656 +  data &outlower;
21657 +       merge ds_act ds_lower;
21658 +       by &tsidVar &timeid;
21659 +  run;
21661 +  data &outupper;
21662 +       merge ds_act ds_upper;
21663 +       by &tsidVar &timeid;
21664 +  run;
21665 +  /*
21666 +  proc print data=&outdata(obs=300);
21667 +  proc print data=&outlower(obs=300);
21668 +  proc print data=&outupper(obs=300);
21669 +  run;
21670 +  */
21671 +%mend EM_TSESM_CreateOutExpand;
21675 +%macro EM_TSESM_MakeOutClus(indata=,
21676 +                   target=,
21677 +                   timeid=,
21678 +                   tsidVar=,
21679 +                   percent=,
21680 +                   outlower=,
21681 +                   outupper=,
21682 +                   outdata=);
21685 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
21687 +  data &outdata(rename=(_NAME_ =_NAMEID_));
21688 +       set &indata;
21689 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD;
21690 +  run;
21692 +  %let dsid=%sysfunc(open(&outdata));
21693 +  %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
21694 +  %let dsid=%sysfunc(close(&dsid));
21696 +  %if &vn_name > 0 %then %do;
21697 +      data &outdata(drop=_NAMEID_);
21698 +           merge &EM_USER_TSIDMAP &outdata;
21699 +           by _TSID_;
21700 +      run;
21701 +  %end;
21702 +  %else %do;
21703 +      proc sort data= &outdata; by _NAMEID_;
21704 +      run;
21705 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
21706 +      run;
21707 +      data &outdata(drop=_NAMEID_);
21708 +           merge &EM_USER_TSIDMAP &outdata;
21709 +           by _NAMEID_;
21710 +      run;
21711 +  %end;
21713 +%mend EM_TSESM_MakeOutClus;
21716 +%macro EM_TSESM_CreateOutEst(indata=,
21717 +                    target=,
21718 +                    timeid=,
21719 +                    outdata=);
21721 +%mend EM_TSESM_CreateOutEst;
21724 +%macro EM_TSESM_Best_Forecast(indata=,
21725 +                method=,
21726 +                timeinterval=,
21727 +                timeid= ,
21728 +                target= ,
21729 +                tsidvar=,
21730 +                lead=,
21731 +                back=,
21732 +                startsum=,
21733 +                accumulate=,
21734 +                seasonality=,
21735 +                alpha=,
21736 +                criterion=,
21737 +                extendedvalue=,
21738 +                outest = ,
21739 +                outdata = ,
21740 +                outfor = ,
21741 +                outstat = ,
21742 +                outsum=
21743 +   );
21745 +   %let _indata = &indata;
21747 +   %if &tsidvar eq _SEGMENT_ %then %do;
21748 +       proc sort data=&indata out=_tmpdata;
21749 +            by  &tsidvar %EM_CROSSID &timeid ;
21750 +       run;
21751 +       proc timeseries  data =_tmpdata out=_tmpdata;
21752 +            by  &tsidvar %EM_CROSSID ;
21753 +            id &timeid interval=&timeinterval accumulate=&accumulate;
21754 +            var &target / ;
21755 +       run;
21756 +       %let _indata = _tmpdata;
21757 +   %end;
21759 +   %let n_model = 0;
21761 +   %if &EM_PROPERTY_SIMPLE eq Y %then %do;
21763 +       %let n_model = %eval(&n_model+1);
21765 +       %let _ds_out =_out&n_model;
21766 +       %let _ds_outest =_outest&n_model;
21767 +       %let _ds_outfor =_outfor&n_model;
21768 +       %let _ds_outstat =_outstat&n_model;
21769 +       %let _ds_outsum=_outsum&n_model;
21771 +       %EM_TSESM_ESM(method=SIMPLE,
21772 +        timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21773 +        lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21774 +        out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21775 +        );
21777 +   %end;
21778 +   %if &EM_PROPERTY_DOUBLE eq Y %then %do;
21780 +       %let n_model = %eval(&n_model+1);
21782 +       %let _ds_out =_out&n_model;
21783 +       %let _ds_outest =_outest&n_model;
21784 +       %let _ds_outfor =_outfor&n_model;
21785 +       %let _ds_outstat =_outstat&n_model;
21786 +       %let _ds_outsum=_outsum&n_model;
21788 +       %EM_TSESM_ESM(method=DOUBLE,
21789 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21790 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21791 +             out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21792 +       );
21793 +   %end;
21795 +   %if &EM_PROPERTY_LINEAR eq Y %then %do;
21797 +       %let n_model = %eval(&n_model+1);
21798 +       %let _ds_out =_out&n_model;
21799 +       %let _ds_outest =_outest&n_model;
21800 +       %let _ds_outfor =_outfor&n_model;
21801 +       %let _ds_outstat =_outstat&n_model;
21802 +       %let _ds_outsum=_outsum&n_model;
21804 +       %EM_TSESM_ESM(method=LINEAR,
21805 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21806 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21807 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21808 +        );
21809 +   %end;
21811 +   %if &EM_PROPERTY_DAMPTREND eq Y %then %do;
21813 +       %let n_model = %eval(&n_model+1);
21815 +       %let _ds_out =_out&n_model;
21816 +       %let _ds_outest =_outest&n_model;
21817 +       %let _ds_outfor =_outfor&n_model;
21818 +       %let _ds_outstat =_outstat&n_model;
21819 +       %let _ds_outsum=_outsum&n_model;
21821 +       %EM_TSESM_ESM(method=DAMPTREND,
21822 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21823 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21824 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21825 +            );
21826 +   %end;
21827 +   /*------- Seasonal model ------*/
21829 +   %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do;
21831 +   %if (&EM_PROPERTY_WINTERS eq Y) %then %do;
21833 +       %let n_model = %eval(&n_model+1);
21835 +       %let _ds_out =_out&n_model;
21836 +       %let _ds_outest =_outest&n_model;
21837 +       %let _ds_outfor =_outfor&n_model;
21838 +       %let _ds_outstat =_outstat&n_model;
21839 +       %let _ds_outsum=_outsum&n_model;
21841 +       %EM_TSESM_ESM(method=WINTERS,
21842 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21843 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21844 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21845 +        );
21846 +   %end;
21848 +   %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then %do;
21850 +       %let n_model = %eval(&n_model+1);
21852 +       %let _ds_out =_out&n_model;
21853 +       %let _ds_outest =_outest&n_model;
21854 +       %let _ds_outfor =_outfor&n_model;
21855 +       %let _ds_outstat =_outstat&n_model;
21856 +       %let _ds_outsum=_outsum&n_model;
21858 +       %EM_TSESM_ESM(method=ADDSEASONAL,
21859 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21860 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21861 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21862 +       );
21863 +   %end;
21865 +   %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %do;
21867 +       %let n_model = %eval(&n_model+1);
21869 +       %let _ds_out =_out&n_model;
21870 +       %let _ds_outest =_outest&n_model;
21871 +       %let _ds_outfor =_outfor&n_model;
21872 +       %let _ds_outstat =_outstat&n_model;
21873 +       %let _ds_outsum=_outsum&n_model;
21875 +       %EM_TSESM_ESM(method=MULTSEASONAL,
21876 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21877 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21878 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21879 +       );
21880 +   %end;
21882 +   %if (&EM_PROPERTY_ADDWINTERS eq Y) %then %do;
21884 +       %let n_model = %eval(&n_model+1);
21886 +       %let _ds_out =_out&n_model;
21887 +       %let _ds_outest =_outest&n_model;
21888 +       %let _ds_outfor =_outfor&n_model;
21889 +       %let _ds_outstat =_outstat&n_model;
21890 +       %let _ds_outsum=_outsum&n_model;
21892 +       %EM_TSESM_ESM(method=ADDWINTERS,
21893 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21894 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21895 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21896 +            );
21897 +   %end;
21900 +   %end; /* end of %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do; */
21901 +   /*-------- end of seasonal model  ------------------------------------------------------*/
21903 +   %if &n_model eq 0 %then %do;
21905 +       /*---- %PUT  ERROR:THE NUMBER OF CANDIDATE MODELS IS ZERO;  */
21906 +       %let  EMEXCEPTIONSTRING = exception.server.tsdm.zerocandidatemodel;
21907 +   %end;
21908 +   %else %do;
21909 +         %EM_TSESM_BestModelSel(crit=&criterion,
21910 +                               n_mdl=&n_model,
21911 +                               tsidvar=&tsidvar,
21912 +                               timeid=&timeid,
21913 +                               out=&outdata,
21914 +                               outest=&outest,
21915 +                               outfor =&outfor,
21916 +                               outstat=&outstat,
21917 +                               outsum=&outsum
21918 +                  );
21919 +   %end;
21921 +%mend EM_TSESM_Best_Forecast;
21924 +%macro EM_TSESM_ESM(method= ,
21925 +           timeinterval=,
21926 +           timeid= ,
21927 +           target= ,
21928 +           tsidvar=,
21929 +           lead=,
21930 +           back=,
21931 +           startsum=,
21932 +           accumulate=,
21933 +           seasonality=,
21934 +           alpha=,
21935 +           out= ,
21936 +           outest= ,
21937 +           outfor= ,
21938 +           outstat= ,
21939 +           outsum=
21940 +           );
21942 +       proc sort data= &_indata out=_tmpdata;
21943 +            by  &tsidvar %EM_CROSSID &timeid ;
21944 +       run;
21945 +       proc esm data = _tmpdata  lead=&lead    back=&back  startsum=&startsum
21947 +       %if &seasonality ne DEFAULT %then %do;
21948 +                     seasonality = &seasonality
21949 +       %end;
21950 +            out=&out
21951 +            outest=&outest
21952 +            outfor =&outfor
21953 +            outstat=&outstat
21954 +            outsum= &outsum
21955 +            ;
21956 +       id &timeid  interval = &timeinterval  accumulate=&accumulate  ;
21958 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
21959 +            %if &target ne %then %do;
21960 +            forecast &target   /  model = none alpha=&alpha;
21961 +            %end;
21962 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21963 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha use=&extendedvalue;
21964 +            %end;
21965 +       %end;
21966 +       %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
21967 +            %if &target ne %then %do;
21968 +            forecast &target /  model =&method alpha=&alpha;
21969 +            %end;
21970 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21971 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
21972 +            %end;
21973 +       %end;
21974 +       %else %do;   /*----- CLUSTER INPUT , KLD, SIMILARITY INPUT ------*/
21975 +            %if &target ne %then %do;
21976 +            forecast &target   /  model = &method alpha=&alpha;
21977 +            %end;
21978 +            /*
21979 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21980 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha;
21981 +            %end;
21982 +            */
21983 +       %end;
21985 +       %if &tsidvar ne %then %do;
21986 +        by &tsidvar %EM_CROSSID;
21987 +       %end;
21988 +       run;
21990 +%mend EM_TSESM_ESM;
21994 +%macro EM_TSESM_BestModelSel(crit=,
21995 +                    n_mdl=,
21996 +                    tsidvar=_TSID_,
21997 +                    timeid=MNTH_YR,
21998 +                    out=&_outdata,
21999 +                    outest=&_outest,
22000 +                    outfor =&_outfor,
22001 +                    outstat=&_outstat,
22002 +                    outsum=&_outsum
22003 +    );
22005 +   %let statbls=select *, 1 as mdlID from _outstat1;
22006 +   %let estbls=select *,  1 as mdlID from _outest1;
22007 +   %let fortbls=select *, 1 as mdlID from _outfor1;
22008 +   %let outbls=select *,  1 as mdlID from _out1;
22009 +   %let sumtbls=select *, 1 as mdlID from _outsum1;
22010 +   %do i=2 %to &n_mdl;
22011 +      %let statbls=&statbls union all select *, &i as mdlID from _outstat&i;
22012 +        %let estbls=&estbls union all select *, &i as mdlID from _outest&i;
22013 +        %let fortbls=&fortbls union all select *, &i as mdlID from _outfor&i;
22014 +        %let outbls=&outbls union all select *, &i as mdlID from _out&i;
22015 +        %let sumtbls=&sumtbls union all select *, &i as mdlID from _outsum&i;
22016 +   %end;
22018 +   %let dsid=%sysfunc(open(_out1));
22019 +   %let vn_tsid = 0;
22021 +   %if &dsid > 0 %then %do;
22022 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22023 +         %let dsid = %sysfunc(close(&dsid));
22024 +   %end;
22026 +   %if &vn_tsid <= 0  %then %do;
22027 +       %let tsidvar=_NAME_;
22028 +   %end;
22030 +  /*
22031 +  %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
22032 +     %let tsidvar=_NAME_;
22033 +   %end;
22034 +  */
22036 +   proc sql;
22037 +     create table tsstat as &statbls;
22038 +     create table tsest  as &estbls;
22039 +     create table tsfor  as &fortbls;
22040 +     create table tsout  as &outbls;
22041 +     create table tssum  as &sumtbls;
22042 +   quit;
22044 +    proc sort data=tsstat out=bestmdl;
22045 +        by &tsidvar &crit mdlID;
22046 +    run;
22048 +    * when multiple BEST model found;
22049 +    * use the one with smallest model ID;
22050 +    data bestmdl;
22051 +        set bestmdl;
22052 +        by &tsIDvar;
22053 +        if first.&tsIDVar;
22054 +    run;
22056 +   proc sql;
22057 +      create table bestID as
22058 +        select distinct(tsest.&tsidvar), _model_, &crit, bestmdl.mdlID
22059 +        from bestmdl,tsest
22060 +        where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar;
22062 +      create table &outfor
22063 +        as select tsfor.*, _model_, &crit from tsfor, bestID
22064 +        where tsfor.&tsidvar=bestID.&tsidvar and tsfor.mdlID=bestID.mdlID order by &tsidvar, &timeid;
22066 +        create table &outstat
22067 +        as select tsstat.*, _model_ from tsstat, bestID
22068 +      where tsstat.&tsidvar=bestID.&tsidvar and tsstat.mdlID=bestID.mdlID order by &tsidvar;
22070 +        create table &outest
22071 +        as select tsest.*, &crit from bestmdl, tsest
22072 +      where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar order by &tsidvar;
22074 +      create table &outsum
22075 +        as select tssum.*, _model_, &crit from tssum, bestID
22076 +      where tssum.&tsidvar=bestID.&tsidvar and tssum.mdlID=bestID.mdlID order by &tsidvar;
22078 +      /*
22079 +      %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
22080 +        create table &out
22081 +          as select tsout.*, _model_, &crit from tsout, bestID
22082 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
22083 +      %end;
22084 +      */
22086 +      %if &tsidvar eq _TSID_ %then %do;
22088 +         create table &out
22089 +          as select tsout.*, _model_, &crit from tsout, bestID
22090 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
22092 +      %end;
22093 + run;
22094 +quit;
22096 + /*%if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
22098 + %if &tsidvar = _NAME_ %then %do;
22099 +      data
22100 +            %let i=1;
22101 +            %do i=1 %to &n_mdl;
22102 +               %let _tmpdsname = _tmpds&i;
22103 +                    &_tmpdsname
22104 +            %end;
22105 +        ;
22106 +         set work.Bestmdl;
22107 +            %let i=1;
22108 +            %do i=1 %to &n_mdl;
22109 +               %let _tmpdsname = _tmpds&i;
22110 +                  if mdlID = &i then output &_tmpdsname;
22111 +            %end;
22112 +      run;
22114 +      data &out;
22115 +           set _out1;
22116 +           keep &timeid %EM_TARGET;
22117 +      run;
22118 +      %let i=1;
22119 +      %do i=1 %to &n_mdl;
22120 +          %let _tmpdsname = _tmpds&i;
22121 +          %let _outdsname = _out&i;
22123 +          data &out;
22124 +               set &out;
22125 +               set &_outdsname(keep=
22126 +               %let dsid=%sysfunc(open(&_tmpdsname));
22127 +               %if &dsid > 0 %then %do;
22128 +                  %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
22129 +                  %do %while(^%sysfunc(fetch(&dsid)));
22130 +                     %let _name  = %sysfunc(getvarc(&dsid, &vn_name));
22131 +                          &_name
22132 +                  %end;
22133 +                  %let dsid = %sysfunc(close(&dsid));
22134 +               %end;
22135 +               );
22136 +           run;
22137 +       %end;
22139 +%end;
22141 +data &out;
22142 +     set  &out;
22143 +      drop mdlID _MODEL_ &crit;
22144 +data &outest;
22145 +      set  &outest;
22146 +      drop mdlID &crit;
22147 +data &outfor;
22148 +     set &outfor;
22149 +     drop mdlID &crit;
22150 +data &outstat;
22151 +     set &outstat;
22152 +     drop mdlID;
22153 +data &outsum;
22154 +     set &outsum;
22155 +     drop mdlID &crit;
22156 +run;
22158 +%mend EM_TSESM_BestModelSel;
22162 +%macro EM_TSESM_MakeOutlierIndex(indata=,
22163 +                        target=,
22164 +                        timeid=,
22165 +                        outoutlier=,
22166 +                        outlierds=,
22167 +                        outdata=);
22168 +%let label_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlier, noquote));
22169 +%let str_Actual_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actualoutlier, noquote));
22170 +%let str_Actual = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actual, noquote));
22171 +data &outdata;
22172 +     set &indata;
22173 +     length OutlierIndex 8.;
22174 +     length Outlier  $40;
22175 +     label  OutlierIndex = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlierindex, noquote))";
22176 +     label  Outlier = "&label_Outlier";
22177 +   /*  if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&label_Outlier";end;
22178 +       else  do; OutlierIndex=0; outlier =" "; end; */
22179 +     if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&str_Actual_Outlier";end;
22180 +       else  do; OutlierIndex=0; outlier ="&str_Actual"; end;
22181 +run;
22183 +data  &outoutlier;
22184 +      set  &outdata;
22185 +      keep &timeid _TSID_ _SEGMENT_ _NAME_ _NAMEID_ OUTLIERINDEX OUTLIER PREDICT;
22186 +      if ACTUAL = . then delete;
22187 +run;
22189 +data &outlierds;
22190 +     set &outoutlier;
22191 +     if OUTLIERINDEX = 0 then delete;
22192 +     Drop OUTLIERINDEX;
22193 +run;
22195 +%mend  EM_TSESM_MakeOutlierIndex;
22198 +%macro EM_TSESM_MakeSmoothedOutds(indata=,
22199 +                         inoutlierds=,
22200 +                         target=,
22201 +                         timeid=,
22202 +                         tsidvar=_TSID_,
22203 +                         replace=,
22204 +                         outdata=);
22207 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22210 +%let dsid=%sysfunc(open(&indata));
22211 +%let vn_tsid = 0;
22212 +%if &dsid > 0 %then %do;
22213 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22214 +         %let dsid = %sysfunc(close(&dsid));
22215 +%end;
22217 +%if &vn_tsid <= 0  %then %do;
22218 +    %let tsidvar=_NAME_;
22219 +%end;
22221 +%if &tsidvar = _TSID_ %then %do;
22222 +/* %if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
22223 + /*    data &outdata;
22224 +          merge &indata &inoutlierds;
22225 +          by _TSID_ &timeid;
22226 +          if OutlierIndex > 0 then
22227 +          %if &replace eq PREDICT %then %do;
22228 +             &target = PREDICT;
22229 +          %end;
22230 +          %else %do;
22231 +             &target = .;
22232 +          %end;
22233 +           Drop Predict _NAME_ OutlierIndex;
22234 +     run;     */
22235 +  %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
22236 +     %if &dsid > 0 %then %do;
22237 +         %let vn_nameid =%sysfunc(varnum(&dsid, _VARNAME_));
22238 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22239 +         %let i = 1;
22240 +              %do %while(^%sysfunc(fetch(&dsid)));
22241 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
22242 +                  %let _vartsid= %sysfunc(getvarn(&dsid, &vn_tsid));
22243 +                  %if &i eq 1 %then %do;
22244 +                      data _tmpoutlier;
22245 +                           set &inoutlierds;
22246 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid then output;
22247 +                      run;
22248 +                      data &outdata;
22249 +                           merge &indata _tmpoutlier;
22250 +                           by _TSID_ &timeid ;
22251 +                           if OutlierIndex  > 0 then
22252 +                              %if &replace eq PREDICT %then %do;
22253 +                                &_varname = PREDICT;
22254 +                              %end;
22255 +                              %else %do;
22256 +                                &_varname = .;
22257 +                              %end;
22258 +                            Drop Predict _NAME_  OutlierIndex Outlier;
22259 +                      run;
22260 +                   %end;
22261 +                   %else %do;
22262 +                      data _tmpoutlier;
22263 +                           set &inoutlierds;
22264 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid  then output;
22265 +                      run;
22266 +                      data &outdata;
22267 +                           merge &outdata _tmpoutlier;
22268 +                           by _TSID_ &timeid ;
22269 +                           if OutlierIndex  > 0 then
22270 +                              %if &replace eq PREDICT %then %do;
22271 +                                &_varname = PREDICT;
22272 +                              %end;
22273 +                              %else %do;
22274 +                                &_varname = .;
22275 +                              %end;
22276 +                           Drop Predict _NAME_  OutlierIndex Outlier;
22277 +                      run;
22278 +                   %end;
22279 +                   %let i = %eval(&i+1);
22281 +              %end;
22282 +           %let dsid = %sysfunc(close(&dsid));
22283 +      %end;
22284 +%end;
22285 +%else %do;  /*  %if &tsidvar = _NAME_ %then %do; */
22287 +     %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
22288 +     %if &dsid > 0 %then %do;
22289 +         %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
22290 +         %let i = 1;
22291 +              %do %while(^%sysfunc(fetch(&dsid)));
22292 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
22293 +                  %if &i eq 1 %then %do;
22294 +                      data _tmpoutlier;
22295 +                           set &inoutlierds;
22296 +                           if _NAME_ ="&_varname"  then output;
22297 +                      run;
22298 +                      data &outdata;
22299 +                           merge &indata _tmpoutlier;
22300 +                           by &timeid;
22301 +                           if OutlierIndex  > 0 then
22302 +                              %if &replace eq PREDICT %then %do;
22303 +                                &_varname = PREDICT;
22304 +                              %end;
22305 +                              %else %do;
22306 +                                &_varname = .;
22307 +                              %end;
22308 +                            Drop Predict _NAME_ OutlierIndex Outlier;
22309 +                      run;
22310 +                   %end;
22311 +                   %else %do;
22312 +                      data _tmpoutlier;
22313 +                           set &inoutlierds;
22314 +                           if _NAME_ ="&_varname"  then output;
22315 +                      run;
22316 +                      data &outdata;
22317 +                           merge &outdata _tmpoutlier;
22318 +                           by &timeid;
22319 +                           if OutlierIndex  > 0 then
22320 +                              %if &replace eq PREDICT %then %do;
22321 +                                &_varname = PREDICT;
22322 +                              %end;
22323 +                              %else %do;
22324 +                                &_varname = .;
22325 +                              %end;
22326 +                           Drop Predict _NAME_ OutlierIndex Outlier;
22327 +                      run;
22328 +                   %end;
22329 +                   %let i = %eval(&i+1);
22331 +              %end;
22332 +           %let dsid = %sysfunc(close(&dsid));
22333 +      %end;
22334 +      %else %do;
22335 +            /* this block is added 09022011*/
22336 +            /* works for wide table in which each time series has a column */
22338 +            proc transpose data=&indata out=_tmpdata1;
22339 +                by &timeID;
22340 +            run;
22342 +            proc sql;
22343 +                create table _tmpdata2 as
22344 +                    select a.*, b.outlierindex, b.outlier, b.predict
22345 +                        from _tmpdata1 as a left join &inoutlierds as b
22346 +                            on a.&timeID eq b.&timeID and a._name_ eq b._name_
22347 +                        order by a.&timeID, a._name_
22348 +                    ;
22349 +            quit;
22351 +            data _tmpdata2;
22352 +                set _tmpdata2;
22353 +                if outlierindex eq 1 then
22354 +                    if &replace eq PREDICT then col1=predict; else col1=.;
22355 +            run;
22357 +            proc transpose data=_tmpdata2 out=_tmpdata3(drop=_name_ _label_);
22358 +                by &timeID;
22359 +                ID _name_;
22360 +                var col1;
22361 +            proc sort data=&inoutlierds out=_tmpoutlier;
22362 +                by &timeID _name_;
22363 +            proc transpose data=_tmpoutlier out=_tmpdata4(drop=_name_ _label_) prefix=Outlier_;
22364 +                by &timeID;
22365 +                ID _name_;
22366 +                var outlier;
22367 +            run;
22369 +            data &outdata;
22370 +                merge _tmpdata3 _tmpdata4;
22371 +                by &timeID;
22372 +            run;
22373 +      %end;
22374 +%end;
22375 +%mend EM_TSESM_MakeSmoothedOutds;
22377 +%Macro EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
22378 +                  insumdata=&EM_USER_OUTSUM,
22379 +                target=&_targetVar,
22380 +                timeid=&_timeidVar,
22381 +                futurepoint=1,
22382 +                outKLD=&EM_USER_OUTKLD
22383 +                );
22385 +%if &futurepoint > 0 %then %do;
22387 +proc sort data=&indata out=_tmptimeid;
22388 +     by &timeid;
22389 +run;
22391 +data _tmptimeid(keep=&timeid);
22392 +      set _tmptimeid; by &timeid;
22393 +      if first.&timeid then output;
22394 +run;
22396 +%let _targetTime =;
22397 +%let dsid=%sysfunc(open(work._tmptimeid));
22398 +%if &dsid > 0 %then %do;
22399 +    %let vn_timeid =%sysfunc(varnum(&dsid, &timeid));
22400 +    %let i = 1;
22401 +    %do %while(^%sysfunc(fetch(&dsid)));
22402 +       %if &i eq &futurepoint %then %do;
22403 +       %let _targetTime  = %sysfunc(getvarn(&dsid, &vn_timeid));
22404 +       %end;
22405 +       %let i = %eval(&i+1);
22406 +    %end;
22407 +    %let dsid = %sysfunc(close(&dsid));
22408 +%end;
22410 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
22411 +   set &indata;
22412 +   if &timeid eq &_targetTime then output;
22413 +run;
22415 +%end;  /* end of %if &futurepoint > 0 %then %do; */
22416 +%else %do;
22419 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
22420 +   set &insumdata;
22421 +run;
22424 +%end;
22426 +%EM_TSESM_KLD(indata=work._tmpKLD, outdata=&outKLD);
22428 +/* Merge TSIDMAP  */
22430 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22431 +data &outKLD(rename=(_NAME_ =_NAMEID_));
22432 +       set &outKLD;
22433 +run;
22435 +%let dsid=%sysfunc(open(&outKLD));
22436 +%let vn_name =%sysfunc(varnum(&dsid, _TSID_));
22437 +%let dsid=%sysfunc(close(&dsid));
22439 +%if &vn_name > 0 %then %do;
22440 +      data &outKLD(drop=_NAMEID_);
22441 +           merge &EM_USER_TSIDMAP &outKLD;
22442 +           by _TSID_;
22443 +      run;
22444 +%end;
22445 +%else %do;
22446 +      proc sort data= &outKLD; by _NAMEID_;
22447 +      run;
22448 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
22449 +      run;
22450 +      data &outKLD(drop=_NAMEID_);
22451 +           merge &EM_USER_TSIDMAP &outKLD;
22452 +           by _NAMEID_;
22453 +      run;
22454 +%end;
22456 +/* delete _tmptimeid  _tmpKLD */
22457 +%Mend  EM_TSESM_MakeOutKLD;
22460 +%Macro EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
22461 +                 target=&_targetVar,
22462 +                 timeid=&_timeidVar,
22463 +                 outdata=&EM_USER_OUTPRED
22464 +                 );
22466 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
22467 +%let _EndTime = ;
22468 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
22469 +%if &dsid > 0 %then %do;
22470 +    %let vn_end =%sysfunc(varnum(&dsid, END));
22471 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
22472 +    %do %while(^%sysfunc(fetch(&dsid)));
22473 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
22474 +       /*--------------------------------------------------------
22475 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
22476 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
22477 +        ---------------------------------------------------------*/
22478 +    %end;
22479 +    %let dsid = %sysfunc(close(&dsid));
22480 +%end;
22482 +data &outdata(keep= _TSID_ _NAME_  &timeid PREDICT LOWER UPPER STD);
22483 +     set &indata;
22484 +     if &timeid > &_EndTime then output;
22485 +run;
22486 +%Mend  EM_TSESM_MakeOutPred;
22489 +%macro EM_TSESM_KLD(indata=work._tmp, outdata=_out);
22491 +%let std_x = ;
22492 +%let mu_y = ;
22494 +%let dsid=%sysfunc(open(&indata));
22495 +%if &dsid > 0 %then %do;
22496 +    %let vn_pred =%sysfunc(varnum(&dsid, PREDICT));
22497 +    %let vn_std  = %sysfunc(varnum(&dsid, STD));
22498 +    %let i=1;
22499 +    %do %while(^%sysfunc(fetch(&dsid)));
22500 +        %let _pred  = %sysfunc(getvarn(&dsid, &vn_pred));
22501 +        %let _std  = %sysfunc(getvarn(&dsid, &vn_std));
22502 +        %let _tsid = _TSID&i.;
22503 +        /* create new data set */
22504 +            %if &i = 1 %then %do;
22505 +            data _tmpindata;
22506 +                set &indata;
22507 +                  mu_x = &_pred;
22508 +                  std_x = &_std;
22509 +                  rename predict = mu_y;
22510 +                  rename std = std_y;
22511 +            run;
22512 +        data _tmpout;
22513 +                 set _tmpindata;
22514 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
22515 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
22516 +             &_tsid= (KLD1+KLD2)/2;
22517 +             if &_tsid < 0 then &_tsid = 0;
22518 +                   drop KLD1 KLD2;
22519 +         run;
22520 +             %end;
22521 +         %else %do;
22522 +         data _tmpindata;
22523 +                  set _tmpout;
22524 +                  mu_x = &_pred;
22525 +                  std_x = &_std;
22527 +             run;
22528 +         data _tmpout;
22529 +                 set _tmpindata;
22530 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
22531 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
22532 +             &_tsid= (KLD1+KLD2)/2;
22533 +             if &_tsid < 0 then &_tsid = 0;
22534 +                   drop KLD1 KLD2;
22535 +         run;
22537 +         %end;
22538 +             %let i = %eval(&i+1);
22540 +    %end;
22541 +    %let dsid = %sysfunc(close(&dsid));
22542 +    data &outdata;
22543 +         set _tmpout;
22544 +         drop mu_x mu_y std_x std_y;
22545 +    run;
22546 +%end;
22547 +%mend EM_TSESM_KLD;
22550 +%macro EM_TSESM_MakeOutClusInput(indata=,
22551 +                   target=,
22552 +                   timeid=,
22553 +                   tsidVar=,
22554 +                   percent=,
22555 +                   outlower=,
22556 +                   outupper=,
22557 +                   esmmethod=,
22558 +                   criterion=,
22559 +                   outdata=);
22561 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22563 +  data &outdata(rename=(_NAME_ =_NAMEID_));
22564 +       set &indata;
22565 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
22566 +  %if &esmmethod eq BEST %then %do;
22567 +      mdlID _MODEL_ &criterion
22569 +  %end;
22570 +  ;
22571 +  run;
22573 +  %let dsid=%sysfunc(open(&outdata));
22574 +       %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
22575 +  %let dsid=%sysfunc(close(&dsid));
22577 +  %if &vn_name > 0 %then %do;
22578 +      proc sort data= &outdata; by _TSID_;
22579 +      run;
22580 +      proc sort data = &EM_USER_TSIDMAP ;by _TSID_;
22581 +      run;
22583 +      data &outdata(drop=_NAMEID_);
22584 +           merge &EM_USER_TSIDMAP &outdata;
22585 +           by _TSID_;
22586 +      run;
22587 +  %end;
22588 +  %else %do;
22589 +      proc sort data= &outdata; by _NAMEID_;
22590 +      run;
22591 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
22592 +      run;
22593 +      data &outdata(drop=_NAMEID_);
22594 +           merge &EM_USER_TSIDMAP &outdata;
22595 +           by _NAMEID_;
22596 +      run;
22597 +  %end;
22599 +%mend EM_TSESM_MakeOutClusInput;
22601 +%macro EM_TSESM_MakeOutSimInput(indata=,
22602 +                   inoutfor=,
22603 +                   target=,
22604 +                   timeid=,
22605 +                   tsidVar=,
22606 +                   esmmethod=,
22607 +                   criterion=,
22608 +                   outdata=);
22611 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22612 +  %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
22614 +   %let _EndTime = ;
22615 +   %let dsid=%sysfunc(open(&EM_USER_TSMETA));
22616 +   %if &dsid > 0 %then %do;
22617 +   %let vn_end =%sysfunc(varnum(&dsid, END));
22618 +   %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
22619 +   %do %while(^%sysfunc(fetch(&dsid)));
22620 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
22621 +   %end;
22622 +   %let dsid = %sysfunc(close(&dsid));
22623 +   %end;
22625 +   %em_varMacro(name=tsesm_crossid, metadata= &EM_DATA_VARIABLESET, key=NAME,
22626 +       where=%nrbquote(ROLE='CROSSID' and USE ne 'N') , nummacro=tsesm_crossidNum);
22628 +   data _out1;
22629 +       set &indata;
22630 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
22631 +           %tsesm_crossid
22632 +   %if &esmmethod eq BEST %then %do;
22633 +      mdlID _MODEL_ &criterion
22634 +   %end;
22635 +   ;
22636 +   run;
22638 +    %let dsid=%sysfunc(open(work._out1));
22639 +    %if &dsid > 0 %then %do;
22640 +      %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22641 +      %let dsid = %sysfunc(close(&dsid));
22642 +    %end;
22644 +    /*
22645 +    proc print data=_out1(obs=10);
22646 +    run;
22647 +    */
22648 +    %let _existtsid = Y;
22649 +    %if (&vn_tsid = 0)  %then %do;
22650 +    %let _existtsid = N;
22651 +    %goto NO_TSID_SIMINPUT;
22652 +    %end;
22654 +    data _out1;
22655 +        set _out1;
22656 +        where _name_ = "&target";
22657 +    run;
22658 +    %let target2 = &target._;
22659 +    proc transpose data=_out1 out=_out2 prefix=&target2;
22660 +            id _TSID_  ;
22661 +    run;
22662 +    /*
22663 +    proc print data=_out2(obs=11);
22664 +    run;
22665 +    */
22666 +    data _out2;
22667 +       length _index 8.;
22668 +       set _out2;
22669 +       _index=_N_;
22670 +       drop _NAME_ _LABEL_;
22671 +    run;
22674 +   data _out3;
22675 +       length _index 8.;
22676 +        set &inoutfor(where=(_TSID_=1 and &timeid > &_EndTime));
22677 +         _index =_N_;
22678 +        keep &timeid _index;
22680 +   run;
22681 +   /*
22682 +   proc print data=_out2(obs=12);
22683 +   proc print data =_out3(obs=13);
22684 +   run;
22685 +   */
22686 +   data &outdata(drop=_index);
22687 +        merge _out3 _out2;by _index;
22688 +        run;
22691 +  proc transpose data=&outdata out=_tout;
22692 +     id &timeid;
22693 +   run;
22694 +   data _tout;
22695 +        length _TSID_ 8.;
22696 +        set _tout;
22697 +        rename _NAME_= _NAMEID_;
22698 +        _TSID_ = _N_;
22699 +        label _NAME_ = "NAMEID";
22700 +        keep _NAME_ _TSID_;
22702 +   run;
22704 +   data &EM_USER_TSIDMAP;
22705 +        merge  _tout  &EM_USER_TSIDMAP; by _TSID_;
22706 +   run;
22707 +   /*
22708 +   proc print data=_tout(obs=14);
22709 +   run;
22710 +   */
22711 +   proc datasets lib=work nolist;
22712 +      delete  _out1 _tmpout1 _out2 _out3 _tout;
22713 +   run;
22716 +   %NO_TSID_SIMINPUT:
22717 +   %if  &_existtsid eq N %then %do;
22718 +   data &outdata;
22719 +        set &inoutfor(where=(&timeid > &_EndTime));
22720 +   run;
22721 +   %end;
22724 +%mend EM_TSESM_MakeOutSimInput;
22727 +%macro EM_TS_CONVERT_LONG_TO_WIDE(indata=, outdata=, wherevar=, nwherevalue=, targetvar=, timeid=);
22728 +%do i=1 %to &nwherevalue;
22729 +     %if &i = 1 %then %do;
22730 +        data &outdata(drop = &wherevar);
22731 +             set &indata;
22732 +               if &wherevar= &i;
22733 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
22734 +               %else %let newname = &wherevar_&i;
22735 +                rename  &targetvar= &newname;
22736 +                   label &targetvar ="&targetvar._&i";
22737 +           run;
22738 +       %end;
22739 +       %else %do;
22740 +        data _tmp_out(drop = &wherevar);
22741 +             set &indata;
22742 +               if &wherevar= &i;
22743 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
22744 +               %else %let newname = &wherevar_&i;
22745 +                rename  &targetvar= &newname;
22746 +                   label &targetvar ="&targetvar._&i";
22747 +           run;
22748 +             data &outdata;
22749 +                  merge &outdata  _tmp_out; by &timeid;
22750 +         run;
22751 +       %end;
22752 +%end;
22754 +%EM_TS_DELETE_DATA(lib=work, data=_tmp_out);
22756 +%mend EM_TS_CONVERT_LONG_TO_WIDE;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
22758 +/*
22759 +       MACRO: TS Utility macros
22761 +       PURPOSE: TS Utility macros
22762 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
22764 +       HISTORY:
22765 +       NOTE:
22767 +*/
22769 +/*
22770 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
22771 +                          timeid=, timeformat=, timeinformat=);
22772 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
22774 +    %do;
22775 +    %let m_data      = &data;
22776 +    %let m_decdata   = &decdata;
22777 +    %let m_decmeta   = &decmeta;
22778 +    %let m_cmeta     = &cmeta;
22779 +    %let m_outfile   = &outfile;
22780 +    %let m_crossid   = &crossid;
22781 +    %let m_timeid    = &timeid;
22782 +    %let m_timeformat    = &timeformat;
22783 +    %let m_timeinformat    = &timeinformat;
22784 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
22785 +  %end;
22786 +%mend EM_TS_CreateTsMetaDs;
22787 +*/
22788 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
22789 +proc sql;
22790 +      create table _tmp_inds
22791 +      as select distinct &timeid from  &indata;
22792 +quit;
22793 +run;
22794 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
22795 +  id &timeid
22796 +%if &timeinterval ne %then %do;
22797 +    %if &timeformattype eq DATE %then %do;
22798 +        interval=&timeinterval
22799 +    %end;
22800 +    %else %if &timeformattype eq DATETIME  %then %do;
22801 +        %let dttimeinterval= DT&timeinterval;
22802 +         interval=&dttimeinterval
22803 +    %end;
22804 +%end;
22805 +;
22806 +run;
22808 +data &outds;
22809 +     set _tmp_tsmeta;
22810 +     format START &timeformat;
22811 +     format END &timeformat;
22812 +     length APPLY_START_END $8;
22813 +     APPLY_START_END ="No";
22814 +     FORMAT = "&timeformat";
22815 +     ROLE ="TIMEID";
22816 +     rename TIMEID = NAME;
22817 +     rename SEASONALITY= LengthOfCycle;
22818 +     rename INTERVAL = TIMEINTERVAL ;
22819 +     rename FORMAT = TIMEFORMAT;
22820 +     output;
22821 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
22822 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
22823 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
22824 +run;
22826 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
22827 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
22829 +%mend EM_TS_CreateTSMetaData;
22833 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
22835 +/* if updated = Y it will pass the TSMETA created by just the previous node */
22837 +%let _tsmetads = ;
22839 +%if &updated = Y %then %do;
22840 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
22841 +%if %sysfunc(exist(&_tsmetads)) %then %do;
22842 +%goto endline;
22843 +%end;
22844 +%end;
22846 +%if &eminfodata eq %then %do;
22847 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
22848 +    data &EM_DATA_EMINFO;
22849 +         set &EM_IMPORT_DATA_EMINFO;
22850 +    run;
22851 +%end;
22852 +%else %do;
22853 +    %let dsid=%sysfunc(open(&eminfodata));
22854 +    data &EM_DATA_EMINFO;
22855 +         set &eminfodata;
22856 +    run;
22857 +%end;
22858 +%if &dsid > 0 %then %do;
22859 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
22860 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
22861 +    %do %while(^ %sysfunc(fetch(&dsid)));
22862 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
22863 +         %if &_key eq TSMETA %then %do;
22864 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
22865 +         %end;
22866 +    %end;
22867 +    %let dsid = %sysfunc(close(&dsid));
22868 +%end; /* the end of %if &dsid > 0 %then %do; */
22870 +%endline:
22872 +%if &_tsmetads ne %then %do;
22873 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
22874 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
22875 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
22876 +         data &EM_USER_TSMETA;
22877 +                   set &_tsmetads;
22878 +         run;
22879 +    %end;
22880 +%end;
22882 +*proc print data=&EM_DATA_EMINFO;
22883 +*proc print data=&EM_IMPORT_DATA_EMINFO;
22884 +*run;
22885 +%MEND EM_TS_GETTSMETA;
22888 +/*
22889 +%macro EM_GETTSMETAVARS(TimeInterval=);
22890 +%global &TimeInterval;
22891 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
22892 +%if &dsid > 0 %then %do;
22893 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
22894 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
22895 +%do %while(^ %sysfunc(fetch(&dsid)));
22896 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22897 +     %if &_role eq TIMEID %then %do;
22898 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
22899 +     %end;
22900 +%end;
22901 +%let dsid = %sysfunc(close(&dsid));
22902 +%end;
22903 +%MEND EM_GETTSMETAVARS;
22904 +*/
22905 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
22906 +%global &TimeInterval;
22907 +%global &TimeId;
22908 +%global &EndTime;
22909 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
22910 +proc print data=&EM_USER_TSMETA;
22911 +run;
22912 +%if &dsid > 0 %then %do;
22913 +%if &TimeInterval ne %then %do;
22914 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
22915 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
22916 +    %do %while(^ %sysfunc(fetch(&dsid)));
22917 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22918 +        %if &_role eq TIMEID %then %do;
22919 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
22920 +        %end;
22921 +     %end;
22922 +%end;
22923 +%if &TimeId ne %then %do;
22924 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
22925 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
22926 +    %do %while(^ %sysfunc(fetch(&dsid)));
22927 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22928 +        %if &_role eq TIMEID %then %do;
22929 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
22930 +        %end;
22931 +    %end;
22932 +%end;
22934 +%if &EndTime ne %then %do;
22935 +    %let vn_end =%sysfunc(varnum(&dsid, END));
22936 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
22937 +    %do %while(^ %sysfunc(fetch(&dsid)));
22938 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22939 +        %if &_role eq TIMEID %then %do;
22940 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
22941 +        %end;
22942 +     %end;
22943 +%end;
22944 +%let dsid = %sysfunc(close(&dsid));
22945 +%end;
22946 +%MEND EM_TS_GETTSMETAVARS;
22950 +/*------------------------------------------------------------------
22952 +      Macro EM_GETTSIDMAP
22954 +------------------------------------------------------------------+*/
22957 +%macro EM_TS_GETTSIDMAP(updated=);
22959 +%let _tsidmap = ;
22961 +%if &updated = Y %then %do;
22962 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
22963 +%if %sysfunc(exist(&_tsidmap)) %then %do;
22964 +%goto endline;
22965 +%end;
22966 +%end;
22968 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
22969 +%if &dsid > 0 %then %do;
22970 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
22971 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
22972 +%do %while(^ %sysfunc(fetch(&dsid)));
22973 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
22974 +     %if &_key eq TSIDMAP %then %do;
22975 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
22976 +     %end;
22977 +%end;
22979 +%let dsid = %sysfunc(close(&dsid));
22980 +%end;
22982 +%endline:
22984 +%if &_tsidmap ne %then %do;
22986 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
22987 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22989 +%if %sysfunc(exist(&_tsidmap)) %then %do;
22990 +         data &EM_USER_TSIDMAP;
22991 +               set &_tsidmap;
22992 +         run;
22993 +    %end;
22994 +%end;
22995 +%MEND EM_TS_GETTSIDMAP;
22997 +/*------------------------------------------------------------------*/
23002 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
23003 +%global &value;
23006 +%let dsid = %sysfunc(open(&data));
23007 +%if &dsid > 0 %then %do;
23008 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
23009 +    %if &vn_var < 1 %then %do;
23010 +        %let &value = 0;
23011 +        %let dsid = %sysfunc(close(&dsid));
23012 +        %goto endline;
23013 +    %end;
23014 +%let dsid = %sysfunc(close(&dsid));
23015 +%end;
23017 +%let _tmp=_tmpDS;
23018 +proc means data=&data &stat;
23019 +     var &var;
23020 +     output out=&_tmp;
23021 +run;
23023 +%let dsid = %sysfunc(open(&_tmp));
23024 +%if &dsid > 0 %then %do;
23025 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
23026 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
23027 +     %do %while(^%sysfunc(fetch(&dsid)));
23028 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
23029 +         %if &_stat eq &stat %then %do;
23030 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
23031 +          %end;
23032 +      %end;
23033 +%let dsid = %sysfunc(close(&dsid));
23034 +%end;
23035 +proc datasets lib=work nolist;
23036 + delete &_tmp;
23037 +run;
23038 +%endline:
23039 +%MEND EM_TS_GET_STAT;
23042 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
23043 +%global &format;
23044 +%global &informat;
23045 +%let dsid = %sysfunc(open(&data));
23046 +%if &dsid > 0 %then %do;
23047 +%let vn_var =%sysfunc(varnum(&dsid, &var));
23048 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
23049 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
23050 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
23051 +%end;
23052 +%let dsid = %sysfunc(close(&dsid));
23053 +%end;
23054 +%MEND EM_TS_GET_VAR_FORMAT;
23056 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
23057 +      %if &lib eq %then %let lib=work;
23058 +       proc datasets lib=&lib nolist;
23059 +              delete &dsname;
23060 +       run;
23061 +%Mend  EM_TS_DELETE_DATA;
23064 +%macro EM_TS_GetNObs(inds=, nobs=);
23065 +    %global &nobs;
23066 +    %let &nobs=0;
23067 +    data _null_;
23068 +        set &inds end=eof;
23069 +        if eof then call symput("&nobs", _N_);
23070 +    run;
23071 +    quit;
23073 +    /*
23074 +    %let dsid=%sysfunc(open(&outdata));
23075 +    %if dsid > 0 %then %do;
23076 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
23077 +        %let dsid = %sysfunc(close(&dsid));
23078 +     %end;
23079 +    */
23080 +%mend  EM_TS_GetNObs;
23083 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
23084 +%global &time1;
23085 +%global &time2;
23086 +%if &default = Y %then %do;
23087 +   data _null_;
23088 +        set &data end=eof;
23089 +        if _N_ = 1 then  call symput("&time1", DATE);
23090 +        if eof then call symput("&time2", DATE);
23091 +    run;%end;
23092 +%else %do;
23093 +    %let dsid = %sysfunc(open(&data));
23094 +    %if &dsid > 0 %then %do;
23095 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
23096 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
23097 +        %do %while(^%sysfunc(fetch(&dsid)));
23098 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
23099 +             %if &_index eq 1 %then %do;
23100 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
23101 +             %end;
23102 +             %if &_index eq 2 %then %do;
23103 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
23104 +             %end;
23105 +        %end;
23106 +    %let dsid = %sysfunc(close(&dsid));
23107 +    %end;
23108 +%end;
23110 +%MEND EM_TS_GET_TIME_VALUES;
23112 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
23113 +%global &exist;
23114 + %let &exist = N;
23115 +%let dsid = %sysfunc(open(&data));
23116 +%if &dsid > 0 %then %do;
23117 +%let vn_var =%sysfunc(varnum(&dsid, &var));
23118 +%if &vn_var > 0 %then %do;
23119 +    %let &exist = Y;
23120 +%end;
23121 +%let dsid = %sysfunc(close(&dsid));
23122 +%end;
23123 +%MEND EM_TS_GET_VAR_EXIST;
23126 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
23127 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
23128 +      set &intreedata;
23129 +        LENGTH NodeType $32;
23130 +      if _PARENT_ eq " " then delete;
23131 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
23132 +        else NodeType = "CLUSTER";
23133 +        LinkID = _N_;
23134 +run;
23135 +%Mend EM_TS_MakeConstellPlotData;
23140 +%macro EM_TS_CreateIDMap(
23141 +/*-------------------------------------------------------------------------*/
23142 +/*---   Written by Xiangxiang Meng                                         */
23143 +/*-------------------------------------------------------------------------*/
23144 +inDS          =,      /* imported data set in TS data mining               */
23145 +outIDMap      =,      /* output data set of TS ID map                      */
23146 +outDS         =,      /* output data set of TS and TS ID merged            */
23147 +variableSet   =,      /* EM variable set                                   */
23148 +TSIDbyCrossID =Y,
23149 +inEM          =Y
23150 +/*-------------------------------------------------------------------------*/
23151 +);
23153 +%global EM_TS_ERR;
23154 +%let EM_TS_ERR = 0;
23156 +%if &inEM eq Y %then %do;
23157 +    %let num_crossIDVar = &EM_NUM_CROSSID;
23158 +    proc sql noprint;
23159 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
23160 +    quit;
23161 +%end;
23162 +%else %do;
23163 +    proc sql noprint;
23164 +         select count(*) into :num_crossIDVar from &variableSet
23165 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23166 +         ;
23167 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
23168 +         ;
23169 +    quit;
23170 +    %let num_crossIDVar=&num_crossIDVar;
23171 +%end;
23173 +* see if _TSID_ exists;
23175 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
23176 +run;
23178 +proc sql noprint;
23179 +    select count(*) into :has_TSID
23180 +        from _emtscm_contents
23181 +        where upcase(strip(name)) eq '_TSID_'
23182 +    ;
23183 +quit;
23185 +/*-------------------------------------------------------------------------*/
23186 +* Creating TSID map..;
23187 +/*-------------------------------------------------------------------------*/
23189 +%if (&num_crossIDVar gt 0) %then %do;
23191 +    data _emtscm_tmpIDMap;
23192 +        set &variableSet;
23193 +        where  (upcase(strip(level)) eq 'INTERVAL')
23194 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
23195 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
23196 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
23197 +          );
23198 +        _emts_dummy=1;
23199 +        keep name label role _emts_dummy;
23200 +    run;
23202 +    proc sql noprint;
23203 +        * create a string of crossID variable like A,B,C,D..;
23204 +        select distinct name into :crossIDVar separated by ','
23205 +            from &variableSet
23206 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23207 +            order by name
23208 +        ;
23209 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
23210 +            from &variableSet
23211 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23212 +            order by name
23213 +        ;
23214 +        * create the TSID map data set;
23215 +        create table _emtscm_tmp1 as
23216 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
23217 +        ;
23218 +        * create a level list of cross ID variables and time series variables;
23219 +        create table &outIDMap as
23220 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
23221 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
23222 +            where a._emts_dummy eq b._emts_dummy
23223 +            order by a.name, &crossIDVar
23224 +        ;
23225 +    quit;
23227 +    %if &TSIDbyCrossID = Y %then %do;
23228 +        * create unique TSID only by Cross ID;
23229 +        data &outIDMap;
23230 +            length _TSID_ 8;
23231 +            set &outIDMap;
23232 +            by _NAMEID_;
23233 +            if first._NAMEID_
23234 +                then _TSID_=1;
23235 +                else _TSID_+1;
23236 +        run;
23237 +        %if "&outDS" ne "" %then %do;
23238 +            * merge TSID into &inDS;
23239 +            proc sql noprint;
23240 +                create table &outDS as
23241 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
23242 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
23243 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
23244 +                        where %do i = 1 %to &num_crossIDVar;
23245 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
23246 +                              %end;
23247 +                             b._TSID_ is not missing
23248 +                    order by b._TSID_, a.&timeIDVar
23249 +                ;
23250 +            quit;
23251 +        %end;
23252 +    %end;
23253 +    %else %do;
23254 +        * create unique TSID by Cross ID and _NAMEID_;
23255 +        data &outIDMap;
23256 +            length _TSID_ 8;
23257 +            set &outIDMap;
23258 +            _TSID_=_n_;
23259 +        run;
23260 +        %if "&outDS" ne "" %then %do;
23261 +            *no merge in this output;
23262 +            data &outDS;
23263 +                set &inDS;
23264 +            run;
23265 +        %end;
23266 +    %end;
23268 +    proc sort data=&outIDMap;
23269 +        by _NAMEID_ _TSID_;
23270 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
23271 +        format _TSID_ best12. _NAMEID2_ $40.;
23272 +        set &outIDMap;
23273 +        by _NAMEID_;
23274 +        if first._NAMEID_
23275 +            then _emts_ind=1;
23276 +            else _emts_ind+1;
23277 +        drop _emts_ind;
23278 +        rename _NAMEID_=_VARNAME_;
23279 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
23280 +        if _labelID_ eq ' '
23281 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
23282 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
23283 +    run;
23285 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
23287 +%end;
23288 +%else %do; /* if no crossid's the nameid needs to be created */
23290 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
23291 +        length _TSID_ 8;
23292 +        set &variableSet;
23293 +        where  (upcase(strip(level)) eq 'INTERVAL')
23294 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
23295 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
23296 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
23297 +          );
23298 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
23299 +        rename ROLE = _ROLE_;
23300 +        _NAMEID_=strip(name);
23301 +        _VARNAME_=strip(name);
23302 +        if label eq ' '
23303 +            then _LABELID_ = strip(name);
23304 +            else _LABELID_ = strip(label);
23305 +        _TSID_=_n_;
23306 +    run;
23308 +    %if "&outDS" ne "" %then %do;
23309 +        *no merge in this output;
23310 +        data &outDS;
23311 +            set &inDS;
23312 +        run;
23313 +    %end;
23314 +%end;
23316 +data &outIDMap;
23317 +    set &outIDMap;
23318 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
23319 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
23320 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
23321 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
23322 +run;
23324 +proc datasets lib=work nolist;
23325 +    delete _emtscm_:;
23326 +run; quit;
23328 +%mend EM_TS_createIDMap;
23330 +%macro EM_TS_CreateMetaData(
23331 +/*-------------------------------------------------------------------------*/
23332 +  inDS          =,      /* imported data set in TS data mining             */
23333 +  outDS         =,      /* output data set of TS metadata                  */
23334 +  variableSet   =,      /* EM variable set                                 */
23335 +  timeInterval  =,      /* time interval                                   */
23336 +  rc            =       /* return code                                     */
23337 +/*-------------------------------------------------------------------------*/
23338 +);
23340 +%if %eval(
23341 +      &EM_NUM_BINARY_INPUT   +
23342 +      &EM_NUM_ORDINAL_INPUT  +
23343 +      &EM_NUM_NOMINAL_INPUT  +
23344 +      &EM_NUM_BINARY_REJECTED   +
23345 +      &EM_NUM_ORDINAL_REJECTED  +
23346 +      &EM_NUM_NOMINAL_REJECTED  +
23347 +      &EM_NUM_ORDINAL_TARGET  +
23348 +      &EM_NUM_NOMINAL_TARGET +
23349 +      &EM_NUM_BINARY_TARGET
23350 +      ) > 0
23351 +%then %do;
23352 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
23353 +        %put &em_codebar;
23354 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
23355 +        %put &errormsg;
23356 +        %put &em_codebar;
23357 +        %goto ENDLINE;
23358 +%end;
23360 +%global EM_TS_ERR;
23361 +%let EM_TS_ERR = 0;
23363 +%if &timeInterval eq AUTO
23364 +    %then %let timeInterval  = ;
23365 +    %else %let timeInterval  = %upcase(&timeInterval);
23367 +/*-------------------------------------------------------------------------*/
23368 +* check time ID variable;
23369 +/*-------------------------------------------------------------------------*/
23371 +* number of variables in the Variableset with ROLE=TIMEID;
23372 +proc sql noprint;
23373 +    select count(*) into :num_timeID from &variableset
23374 +        where upcase(role) eq 'TIMEID';
23375 +quit;
23377 +/*-------------------------------------------------------------------------*/
23378 +* process only when there is one Time ID, otherwise exception message;
23379 +/*-------------------------------------------------------------------------*/
23381 +%if &num_timeID eq 0 %then %do;
23383 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
23384 +    %let EM_TS_ERR = 11;
23385 +    %put &em_codebar;
23386 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
23387 +    %put &errormsg;
23388 +    %put &em_codebar;
23389 +    %goto tscm_endline;
23391 +%end;
23392 +%else %if &num_timeID gt 1 %then %do;
23394 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
23395 +    %let EM_TS_ERR = 12;
23396 +    %put &em_codebar;
23397 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
23398 +    %put &errormsg;
23399 +    %put &em_codebar;
23400 +    %goto tscm_endline;
23402 +%end;
23403 +%else %do;
23404 +    *** proceed when there is one Time ID;
23406 +    data _null_;
23407 +        set &variableset(where=(upcase(role)='TIMEID'));
23408 +        call symput('timeIDFormat',     strip(format));
23409 +        call symput('timeID',           strip(upcase(name)      ));
23410 +        call symput('timeIDLevel',      strip(upcase(level))     );
23411 +        call symput('timeIDFormatType', strip(upcase(formattype)));
23412 +    run;
23414 +    *** exception message if the time ID is not an interval variable;
23415 +    %if &timeIDLevel ne INTERVAL %then %do;
23416 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
23417 +        %let EM_TS_ERR = 13;
23418 +        %put &em_codebar;
23419 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
23420 +        %put &errormsg;
23421 +        %put &em_codebar;
23422 +        %goto tscm_endline;
23423 +    %end;
23425 +    %if (&timeIDFormatType ne DATETIME) and
23426 +        (&timeIDFormatType ne DATE) and
23427 +        (&timeIDFormatType ne TIME) and
23428 +        (&timeIDFormatType ne USER)
23429 +    %then %do;
23430 +        *** sequential format-type of time ID;
23432 +        %let timeInterval = DAY;
23433 +        %let timeIDFormatType = SEQ;
23435 +        proc sql noprint;
23436 +            create table _emtscm_inds as
23437 +                 select distinct &timeID from &inDS(keep=&timeID)
23438 +                 where &timeID is not missing;
23439 +            select count(*) into :num_nonInteger from _emtscm_inds
23440 +                where &timeID ne int(&timeID);
23441 +        quit;
23443 +        %if &num_nonInteger gt 0 %then %do;
23444 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
23445 +            %let EM_TS_ERR = 14;
23446 +            %put &em_codebar;
23447 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
23448 +            %put &errormsg;
23449 +            %put &em_codebar;
23450 +            %goto tscm_endline;
23451 +        %end;
23452 +    %end;
23453 +    %else %do;
23454 +        *** date, datetime, time format-type of time ID;
23456 +        *** must have a format;
23457 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
23458 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
23459 +            %let EM_TS_ERR = 15;
23460 +            %put &em_codebar;
23461 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
23462 +            %put &errormsg;
23463 +            %put &em_codebar;
23464 +            %goto tscm_endline;
23465 +        %end;
23467 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
23468 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
23469 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
23470 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
23471 +                %let EM_TS_ERR = 16;
23472 +                %put &em_codebar;
23473 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
23474 +                %put &errormsg;
23475 +                %put &em_codebar;
23476 +                %goto tscm_endline;
23477 +            %end;
23478 +        %end;
23480 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
23481 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
23482 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
23483 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
23484 +                %let EM_TS_ERR = 17;
23485 +                %put &em_codebar;
23486 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
23487 +                %put &errormsg;
23488 +                %put &em_codebar;
23489 +                %goto tscm_endline;
23490 +            %end;
23491 +        %end;
23493 +        *** the AUTO function is currently turned off for TIME timeID variable;
23494 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
23495 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
23496 +            %let EM_TS_ERR = 18;
23497 +            %put &em_codebar;
23498 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
23499 +            %put &errormsg;
23500 +            %put &em_codebar;
23501 +            %goto tscm_endline;
23502 +        %end;
23504 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
23505 +            %then %let timeInterval =DT&timeInterval;
23507 +        proc sql noprint;
23508 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
23509 +                where &timeID is not missing;
23510 +        quit;
23511 +    %end;
23513 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
23514 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
23515 +    run;
23517 +    %let hasValidInterval = 0;
23518 +    %let hasLengthOne     = 0;
23520 +    proc sql noprint;
23521 +        create table _emtscm_label as
23522 +            select name,label
23523 +            from dictionary.columns
23524 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
23525 +        ;
23526 +        create table _emtscm_meta2 as
23527 +            select a.*, b.label
23528 +            from _emtscm_meta as a, _emtscm_label as b
23529 +            where upcase(a.timeID) eq upcase(b.name)
23530 +        ;
23531 +    quit;
23533 +    data &outDS;
23534 +        set _emtscm_meta2;
23535 +        format
23536 +            timeformat      $30.
23537 +            role            $10.
23538 +            start           &timeIDformat
23539 +            end             &timeIDformat
23540 +            apply_start_end $8.
23541 +        ;
23542 +        rename
23543 +            timeID      = name
23544 +            seasonality = lengthOfCycle
23545 +            interval    = timeinterval
23546 +        ;
23547 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
23549 +        role            = "TIMEID";
23550 +        apply_start_end = 'N';
23551 +        timeformat      = symget('timeIDformat');
23552 +        timeformattype  = symget('timeIDformatType');
23554 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
23555 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
23556 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
23557 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
23558 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
23559 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
23560 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
23561 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
23562 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
23563 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
23565 +        if timeformattype eq 'SEQ' then do;
23566 +            timeformat='BEST12.';
23567 +            seasonality=1;
23568 +        end;
23570 +        call symput('_tinterval',interval);
23572 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
23574 +        if upcase(timeformattype) eq 'DATE' and
23575 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
23576 +            then call symput('hasValidInterval',1);
23578 +        if upcase(timeformattype) eq 'DATETIME' and
23579 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
23580 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
23581 +            then call symput('hasValidInterval',1);
23583 +        if upcase(timeformattype) eq 'TIME' and
23584 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
23585 +            then call symput('hasValidInterval',1);
23587 +        if upcase(timeformattype) eq 'SEQ'
23588 +            then call symput('hasValidInterval',1);
23590 +        if upcase(timeformattype) eq 'USER'
23591 +            then call symput('hasValidInterval',1);
23593 +        if start eq end
23594 +            then call symput('hasLengthOne',1);
23595 +    run;
23597 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
23599 +    *** detect any missing time interval after running PROC TIMEID;
23600 +    %if &_tinterval eq %then %do;
23601 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
23602 +        %let EM_TS_ERR = 19;
23603 +        %put &em_codebar;
23604 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
23605 +        %put &errormsg;
23606 +        %put &em_codebar;
23607 +        %goto tscm_endline;
23608 +    %end;
23610 +    *** detect any missing time interval after running PROC TIMEID;
23611 +    %if &hasValidInterval eq 0 %then %do;
23612 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
23613 +        %let EM_TS_ERR = 20;
23614 +        %put &em_codebar;
23615 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
23616 +        %put &errormsg;
23617 +        %put &em_codebar;
23618 +        %goto tscm_endline;
23619 +    %end;
23621 +    %if &hasLengthOne eq 1 %then %do;
23622 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
23623 +        %let EM_TS_ERR = 21;
23624 +        %put &em_codebar;
23625 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
23626 +        %put &errormsg;
23627 +        %put &em_codebar;
23628 +        %goto tscm_endline;
23629 +    %end;
23631 +%end;
23633 +%tscm_endline:;
23635 +%mend EM_TS_CreateMetaData;
23638 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
23640 +data _null_;
23641 +    set &tsmeta;
23642 +    call symput('_timeidFormatType', timeformattype);
23643 +    call symput('_timeid', strip(name));
23644 +    call symput('_seqstartnum',strip(put(start,best12.)));
23645 +run;
23647 +proc contents data=&inDS noprint
23648 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
23649 +run; quit;
23651 +data _null_;
23652 +    set _emts_tmpp1;
23653 +    call symput('_timeIDlabel',label);
23654 +run;
23656 +%if &_timeidFormatType eq SEQ
23657 +%then %do;
23658 +    proc sql noprint;
23659 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
23660 +    quit;
23661 +    %let _dummystarttime=&_dummystarttime;
23663 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
23664 +        set &inDS;
23665 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
23666 +        drop &_timeid;
23667 +        label _tsdp_tmpID = "&_timeIDlabel";
23669 +    run;
23670 +%end;
23672 +%mend;
23674 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
23676 +data _null_;
23677 +    set &tsmeta;
23678 +    call symput('_timeidFormatType', timeformattype);
23679 +    call symput('_timeidFormat', timeformat);
23680 +    call symput('_timeid', strip(name));
23681 +    call symput('_timeinterval',strip(upcase(timeinterval)));
23682 +run;
23684 +/* manually change time ID format to a longer enough time format */
23685 +/* because proc timeid returns time5. for second time interval */
23686 +/* which is not long enough for transpose with time unit as seconds */
23687 +%if &_timeinterval eq SECOND
23688 +%then %do;
23689 +    %let _timeIDformat = %str(time8.);
23690 +%end;
23692 +proc contents data=&inDS noprint
23693 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
23694 +run; quit;
23696 +data _null_;
23697 +    set _emts_tmpp1;
23698 +    call symput('_timeIDlabel',label);
23699 +run;
23701 +%if &_timeidFormatType eq TIME
23702 +%then %do;
23703 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
23704 +        set &inDS;
23705 +        _tsdp_tmpID = timepart(&_timeID);
23706 +        format _tsdp_tmpID &_timeidFormat;
23707 +        label  _tsdp_tmpID = "&_timeIDlabel";
23708 +        drop &_timeid;
23709 +    run;
23710 +%end;
23712 +%mend;
23714 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
23716 + proc sql noprint;
23717 +     create table _tmptimetable as
23718 +         select distinct &timeidvar as DATE from &inDS
23719 +         where &timeIDVar is not missing
23720 +         order by &timeIDVar;
23721 + quit;
23723 +%if &compare eq Y %then %do;
23724 +    * compare with the existing time table;
23725 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
23726 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
23727 +    run;
23729 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
23731 +    %if &_diffobs > 0 %then %do; /* create it again */
23732 +        data &outDS(keep=DATE _INDEX_);
23733 +            set _tmptimetable end = _eof_;
23734 +            if _N_ = 1
23735 +                then _INDEX_ = 1;
23736 +                else _INDEX_ = 0;
23737 +            if _eof_ then _INDEX_= 2;
23738 +        run;
23739 +    %end;
23741 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
23742 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
23743 +%end;
23744 +%else %do;
23745 +    * create a new time table directly;
23746 +    data &outDS(keep=DATE _INDEX_);
23747 +        set _tmptimetable end = _eof_;
23748 +        if _N_ = 1
23749 +            then _INDEX_ = 1;
23750 +            else _INDEX_ = 0;
23751 +        if _eof_ then _INDEX_= 2;
23752 +    run;
23754 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
23755 +%end;
23757 +* assign a defult format BEST12. for sequential time ID;
23759 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
23761 +%let _nodatefmt=N;
23763 +data _null_;
23764 +    set _tmpcontents;
23765 +    where upcase(name) eq 'DATE';
23766 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
23767 +run;
23769 +%if "&_nodatefmt" eq "Y" %then %do;
23770 +    data &outDS;
23771 +        set &outDS;
23772 +        format date best12.;
23773 +    run;
23774 +%end;
23776 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
23778 +%mend;
23782 +%macro EM_TS_Transpose(
23783 +/*-------------------------------------------------------------------------*/
23784 +  inDS          =,      /* imported data set in TS data mining             */
23785 +  inIDMap       =,      /* input TS ID map                                 */
23786 +  variableSet   =,      /* variable set                                    */
23787 +  transposeBy   =,      /* byTSID or byTimeID                              */
23788 +  outDS         =,      /* output transposed data set                      */
23789 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
23790 +  inEM          =Y,
23791 +  timePrefix    =_T
23792 +/*-------------------------------------------------------------------------*/
23793 +);
23795 +%let timePrefix = &timePrefix;
23797 +%if  &EM_NUM_CROSSID > 0 %then %do;
23799 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
23800 +    set &inIDMap;
23801 +    drop _NAMEID_;
23802 +    run;
23803 +%let inIDMap=_emtstp_map0;
23805 +%end;
23807 +proc sql noprint;
23808 +    * number of TS Variables to be transposed;
23809 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
23810 +    ;
23811 +    * number of TS Variables to be transposed;
23812 +    select max(_TSID_) into :num_TSID from &inIDMap
23813 +    ;
23814 +    * name list of TS Variables;
23815 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
23816 +        from &inIDMap
23817 +        order by _NAMEID_
23818 +    ;
23819 +    * total number of time series =max(_TSID_)*&num_TSVar;
23820 +    * and the number of digits of this variable is &num_digits;
23821 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
23822 +        from &inIDMap
23823 +    ;
23824 +      * Time ID variable;
23825 +    select name into:timeIDVar from &variableset
23826 +        where upcase(role) eq 'TIMEID'
23827 +    ;
23828 +quit;
23829 +%let num_digits = &num_digits;
23830 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
23832 +/*-------------------------------------------------------------------------*/
23834 +* get number of cross IDs and also the TIME ID variable name;
23835 +%if &inEM eq Y %then %do;
23836 +    %let num_crossIDVar = &EM_NUM_CROSSID;
23837 +    %let crossIDVar     = %EM_CROSSID;
23838 +%end;
23839 +%else %do;
23840 +    proc sql noprint;
23841 +        * number of cross ID;
23842 +        select count(*) into :num_crossIDVar
23843 +            from &variableSet
23844 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23845 +        ;
23846 +        * create a string of crossID variable like A B C D..;
23847 +        select distinct name into :crossIDVar separated by ' '
23848 +            from &variableSet
23849 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23850 +            order by name
23851 +        ;
23852 +    quit;
23853 +    %let num_crossIDVar=&num_crossIDVar;
23854 +%end;
23856 +/*-------------------------------------------------------------------------*/
23858 +%if (&num_crossIDVar gt 0) %then %do;
23860 +    data _emtstp_tmpDat;
23861 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
23862 +        _NAMEID_ = cats("_TS_",_TSID_);
23863 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
23864 +    run;
23866 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
23868 +        * update the ID maps;
23869 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
23870 +            by _NAMEID_ _TSID_;
23871 +        data &outIDMap;
23872 +            set _emtstp_tmpmap;
23873 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
23874 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
23875 +        run;
23877 +        * get the names for the new variables;
23878 +        proc sql noprint;
23879 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
23880 +            ;
23881 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
23882 +            ;
23883 +        quit;
23885 +        * data must be sorted before transposed;
23886 +        proc sort data=_emtstp_tmpDat;
23887 +            by &timeIDvar;
23888 +        run;
23890 +        %do i = 1 %to &num_TSVar;
23891 +            %let i = &i;
23892 +            * transpose one cross-type time series data by TSID;
23893 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
23894 +                id _NAMEID_;
23895 +                by &timeIDVar;
23896 +                var &&&TSVar&i;
23897 +            run;
23898 +        %end;
23900 +        * merge all vertical time series, rename and label them;
23901 +        data &outDS;
23902 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
23903 +            by &timeIDVar;
23904 +            rename
23905 +                %do i = 1 %to &num_TSVar;
23906 +                    %do j = 1 %to &num_TSID;
23907 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
23908 +                        /* %put &i &j &num1 &num_TSID; */
23909 +                        _V_&i._TS_&j = &&&tsname&num1
23910 +                    %end;
23911 +                %end;
23912 +            ;
23913 +            label
23914 +                %do i = 1 %to &num_TSVar;
23915 +                    %do j = 1 %to &num_TSID;
23916 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
23917 +                        /* %put &i &j &num1 &num_TSID; */
23918 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
23919 +                    %end;
23920 +                %end;
23921 +            ;
23922 +        run;
23923 +    %end;
23924 +    %else %do;
23926 +        * update the ID maps;
23927 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
23928 +            by _NAMEID_ _TSID_;
23929 +        data &outIDMap;
23930 +            set _emtstp_tmpmap;
23931 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
23932 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
23933 +        run;
23935 +        proc sql noprint;
23936 +            * get the roles for the new variables;
23937 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
23938 +                from &inIDMap
23939 +                order by _NAMEID_
23940 +            ;
23941 +            * get the length of the time series;
23942 +            select count(distinct &timeIDvar) into :num_T
23943 +                from _emtstp_tmpDat
23944 +            ;
23945 +        quit;
23947 +        * data must be sorted before transposed;
23948 +        proc sort data=_emtstp_tmpDat;
23949 +            by _TSID_ &crossIDVar &timeIDvar;
23950 +        run;
23952 +        %do i = 1 %to &num_TSVar;
23953 +            %let i = &i;
23954 +            * transpose one cross-type time series data by TIMEID;
23955 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
23956 +                by _TSID_ &crossIDVar;
23957 +                var &&&TSVar&i;
23958 +            run;
23959 +        %end;
23961 +        * stack all horizontal time series;
23962 +        data &outDS;
23963 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
23964 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
23965 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
23966 +            %do i=1 %to &num_TSVar;
23967 +                if in&i then do;
23968 +                    _NAMEID_ ="&&&TSVar&i";
23969 +                    _ROLE_   ="&&&TSRole&i";
23970 +                end;
23971 +            %end;
23972 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
23973 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
23974 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
23975 +        run;
23976 +    %end;
23977 +%end;
23978 +%else %do;
23980 +    proc sql noprint;
23981 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
23982 +            order by _NAMEID_
23983 +        ;
23984 +    quit;
23986 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
23987 +        * transpose the panel-type time series data by TSID;
23988 +        proc sort data=&inDS out=_emtstp_tmpDat;
23989 +            by &timeIDvar;
23990 +        proc transpose data=_emtstp_tmpDat
23991 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
23992 +            by &timeIDVar;
23993 +            var &panelTSVar;
23994 +        run;
23995 +        proc datasets lib=work nolist;
23996 +            modify _emtstp_tmpDat2;
23997 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
23998 +            run; quit;
23999 +    %end;
24000 +    %else %do;
24001 +        * transpose the panel-type time series data by TIMEID;
24002 +        proc sort data=&inDS out=_emtstp_tmpDat;
24003 +            by &timeIDvar;
24004 +        data _emtstp_tmpDat;
24005 +            set _emtstp_tmpDat;
24006 +            _tmp_ind=_n_;
24007 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
24008 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
24009 +            ID _tmp_ind;
24010 +            var &panelTSVar;
24011 +        run;
24012 +    %end;
24014 +      * merge ID maps to the transpose data set;
24015 +      proc sql noprint;
24016 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
24017 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
24018 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
24019 +          ;
24020 +      quit;
24022 +      * update the TS ID map;
24023 +      data &outIDMap;
24024 +          set &inIDMap;
24025 +      run;
24026 +%end;
24028 +proc datasets lib=work nolist;
24029 +    delete _emtstp:;
24030 +run; quit;
24032 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_REPORT.SOURCE.
24034 +/*----------------------------------------------------------------------------------+
24035 + |
24036 + |   Title :  TS Forecating Node
24037 + |
24038 + |
24039 + |   SUPPORT: Taiyeong Lee (Taiyeong.Lee@sas.com)
24040 + |
24041 + +-----------------------------------------------------------------------------------*/
24043 +%macro EM_TSESM_REPORT;
24045 +    %EM_GETNAME(KEY=OUTEST, TYPE=DATA);
24046 +    %EM_GETNAME(KEY=OUTDATA, TYPE=DATA);
24047 +    %EM_GETNAME(KEY=OUTFOR, TYPE=DATA);
24048 +    %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
24049 +    %EM_GETNAME(KEY=OUTFORCST, TYPE=DATA);
24050 +    %EM_GETNAME(KEY=OUTSUM, TYPE=DATA);
24051 +    %EM_GETNAME(KEY=OUTSTAT, TYPE=DATA);
24052 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
24053 +    %EM_GETNAME(KEY=OUTCOMPFCST, TYPE=DATA);
24054 +    %EM_GETNAME(KEY=FORCSTPLOTDS, TYPE=DATA);
24055 +    %EM_GETNAME(KEY=OUTLIERDS, TYPE=DATA);
24056 +    %EM_GETNAME(KEY=OUTSUMPLOT, TYPE=DATA);
24058 +    %EM_REPORT(key=OUTEST,    view=1, viewtype=DATA, block=MODEL, autodisplay=N, description=tsparaest ) ;
24059 +    %EM_REPORT(key=OUTSTAT,   view=2, viewtype=DATA, block=MODEL, autodisplay=N, description=tsfitstat) ;
24060 +    %EM_REPORT(key=TSIDMAP,   view=3, viewtype=DATA, block=MODEL, autodisplay=N, description=tsidmaptable) ;
24061 +    %EM_REPORT(key=OUTLIERDS, view=4, viewtype=DATA, block=MODEL, autodisplay=N, description=tsoutliertable) ;
24062 +    %EM_REPORT(key=TSMETA,    view=5, viewtype=DATA, block=MODEL, autodisplay=N, description=tsmetatable) ;
24064 +    %let viewnum=6;
24066 +    %let _num_inputs = %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED);
24068 +    %if %EM_CROSSID eq %then %goto SKIP_HISTOGRAM;  /* panel data */
24070 +    %EM_GETNAME(key=OUTSUMHIST, type=DATA);
24071 +    %EM_GETNAME(key=OUTFCSTHIST, type=DATA);
24073 +    %let _varlist1=LOWER PREDICT UPPER;
24074 +    %let _varlist2=;
24075 +    %do k=1 %to &EM_PROPERTY_FCLEAD;
24076 +         %let _varlist2 = &_varlist2. _LEAD&k._ ;
24077 +    %end;
24078 +    %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24079 +           %let j=1;
24080 +           %do %while(%scan(%EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED, &j) ne );
24081 +               %let _var=%scan(%EM_INTERVAL_INPUT, &j);
24082 +               data _tmp_OUTSUM;
24083 +                    set  &EM_USER_OUTSUM;
24084 +                    if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then output;
24085 +               run;
24086 +               %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=_tmp_OUTSUMHIST, VARS=&_varlist1, NUMBARS=10);
24087 +               %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=_tmp_OUTFCSTHIST, VARS=&_varlist2, NUMBARS=10);
24088 +               %if &j=1 %then %do;
24089 +                   data &EM_USER_OUTSUMHIST;
24090 +                        length _VARNAME_  $32;
24091 +                        set   _tmp_OUTSUMHIST;
24092 +                        _VARNAME_="&_var";
24093 +                        label _VARNAME_ = "Variable Name";
24094 +                   run;
24095 +                   data &EM_USER_OUTFCSTHIST ;
24096 +                        length _VARNAME_  $32;
24097 +                         set _tmp_OUTFCSTHIST;
24098 +                          _VARNAME_="&_var";
24099 +                        label _VARNAME_ = "Variable Name";
24100 +                   run;
24101 +                %end;
24102 +                %else %do;
24103 +                   data  _tmp_OUTSUMHIST;
24104 +                        length _VARNAME_  $32;
24105 +                        set   _tmp_OUTSUMHIST;
24106 +                        _VARNAME_="&_var";
24107 +                        label _VARNAME_ = "Variable Name";
24108 +                   run;
24109 +                   data &EM_USER_OUTSUMHIST;
24110 +                        set &EM_USER_OUTSUMHIST  _tmp_OUTSUMHIST;
24111 +                   run;
24112 +                   data _tmp_OUTFCSTHIST ;
24113 +                        length _VARNAME_  $32;
24114 +                         set _tmp_OUTFCSTHIST;
24115 +                          _VARNAME_="&_var";
24116 +                        label _VARNAME_ = "Variable Name";
24117 +                   run;
24118 +                   data &EM_USER_OUTFCSTHIST ;
24119 +                        set &EM_USER_OUTFCSTHIST _tmp_OUTFCSTHIST ;
24120 +                   run;
24122 +                %end;
24123 +               %let j=%eval(&j+1);
24124 +           %end;
24126 +    %end;
24127 +    %else %do;
24128 +        /* Since we allow only one targt at this version */
24129 +        %let _var=%EM_TARGET;
24130 +        data _tmp_OUTSUM;
24131 +            set  &EM_USER_OUTSUM;
24132 +            if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then output;
24133 +        run;
24134 +        %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=&EM_USER_OUTSUMHIST, VARS=&_varlist1, NUMBARS=10);
24135 +        %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=&EM_USER_OUTFCSTHIST, VARS=&_varlist2, NUMBARS=10);
24137 +        /*
24138 +        %VAR_PROFILE(DATA=&EM_USER_OUTSUM, OUTPUT=&EM_USER_OUTSUMHIST, VARS=&_varlist1, NUMBARS=10);
24139 +        %VAR_PROFILE(DATA=&EM_USER_OUTSUM, OUTPUT=&EM_USER_OUTFCSTHIST, VARS=&_varlist2, NUMBARS=10);
24140 +        */
24141 +    %end;
24143 +    data &EM_USER_OUTSUMHIST;
24144 +         set &EM_USER_OUTSUMHIST;
24145 +         label value="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_forecastsum, noquote))";
24146 +         label Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_histogram, noquote))";
24147 +         label Percent="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_percent, noquote))";
24148 +         if strip(upcase(Variable)) eq "UPPER" then Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_upper,noquote))";
24149 +         if strip(upcase(Variable)) eq "PREDICT" then Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_predict,noquote))";
24150 +         if strip(upcase(Variable)) eq "LOWER" then Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lower,noquote))";
24151 +         %if &_seriesFormat ^= %then %do;
24152 +            format VALUE &_seriesFormat;
24153 +         %end;
24154 +    run;
24157 +    data &EM_USER_OUTFCSTHIST;
24158 +         set &EM_USER_OUTFCSTHIST;
24159 +         length vlabel $100;
24160 +         %do k=1 %to &EM_PROPERTY_FCLEAD;
24161 +             %let _leadvar = _LEAD&k._ ;
24162 +             if upcase(strip(Variable)) ="&_leadvar" then vlabel= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_stepahead_forecast, noquote, &k))";
24163 +         %end;
24164 +         output;
24165 +         label value="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_forecast, noquote))";
24166 +         label vlabel="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_histogram, noquote))";
24167 +         label Percent="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_percent, noquote))";
24168 +         %if &_seriesFormat ^= %then %do;
24169 +            format VALUE &_seriesFormat;
24170 +         %end;
24171 +    run;
24173 +    %SKIP_HISTOGRAM:
24176 +    %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24178 +        %EM_REPORT(key=OUTSUMHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=N,
24179 +              latticex=Variable, equalizerowy=Y, equalizecoly=Y, byset=_VARNAME_, description=tsfcstsumhist, view=&viewnum);
24180 +        %let viewnum=%eval(&viewnum+1);
24181 +        %EM_REPORT(key=OUTFCSTHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=Y,
24182 +              latticex=vlabel, equalizerowy=Y, equalizecoly=Y,  byset=_VARNAME_, description=tsfcsthist, view=&viewnum);
24183 +        %let viewnum=%eval(&viewnum+1);
24184 +    %end;
24185 +    %else %do;
24186 +        %EM_REPORT(key=OUTSUMHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=N,
24187 +              latticex=Variable, equalizerowy=Y, equalizecoly=Y, description=tsfcstsumhist, view=&viewnum);
24188 +        %let viewnum=%eval(&viewnum+1);
24189 +        %EM_REPORT(key=OUTFCSTHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=Y,
24190 +              latticex=vlabel, equalizerowy=Y, equalizecoly=Y, description=tsfcsthist, view=&viewnum);
24191 +        %let viewnum=%eval(&viewnum+1);
24192 +    %end;
24194 +    %let _EndTime = ;
24195 +    %let dsid=%sysfunc(open(&EM_USER_TSMETA));
24196 +    %if &dsid > 0 %then %do;
24197 +    %let vn_end =%sysfunc(varnum(&dsid, END));
24198 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
24199 +    %do %while(^%sysfunc(fetch(&dsid)));
24200 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
24201 +       /*--------------------------------------------------------
24202 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
24203 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
24204 +        ---------------------------------------------------------*/
24205 +    %end;
24206 +    %let dsid = %sysfunc(close(&dsid));
24207 +    %end;
24209 +    %let _ndisplay = 3;
24210 +    %let _timeidVar = %EM_TIMEID;
24211 +    %let _targetVar = %EM_TARGET;
24212 +    %let _accumulate = &EM_PROPERTY_ACCUMULATE;
24215 +    %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24217 +        %let dsid=%sysfunc(open(&EM_DATA_VARIABLESET(where=(ROLE='INPUT' and LEVEL ='INTERVAL' and USE in ('D', 'Y')))));
24218 +        %let vn_name =%sysfunc(varnum(&dsid, NAME));
24219 +        %let _autodisplay = Y;
24220 +        %let YvarString = ;
24221 +        %let i = 0;
24222 +        %do %while(^%sysfunc(fetch(&dsid)));
24223 +            %let _varname= %sysfunc(getvarc(&dsid, &vn_name));
24224 +            %let i=%eval(&i+1);
24225 +            %let YvarString = &YvarString &_varname ;
24226 +            %if &i >  &_ndisplay %then %let _autodisplay = N;
24228 +            %let vnamefcstplot1 = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_vnamefcstplot, noquote, &_varname ));
24230 +            %if %EM_CROSSID ne %then
24231 +                  %EM_REPORT(key=FORCSTPLOTDS, viewtype=LINEBAND, block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_NAME_ ="&_varname"),  x=&_timeidVar,
24232 +                             LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE, XREF=&_EndTime, group=Outlier,
24233 +                             byset=_TSID_, Description= &vnamefcstplot1, view=&viewnum);
24234 +            %else
24235 +                  %EM_REPORT(key=FORCSTPLOTDS, viewtype=LINEBAND, block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_NAME_ ="&_varname"),  x=&_timeidVar,
24236 +                             LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE, XREF=&_EndTime, group=Outlier,
24237 +                             Description= &vnamefcstplot1, view=&viewnum);
24239 +            %let viewnum=%eval(&viewnum+1);
24240 +        %end;
24241 +        %let dsid = %sysfunc(close(&dsid));
24244 +        data &EM_USER_OUTCOMPFCST;
24245 +             set &EM_USER_OUTDATA;
24246 +             if &_timeidVar > &_EndTime then output;
24247 +             drop %EM_TARGET;    /* EM12 */
24248 +        run;
24250 +        %if %EM_CROSSID ne %then %do;
24252 +            /* &YVarString need to be replaced to aviod the potential length problem */
24254 +            %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, byset=_TSID_, X=&_timeidVar,
24255 +                Y=&YvarString, block=Plot, description=tsfcstcomp, view=&viewnum) ;
24256 +            %let viewnum=%eval(&viewnum+1);
24257 +            %let j=1;
24258 +            %do %while(%scan(&YvarString, &j) ne );
24259 +                %let _yvar=%scan(&YvarString, &j);
24260 +                %if &j = 1 %then
24261 +                    %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, group=_TSID_, X=&_timeidVar,
24262 +                        Y=&_yvar, block=Plot, description=mtsfcstcomp, view=&viewnum);
24263 +                %else
24264 +                    %EM_REPORT(Y=&_yvar, view=&viewnum);
24265 +                %let j=%eval(&j+1);
24267 +            %end;
24268 +            %let viewnum=%eval(&viewnum+1);
24269 +        %end;
24270 +        %else %do;
24271 +            %let j=1;
24272 +            %do %while(%scan(&YvarString, &j) ne );
24273 +                %let _yvar=%scan(&YvarString, &j);
24274 +                %if &j = 1 %then
24275 +                    %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar,
24276 +                        Y=&_yvar, block=Plot, description=tsfcstcomp, view=&viewnum);
24277 +                %else
24278 +                    %EM_REPORT(Y=&_yvar, view=&viewnum);
24279 +                %let j=%eval(&j+1);
24281 +            %end;
24282 +            %let viewnum=%eval(&viewnum+1);
24284 +            %if &j > 2 %then %do;
24285 +                %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar,
24286 +                   Y=&YvarString, block=Plot, description=mtsfcstcomp, view=&viewnum);
24287 +                %let viewnum=%eval(&viewnum+1);
24288 +            %end;
24289 +        %end;
24292 +    %end;   /* the end of  if &EM_PROPERTY_EXTINPUT eq Y */
24293 +    %else %do;
24294 +        /*
24295 +        %let _crossidvars = %EM_CROSSID;
24296 +        %let _lastcrossidvar = %SCAN(&_crossidvars, -1, %STR( ));
24297 +        %if &_lastcrossidvar eq _SEGMENT_ %then %do;
24298 +            %let _tsidVar = _SEGMENT_;
24299 +            %EM_TS_GET_STAT(data=&EM_USER_TSIDMAP, var=_SEGMENT_, stat=MAX, value=n_segments);
24300 +        %end;
24301 +        %else %do;
24302 +            %let _tsidVar = _TSID_;
24303 +        %end;
24304 +        */
24305 +        %let _tsidVar = _TSID_;
24306 +        %if &_tsidVar = _TSID_ %then %do;
24307 +            %let dsid=%sysfunc(open(&EM_USER_FORCSTPLOTDS));
24308 +            %if &dsid > 0 %then %do;
24309 +                %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
24310 +                %let dsid = %sysfunc(close(&dsid));
24311 +            %end;
24312 +            %if &vn_tsid > 0 %then %do;
24313 +                %let dsid=%sysfunc(open(&EM_USER_TSIDMAP(where=(strip(_ROLE_)="TARGET"))));  /* whereclause EM12 */
24314 +                %if &dsid > 0 %then %do;
24315 +                    %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
24316 +                    %do %while(^%sysfunc(fetch(&dsid)));
24317 +                        %let _tsid  = %sysfunc(getvarn(&dsid, &vn_tsid));
24318 +                        %if &_tsid < &_ndisplay %then %let _autodisplay = Y;
24319 +                        %else %let _autodisplay = N;
24320 +                        %let tsidfcstplot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_tsidfcstplot, noquote, &_tsid ));
24321 +                        %EM_REPORT(key=FORCSTPLOTDS, view=&viewnum, viewtype=LINEBAND, Block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_TSID_ = &_tsid ),  x=&_timeidVar,
24322 +                                   LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE, XREF=&_EndTime, group=outlier,
24323 +                                   Description=&tsidfcstplot);
24324 +                        %let viewnum=%eval(&viewnum+1);
24325 +                    %end;
24326 +                    %let dsid = %sysfunc(close(&dsid));
24327 +                %end;
24328 +           %end;
24329 +           %else %do;  /*------ iterate over the target variables -----*/
24330 +                %let dsid=%sysfunc(open(&EM_DATA_VARIABLESET(where=(ROLE='TARGET' and LEVEL ='INTERVAL' and USE in ('D', 'Y')))));
24331 +                %let vn_name =%sysfunc(varnum(&dsid, NAME));
24332 +                %let _autodisplay = Y;
24333 +                %let i = 0;
24334 +                %do %while(^%sysfunc(fetch(&dsid)));
24335 +                    %let i=%eval(&i+1);
24336 +                    %if &i > 5 %then  %let _autodisplay = N;
24337 +                    %let _varname= %sysfunc(getvarc(&dsid, &vn_name));
24338 +                    %let vnamefcstplot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_vnamefcstplot, noquote, &_varname ));
24339 +                    %EM_REPORT(key=FORCSTPLOTDS, view=&viewnum, viewtype=LINEBAND, Block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_NAME_ ="&_varname"),  x=&_timeidVar, LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL,
24339!+YPLOTTYPE=LINE, XREF=&_EndTime,  group=outlier, Description=&vnamefcstplot);
24340 +                    %let viewnum=%eval(&viewnum+1);
24341 +                %end;
24342 +                %let dsid = %sysfunc(close(&dsid));
24343 +           %end;
24344 +        %end; /* end of %if &_tsidVar = _TSID_  */
24345 +        %else %if &_tsidVar = _SEGMENT_ %then %do;
24346 +              %do i=1 %to &n_segments;
24347 +                  %if &i < &_ndisplay %then %let _autodisplay = Y;
24348 +                  %else %let _autodisplay = N;
24349 +                  %let segfcstplot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_segfcstplot, noquote, &i, &_accumulate ));
24350 +                  %EM_REPORT(key=FORCSTPLOTDS, view=&viewnum, viewtype=LINEBAND, Block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_SEGMENT_ = &i),  x=&_timeidVar, LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE,
24350!+XREF=&_EndTime, group=outlier, Description=&segfcstplot);
24351 +                  %let viewnum=%eval(&viewnum+1);
24352 +              %end;
24353 +        %end;
24354 +         /*-------- the end of Forecasting Plot --------------------------------*/
24356 +        data &EM_USER_OUTCOMPFCST;
24357 +             set &EM_USER_OUTDATA;
24358 +            if &_timeidVar > &_EndTime then output;
24359 +            drop %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED;
24360 +        run;
24362 +        %let dsid=%sysfunc(open(&EM_USER_OUTCOMPFCST));
24363 +        %if &dsid > 0 %then %do;
24364 +            %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
24365 +            %let vn_segment =%sysfunc(varnum(&dsid, _SEGMENT_));
24366 +            %let dsid = %sysfunc(close(&dsid));
24367 +        %end;
24369 +        %if (&vn_tsid > 0) and (&_targetVar ne ) %then %do;
24370 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=&_targetVar,block=Plot,
24371 +                            GROUP=_TSID_, WHERE=%nrbquote(_TSID_ <= 100), description=mtsfcstcomp) ;
24372 +            %let viewnum=%eval(&viewnum+1);
24373 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=&_targetVar,block=Plot,
24374 +                            Byset=_TSID_, WHERE=%nrbquote(_TSID_ <= 100), description=tsfcstcomp) ;
24375 +            %let viewnum=%eval(&viewnum+1);
24376 +        %end;
24377 +        %else %if &vn_segment > 0 and (&_targetVar ne ) %then %do;
24378 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=&_targetVar, block=Plot,
24379 +                            GROUP=_SEGMENT_, WHERE=%nrbquote(_SEGMENT_ <= 100),  description=tsfcstcomp) ;
24380 +            %let viewnum=%eval(&viewnum+1);
24381 +        %end;
24382 +        %else %if &vn_segment > 0 and (&_targetVar eq ) %then %do;
24383 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=%EM_INTERVAL_INPUT , block=Plot,
24384 +                            GROUP=_SEGMENT_, WHERE=%nrbquote(_SEGMENT_ <= 100),  description=tsfcstcomp) ;
24385 +            %let viewnum=%eval(&viewnum+1);
24386 +        %end;
24387 +        %else %do;
24388 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=%EM_TARGET , block=Plot, description=mtsfcstcomp) ;
24389 +            %let viewnum=%eval(&viewnum+1);
24391 +            %if &EM_NUM_TARGET > 1 %then %do;
24392 +                %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=_ANYNUMERIC_, block=Plot, description=tsfcstcomp) ;
24393 +                %let viewnum=%eval(&viewnum+1);
24394 +            %end;
24395 +        %end;
24397 +    %end; /* the end of  if &EM_PROPERTY_EXTINPUT eq N */
24400 +   /*------------------ plot distance map ---------------------------------*/
24402 +   %if (&EM_PROPERTY_EXPORTDATA eq KLD) %then %do;
24404 +       %EM_GETNAME(KEY=OUTKLD, TYPE=DATA);
24405 +       %EM_GETNAME(KEY=MAPDS, TYPE=DATA);
24407 +       data _tmp;
24408 +           set &EM_USER_OUTKLD;
24409 +           KEEP _TSID_ _TSID:;
24410 +       proc sort data =_tmp;
24411 +            by _TSID_;
24412 +       proc transpose data =_tmp out= &EM_USER_MAPDS Prefix=TSID_;
24413 +            by _TSID_;
24414 +       run;
24416 +       data &EM_USER_MAPDS;
24417 +           set &EM_USER_MAPDS;
24418 +           label _TSID_ ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
24419 +           label _NAME_ ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
24420 +           label TSID_1 ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_distmeasure, noquote))";
24421 +           rename _NAME_  =COL_VAR;
24422 +           rename TSID_1 = DISTANCE;
24423 +           ROW_VAR = "_TSID"||strip(_TSID_);
24424 +           label ROW_VAR ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
24425 +       run;
24426 +       %EM_REPORT(key=MAPDS, viewtype=HISTOGRAM, Y=COL_VAR,X=ROW_VAR,
24427 +           FREQ=DISTANCE, autodisplay=Y, block=Plot, description=tssimmap, view=&viewnum);
24428 +       %let viewnum=%eval(&viewnum+1);
24429 +   %end;
24431 +   %let _xvar = ;
24432 +   %EM_TS_GET_VAR_EXIST(data=&EM_USER_OUTSUM, var=_TSID_, exist=_isTSID);
24433 +   %if &_isTSID eq Y %then %do;
24434 +      %let _xvar = _TSID_;
24435 +      /*%EM_TSDP_MergeTSID(inds=&EM_USER_OUTSUM, tsidds=&EM_USER_TSIDMAP, inputtype=&EM_PROPERTY_INPUTDATATYPE, outds=);*/
24436 +   %end;
24437 +   %else %do;
24438 +     %EM_TS_GET_VAR_EXIST(data=&EM_USER_OUTSUM, var=_NAMEID_, exist=_isNAMEID);
24439 +     %if &_isNAMEID eq Y %then %let _xvar = _NAMEID_;
24440 +     %else %do;
24441 +           %EM_TS_GET_VAR_EXIST(data=&EM_USER_OUTSUM, var=_NAME_, exist=_isNAME);
24442 +           %if &_isNAME eq Y %then %let _xvar = _NAME_;
24443 +     %end;
24444 +  %end;
24446 +  %if &_xvar ne %then %do;
24447 +        %let bysetflag = N;
24448 +         %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24449 +             data &EM_USER_OUTSUMPLOT;
24450 +                  set  &EM_USER_OUTSUM;
24451 +             %let j=1;
24452 +             %do %while(%scan(%EM_TARGET, &j) ne );
24453 +                 %let _var=%scan(%EM_TARGET, &j);
24454 +                 if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then delete;
24455 +                 %let j=%eval(&j+1);
24456 +             %end;
24457 +             run;
24458 +             %if %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED)  > 1 %then %let bysetflag = Y;
24459 +        %end;
24460 +        %else %do;
24461 +             data &EM_USER_OUTSUMPLOT;
24462 +                  set  &EM_USER_OUTSUM;
24463 +                  %let j=1;
24464 +                  %do %while(%scan(%EM_INTERVAL_INPUT, &j) ne );
24465 +                  %let _var=%scan(%EM_INTERVAL_INPUT, &j);
24466 +                  if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then delete;
24467 +                  %let j=%eval(&j+1);
24468 +                  %end;
24469 +                  %let j=1;
24470 +                  %do %while(%scan(%EM_INTERVAL_REJECTED, &j) ne );
24471 +                  %let _var=%scan(%EM_INTERVAL_REJECTED, &j);
24472 +                  if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then delete;
24473 +                  %let j=%eval(&j+1);
24474 +                  %end;
24475 +            run;
24476 +            %if &EM_NUM_TARGET  > 1 %then %let bysetflag = Y;
24477 +        %end;
24479 +    %if %EM_CROSSID ne %then %do;
24481 +        %if &bysetflag = Y %then
24482 +            %EM_REPORT(key=OUTSUMPLOT,  viewtype=BAR, autodisplay=Y, x=&_xvar, block=Plot,  FREQ=PREDICT,
24483 +                byset = _NAME_, description=tsfcstsum, view=&viewnum) ;
24484 +        %else
24485 +            %EM_REPORT(key=OUTSUMPLOT,  viewtype=BAR, autodisplay=Y, x=&_xvar, block=Plot,  FREQ=PREDICT,
24486 +                description=tsfcstsum, view=&viewnum) ;
24488 +    %end; /* end of %if %EM_CROSSID ne %then %do; */
24489 +    %else %do;
24491 +        %EM_REPORT(key=OUTSUMPLOT,  viewtype=BAR, autodisplay=Y, x=&_xvar, block=Plot,  FREQ=PREDICT,
24492 +            group=_NAME_, description=tsfcstsum, view=&viewnum) ;
24493 +        *%let viewnum=%eval(&viewnum+1);
24494 +    %end;
24496 +     %do k=1 %to &EM_PROPERTY_FCLEAD;
24497 +         %let _freqvarname = _LEAD&k._ ;
24498 +         %EM_REPORT(VIEW=&viewnum, Freq=&_freqvarname);
24499 +     %end;
24500 +     %EM_REPORT(VIEW=&viewnum, Freq=LOWER);
24501 +     %EM_REPORT(VIEW=&viewnum, Freq=UPPER);
24502 +     %EM_REPORT(VIEW=&viewnum, Freq=STD);
24503 +     %EM_REPORT(VIEW=&viewnum, Freq=MIN);
24504 +     %EM_REPORT(VIEW=&viewnum, Freq=MAX);
24505 +     %EM_REPORT(VIEW=&viewnum, Freq=MEAN);
24506 +     %EM_REPORT(VIEW=&viewnum, Freq=STDDEV);
24507 +  %end; /*end of   %if &_xvar ne %then %do; */
24510 +%mend EM_TSESM_REPORT;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 264 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 264 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 396 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 396 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 528 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 528 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 660 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 660 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 792 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 792 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 924 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 924 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1058 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 221 observations read from the data set EMWS5.TSESM2_OUTDATA.
NOTE: The data set EMWS5.TSESM2_OUTCOMPFCST has 6 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1058 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1191 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM2_OUTSUM.
NOTE: The data set EMWS5.TSESM2_OUTSUMPLOT has 1 observations and 20 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1191 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1323 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1323 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1455 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1455 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1587 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1587 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1719 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1719 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1851 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1851 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1983 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1983 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2115 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 2115 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2247 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2247 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2379 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2379 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2511 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 2511 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2643 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 2643 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2775 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2775 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2907 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
24513
24514
24515  *------------------------------------------------------------*;
24516  * End REPORT: TSESM2;
24517  *------------------------------------------------------------*;
 
24518  /* Reset EM Options */
24519  options formchar="|----|+|---+=|-/\<>*";
24520  options nocenter ls=256 ps=10000;
24521  goptions reset=all device=GIF NODISPLAY;
 
24522  proc sort data=WORK.EM_USER_REPORT;
24523  by ID VIEW;
24524  run;
 
NOTE: There were 2907 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2907 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
