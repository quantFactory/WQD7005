*------------------------------------------------------------*
User:                ali
Date:                December 19, 2019
Time:                13:06:44
Site:                12601940
Platform:            W32_8PRO
Maintenance Release: 9.04.01M3P062415
EM Version:          14.1
* 
*------------------------------------------------------------*
* Training Log
Date:                December 19, 2019
Time:                13:06:41
*------------------------------------------------------------*
14718  proc freq data=EMWS5.TSESM4_VariableSet noprint;
14719  table ROLE*LEVEL/out=WORK.TSESM4META;
14720  run;
 
NOTE: There were 6 observations read from the data set EMWS5.TSESM4_VARIABLESET.
NOTE: The data set WORK.TSESM4META has 3 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
14721  proc print data=WORK.TSESM4META label noobs;
14722  var ROLE LEVEL COUNT;
14723  label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
14724  title9 ' ';
14725  title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
14726  run;
 
NOTE: There were 3 observations read from the data set WORK.TSESM4META.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
14727  title10;
 
14728  %let EMEXCEPTIONSTRING=;
PERFORMANCE  DETAILS
15083  *------------------------------------------------------------*;
15084  * TSESM4: Generation of macros and macro variables;
15085  * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
15086  *------------------------------------------------------------*;
 
15087  %let EMEXCEPTIONSTRING=;
15088  *------------------------------------------------------------*;
15089  * TRAIN: TSESM4;
15090  *------------------------------------------------------------*;
15091  %let EM_ACTION = TRAIN;
15092  %let syscc = 0;
15093
15094  %macro EM_TSESM_MAIN;
15095
15096     filename temp catalog 'sashelp.emtsdm.tsesm_macros.source';
15097     %include temp;
15098     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
15099     %include temp;
15100     filename temp;
15101
15102     %if %upcase(&EM_ACTION) = CREATE %then %do;
15103         filename temp catalog 'sashelp.emtsdm.tsesm_create.source';
15104         %include temp;
15105         filename temp;
15106         %EM_TSESM_CREATE;
15107     %end;
15108     %else
15109     %if %upcase(&EM_ACTION) = TRAIN %then %do;
15110          filename temp catalog 'sashelp.emtsdm.tsesm_train.source';
15111             %include temp;
15112             filename temp;
15113          %EM_TSESM_TRAIN;
15114     %end;
15115     %else
15116     %if %upcase(&EM_ACTION) = SCORE %then %do;
15117             filename temp catalog 'sashelp.emtsdm.tsesm_score.source';
15118             %include temp;
15119             filename temp;
15120           %EM_TSESM_SCORE;
15121     %end;
15122     %else
15123     %if %upcase(&EM_ACTION) = REPORT %then %do;
15124             filename temp catalog 'sashelp.emtsdm.tsesm_report.source';
15125             %include temp;
15126             filename temp;
15127            %EM_TSESM_REPORT;
15128     %end;
15129  %mend EM_TSESM_MAIN;
15130  %EM_TSESM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_MACROS.SOURCE.
15131 +/*----------------------------------------------------------------------------------+
15132 + |
15133 + |   Title :  Time Series data Mining Forcating Macros
15134 + |
15135 + |   SUPPORT: Ruiwen Zhang (Ruiwen.Zhang@sas.com)
15136 + |
15137 + |
15138 + +-----------------------------------------------------------------------------------*/
15141 +%macro EM_TSESM_Forecast(indata=,
15142 +                method=,
15143 +                timeinterval=,
15144 +                timeid= ,
15145 +                target= ,
15146 +                tsidvar=,
15147 +                lead=,
15148 +                back=,
15149 +                startsum=,
15150 +                accumulate=,
15151 +                seasonality=,
15152 +                alpha=,
15153 +                extendedvalue=,
15154 +                outest = ,
15155 +                outdata = ,
15156 +                outfor = ,
15157 +                outstat = ,
15158 +                outsum=
15159 +   );
15162 +   %if &tsidvar eq _SEGMENT_ %then %do;
15163 +       proc sort data=&indata out=_tmpdata;
15164 +            by  &tsidvar %EM_CROSSID &timeid ;
15165 +       run;
15166 +       proc timeseries  data =_tmpdata out=_tmpdata;
15167 +            by  &tsidvar %EM_CROSSID;
15168 +            id &timeid interval=&timeinterval accumulate=&accumulate;
15169 +            var &target / ;
15170 +       run;
15171 +       proc esm data =_tmpdata
15172 +   %end;
15173 +   %else %do;
15174 +       proc sort data= &indata out=_tmpdata;
15175 +            by  &tsidvar %EM_CROSSID &timeid ;
15176 +       run;
15177 +       proc esm data = _tmpdata
15178 +   %end;
15179 +            lead=&lead  back=&back startsum=&startsum
15181 +   %if &seasonality ne DEFAULT %then %do;
15182 +            seasonality = &seasonality
15183 +   %end;
15186 +            out=&outdata
15187 +            outest=&outest
15188 +            outfor =&outfor
15189 +            outstat=&outstat
15190 +            outsum= &outsum
15191 +       ;
15192 +        id &timeid  interval = &timeinterval   accumulate=&accumulate ;
15194 +        %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15195 +            %if &target ne %then %do;
15196 +            forecast &target   /  model = none alpha=&alpha;
15197 +            %end;
15198 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15199 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /  model = &method alpha=&alpha use=&extendedvalue;
15200 +            %end;
15201 +        %end;
15202 +        %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
15203 +            %if &target ne %then %do;
15204 +            forecast &target /  model =&method alpha=&alpha;
15205 +            %end;
15206 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15207 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
15208 +            %end;
15209 +        %end;
15210 +        %else %do; /* for KLD, FORECAST Cluster , SIMILARITY */
15211 +            forecast &target /*%EM_INTERVAL_INPUT*/ /  model = &method alpha=&alpha use=predict;
15212 +        %end;
15214 +   %if &tsidvar ne %then %do;
15215 +        by &tsidvar %EM_CROSSID ;
15216 +   %end;
15217 +   run;
15218 +%mend EM_TSESM_Forecast;
15221 +%macro EM_TSESM_CreateOutFor(indata=,
15222 +                            target=,
15223 +                            timeid=,
15224 +                            tsidVar=,
15225 +                            percent=,
15226 +                            outdata=);
15228 +  %let lowerBound = L&percent;
15229 +  %let upperBound = U&percent;
15231 +  data ds_fore(rename=(&target=FORECAST)  drop=_TYPE_)
15232 +       ds_resid(rename=(&target=RESIDUAL) drop=_TYPE_)
15233 +       ds_act(rename=(&target=ACTUAL) drop=_TYPE_)
15234 +       ds_lower(rename=(&target=LBOUND)  drop=_TYPE_)
15235 +       ds_upper(rename=(&target=UBOUND) drop=_TYPE_)
15236 +       ds_std(rename=(&target=STD) drop=_TYPE_);
15237 +     set &indata;
15238 +       if _TYPE_="FORECAST" then output ds_fore;
15239 +       if _TYPE_="RESIDUAL" then output ds_resid;
15240 +       if _TYPE_="ACTUAL" then output ds_act;
15241 +       if _TYPE_="&lowerBound" then output ds_lower;
15242 +       if _TYPE_="&upperBound" then output ds_upper;
15243 +       if _TYPE_="STD" then output ds_std;
15244 +  run;
15246 +  data &outdata;
15247 +       merge ds_fore ds_resid ds_act ds_lower ds_upper ds_std;
15248 +       by &tsidVar &timeid;
15249 +       label  FORECAST = "Forecast";
15250 +       label  ACTUAL = "Actual";
15251 +       label  RESIDUAL = "Residual";
15252 +       label  LBOUND = "Lower Bound";
15253 +       label  UBOUND = "Upper Bound";
15254 +       label   STD = "Standard Deviation";
15255 +  run;
15256 +%mend EM_TSESM_CreateOutFor;
15259 +%macro EM_TSESM_CreateOutExpand(indata=,
15260 +                       target=,
15261 +                       timeid=,
15262 +                       tsidVar=,
15263 +                       percent=,
15264 +                       outlower=,
15265 +                       outupper=,
15266 +                       outdata=);
15268 +  %let lowerBound = L&percent;
15269 +  %let upperBound = U&percent;
15271 +  /*proc print data=&indata(obs=200);
15272 +  run;
15273 +  */
15275 +  data ds_fore(drop=&target)
15276 +       ds_lower(drop=&target)
15277 +       ds_upper(drop=&target)
15278 +       ds_act;
15279 +     set &indata;
15280 +       if _TYPE_="FORECAST" and _LEAD_  > 0 then output ds_fore;
15281 +       if _TYPE_="&lowerBound" and  _LEAD_  > 0 then output ds_lower;
15282 +       if _TYPE_="&upperBound" and  _LEAD_  > 0 then output ds_upper;
15283 +       if _TYPE_="ACTUAL" then output ds_act;
15284 +  run;
15286 +  /*
15287 +  proc print data = ds_fore;
15288 +  proc print data=ds_act;
15289 +  run;
15290 +  */
15291 +  data &outdata;
15292 +       merge ds_act ds_fore;
15293 +       by &tsidVar &timeid;
15294 +  run;
15296 +  data &outlower;
15297 +       merge ds_act ds_lower;
15298 +       by &tsidVar &timeid;
15299 +  run;
15301 +  data &outupper;
15302 +       merge ds_act ds_upper;
15303 +       by &tsidVar &timeid;
15304 +  run;
15305 +  /*
15306 +  proc print data=&outdata(obs=300);
15307 +  proc print data=&outlower(obs=300);
15308 +  proc print data=&outupper(obs=300);
15309 +  run;
15310 +  */
15311 +%mend EM_TSESM_CreateOutExpand;
15315 +%macro EM_TSESM_MakeOutClus(indata=,
15316 +                   target=,
15317 +                   timeid=,
15318 +                   tsidVar=,
15319 +                   percent=,
15320 +                   outlower=,
15321 +                   outupper=,
15322 +                   outdata=);
15325 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
15327 +  data &outdata(rename=(_NAME_ =_NAMEID_));
15328 +       set &indata;
15329 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD;
15330 +  run;
15332 +  %let dsid=%sysfunc(open(&outdata));
15333 +  %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
15334 +  %let dsid=%sysfunc(close(&dsid));
15336 +  %if &vn_name > 0 %then %do;
15337 +      data &outdata(drop=_NAMEID_);
15338 +           merge &EM_USER_TSIDMAP &outdata;
15339 +           by _TSID_;
15340 +      run;
15341 +  %end;
15342 +  %else %do;
15343 +      proc sort data= &outdata; by _NAMEID_;
15344 +      run;
15345 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
15346 +      run;
15347 +      data &outdata(drop=_NAMEID_);
15348 +           merge &EM_USER_TSIDMAP &outdata;
15349 +           by _NAMEID_;
15350 +      run;
15351 +  %end;
15353 +%mend EM_TSESM_MakeOutClus;
15356 +%macro EM_TSESM_CreateOutEst(indata=,
15357 +                    target=,
15358 +                    timeid=,
15359 +                    outdata=);
15361 +%mend EM_TSESM_CreateOutEst;
15364 +%macro EM_TSESM_Best_Forecast(indata=,
15365 +                method=,
15366 +                timeinterval=,
15367 +                timeid= ,
15368 +                target= ,
15369 +                tsidvar=,
15370 +                lead=,
15371 +                back=,
15372 +                startsum=,
15373 +                accumulate=,
15374 +                seasonality=,
15375 +                alpha=,
15376 +                criterion=,
15377 +                extendedvalue=,
15378 +                outest = ,
15379 +                outdata = ,
15380 +                outfor = ,
15381 +                outstat = ,
15382 +                outsum=
15383 +   );
15385 +   %let _indata = &indata;
15387 +   %if &tsidvar eq _SEGMENT_ %then %do;
15388 +       proc sort data=&indata out=_tmpdata;
15389 +            by  &tsidvar %EM_CROSSID &timeid ;
15390 +       run;
15391 +       proc timeseries  data =_tmpdata out=_tmpdata;
15392 +            by  &tsidvar %EM_CROSSID ;
15393 +            id &timeid interval=&timeinterval accumulate=&accumulate;
15394 +            var &target / ;
15395 +       run;
15396 +       %let _indata = _tmpdata;
15397 +   %end;
15399 +   %let n_model = 0;
15401 +   %if &EM_PROPERTY_SIMPLE eq Y %then %do;
15403 +       %let n_model = %eval(&n_model+1);
15405 +       %let _ds_out =_out&n_model;
15406 +       %let _ds_outest =_outest&n_model;
15407 +       %let _ds_outfor =_outfor&n_model;
15408 +       %let _ds_outstat =_outstat&n_model;
15409 +       %let _ds_outsum=_outsum&n_model;
15411 +       %EM_TSESM_ESM(method=SIMPLE,
15412 +        timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15413 +        lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15414 +        out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15415 +        );
15417 +   %end;
15418 +   %if &EM_PROPERTY_DOUBLE eq Y %then %do;
15420 +       %let n_model = %eval(&n_model+1);
15422 +       %let _ds_out =_out&n_model;
15423 +       %let _ds_outest =_outest&n_model;
15424 +       %let _ds_outfor =_outfor&n_model;
15425 +       %let _ds_outstat =_outstat&n_model;
15426 +       %let _ds_outsum=_outsum&n_model;
15428 +       %EM_TSESM_ESM(method=DOUBLE,
15429 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15430 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15431 +             out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15432 +       );
15433 +   %end;
15435 +   %if &EM_PROPERTY_LINEAR eq Y %then %do;
15437 +       %let n_model = %eval(&n_model+1);
15438 +       %let _ds_out =_out&n_model;
15439 +       %let _ds_outest =_outest&n_model;
15440 +       %let _ds_outfor =_outfor&n_model;
15441 +       %let _ds_outstat =_outstat&n_model;
15442 +       %let _ds_outsum=_outsum&n_model;
15444 +       %EM_TSESM_ESM(method=LINEAR,
15445 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15446 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15447 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15448 +        );
15449 +   %end;
15451 +   %if &EM_PROPERTY_DAMPTREND eq Y %then %do;
15453 +       %let n_model = %eval(&n_model+1);
15455 +       %let _ds_out =_out&n_model;
15456 +       %let _ds_outest =_outest&n_model;
15457 +       %let _ds_outfor =_outfor&n_model;
15458 +       %let _ds_outstat =_outstat&n_model;
15459 +       %let _ds_outsum=_outsum&n_model;
15461 +       %EM_TSESM_ESM(method=DAMPTREND,
15462 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15463 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15464 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15465 +            );
15466 +   %end;
15467 +   /*------- Seasonal model ------*/
15469 +   %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do;
15471 +   %if (&EM_PROPERTY_WINTERS eq Y) %then %do;
15473 +       %let n_model = %eval(&n_model+1);
15475 +       %let _ds_out =_out&n_model;
15476 +       %let _ds_outest =_outest&n_model;
15477 +       %let _ds_outfor =_outfor&n_model;
15478 +       %let _ds_outstat =_outstat&n_model;
15479 +       %let _ds_outsum=_outsum&n_model;
15481 +       %EM_TSESM_ESM(method=WINTERS,
15482 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15483 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15484 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15485 +        );
15486 +   %end;
15488 +   %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then %do;
15490 +       %let n_model = %eval(&n_model+1);
15492 +       %let _ds_out =_out&n_model;
15493 +       %let _ds_outest =_outest&n_model;
15494 +       %let _ds_outfor =_outfor&n_model;
15495 +       %let _ds_outstat =_outstat&n_model;
15496 +       %let _ds_outsum=_outsum&n_model;
15498 +       %EM_TSESM_ESM(method=ADDSEASONAL,
15499 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15500 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15501 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15502 +       );
15503 +   %end;
15505 +   %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %do;
15507 +       %let n_model = %eval(&n_model+1);
15509 +       %let _ds_out =_out&n_model;
15510 +       %let _ds_outest =_outest&n_model;
15511 +       %let _ds_outfor =_outfor&n_model;
15512 +       %let _ds_outstat =_outstat&n_model;
15513 +       %let _ds_outsum=_outsum&n_model;
15515 +       %EM_TSESM_ESM(method=MULTSEASONAL,
15516 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15517 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15518 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15519 +       );
15520 +   %end;
15522 +   %if (&EM_PROPERTY_ADDWINTERS eq Y) %then %do;
15524 +       %let n_model = %eval(&n_model+1);
15526 +       %let _ds_out =_out&n_model;
15527 +       %let _ds_outest =_outest&n_model;
15528 +       %let _ds_outfor =_outfor&n_model;
15529 +       %let _ds_outstat =_outstat&n_model;
15530 +       %let _ds_outsum=_outsum&n_model;
15532 +       %EM_TSESM_ESM(method=ADDWINTERS,
15533 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
15534 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
15535 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
15536 +            );
15537 +   %end;
15540 +   %end; /* end of %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do; */
15541 +   /*-------- end of seasonal model  ------------------------------------------------------*/
15543 +   %if &n_model eq 0 %then %do;
15545 +       /*---- %PUT  ERROR:THE NUMBER OF CANDIDATE MODELS IS ZERO;  */
15546 +       %let  EMEXCEPTIONSTRING = exception.server.tsdm.zerocandidatemodel;
15547 +   %end;
15548 +   %else %do;
15549 +         %EM_TSESM_BestModelSel(crit=&criterion,
15550 +                               n_mdl=&n_model,
15551 +                               tsidvar=&tsidvar,
15552 +                               timeid=&timeid,
15553 +                               out=&outdata,
15554 +                               outest=&outest,
15555 +                               outfor =&outfor,
15556 +                               outstat=&outstat,
15557 +                               outsum=&outsum
15558 +                  );
15559 +   %end;
15561 +%mend EM_TSESM_Best_Forecast;
15564 +%macro EM_TSESM_ESM(method= ,
15565 +           timeinterval=,
15566 +           timeid= ,
15567 +           target= ,
15568 +           tsidvar=,
15569 +           lead=,
15570 +           back=,
15571 +           startsum=,
15572 +           accumulate=,
15573 +           seasonality=,
15574 +           alpha=,
15575 +           out= ,
15576 +           outest= ,
15577 +           outfor= ,
15578 +           outstat= ,
15579 +           outsum=
15580 +           );
15582 +       proc sort data= &_indata out=_tmpdata;
15583 +            by  &tsidvar %EM_CROSSID &timeid ;
15584 +       run;
15585 +       proc esm data = _tmpdata  lead=&lead    back=&back  startsum=&startsum
15587 +       %if &seasonality ne DEFAULT %then %do;
15588 +                     seasonality = &seasonality
15589 +       %end;
15590 +            out=&out
15591 +            outest=&outest
15592 +            outfor =&outfor
15593 +            outstat=&outstat
15594 +            outsum= &outsum
15595 +            ;
15596 +       id &timeid  interval = &timeinterval  accumulate=&accumulate  ;
15598 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15599 +            %if &target ne %then %do;
15600 +            forecast &target   /  model = none alpha=&alpha;
15601 +            %end;
15602 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15603 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha use=&extendedvalue;
15604 +            %end;
15605 +       %end;
15606 +       %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
15607 +            %if &target ne %then %do;
15608 +            forecast &target /  model =&method alpha=&alpha;
15609 +            %end;
15610 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15611 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
15612 +            %end;
15613 +       %end;
15614 +       %else %do;   /*----- CLUSTER INPUT , KLD, SIMILARITY INPUT ------*/
15615 +            %if &target ne %then %do;
15616 +            forecast &target   /  model = &method alpha=&alpha;
15617 +            %end;
15618 +            /*
15619 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
15620 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha;
15621 +            %end;
15622 +            */
15623 +       %end;
15625 +       %if &tsidvar ne %then %do;
15626 +        by &tsidvar %EM_CROSSID;
15627 +       %end;
15628 +       run;
15630 +%mend EM_TSESM_ESM;
15634 +%macro EM_TSESM_BestModelSel(crit=,
15635 +                    n_mdl=,
15636 +                    tsidvar=_TSID_,
15637 +                    timeid=MNTH_YR,
15638 +                    out=&_outdata,
15639 +                    outest=&_outest,
15640 +                    outfor =&_outfor,
15641 +                    outstat=&_outstat,
15642 +                    outsum=&_outsum
15643 +    );
15645 +   %let statbls=select *, 1 as mdlID from _outstat1;
15646 +   %let estbls=select *,  1 as mdlID from _outest1;
15647 +   %let fortbls=select *, 1 as mdlID from _outfor1;
15648 +   %let outbls=select *,  1 as mdlID from _out1;
15649 +   %let sumtbls=select *, 1 as mdlID from _outsum1;
15650 +   %do i=2 %to &n_mdl;
15651 +      %let statbls=&statbls union all select *, &i as mdlID from _outstat&i;
15652 +        %let estbls=&estbls union all select *, &i as mdlID from _outest&i;
15653 +        %let fortbls=&fortbls union all select *, &i as mdlID from _outfor&i;
15654 +        %let outbls=&outbls union all select *, &i as mdlID from _out&i;
15655 +        %let sumtbls=&sumtbls union all select *, &i as mdlID from _outsum&i;
15656 +   %end;
15658 +   %let dsid=%sysfunc(open(_out1));
15659 +   %let vn_tsid = 0;
15661 +   %if &dsid > 0 %then %do;
15662 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
15663 +         %let dsid = %sysfunc(close(&dsid));
15664 +   %end;
15666 +   %if &vn_tsid <= 0  %then %do;
15667 +       %let tsidvar=_NAME_;
15668 +   %end;
15670 +  /*
15671 +  %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15672 +     %let tsidvar=_NAME_;
15673 +   %end;
15674 +  */
15676 +   proc sql;
15677 +     create table tsstat as &statbls;
15678 +     create table tsest  as &estbls;
15679 +     create table tsfor  as &fortbls;
15680 +     create table tsout  as &outbls;
15681 +     create table tssum  as &sumtbls;
15682 +   quit;
15684 +    proc sort data=tsstat out=bestmdl;
15685 +        by &tsidvar &crit mdlID;
15686 +    run;
15688 +    * when multiple BEST model found;
15689 +    * use the one with smallest model ID;
15690 +    data bestmdl;
15691 +        set bestmdl;
15692 +        by &tsIDvar;
15693 +        if first.&tsIDVar;
15694 +    run;
15696 +   proc sql;
15697 +      create table bestID as
15698 +        select distinct(tsest.&tsidvar), _model_, &crit, bestmdl.mdlID
15699 +        from bestmdl,tsest
15700 +        where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar;
15702 +      create table &outfor
15703 +        as select tsfor.*, _model_, &crit from tsfor, bestID
15704 +        where tsfor.&tsidvar=bestID.&tsidvar and tsfor.mdlID=bestID.mdlID order by &tsidvar, &timeid;
15706 +        create table &outstat
15707 +        as select tsstat.*, _model_ from tsstat, bestID
15708 +      where tsstat.&tsidvar=bestID.&tsidvar and tsstat.mdlID=bestID.mdlID order by &tsidvar;
15710 +        create table &outest
15711 +        as select tsest.*, &crit from bestmdl, tsest
15712 +      where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar order by &tsidvar;
15714 +      create table &outsum
15715 +        as select tssum.*, _model_, &crit from tssum, bestID
15716 +      where tssum.&tsidvar=bestID.&tsidvar and tssum.mdlID=bestID.mdlID order by &tsidvar;
15718 +      /*
15719 +      %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
15720 +        create table &out
15721 +          as select tsout.*, _model_, &crit from tsout, bestID
15722 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
15723 +      %end;
15724 +      */
15726 +      %if &tsidvar eq _TSID_ %then %do;
15728 +         create table &out
15729 +          as select tsout.*, _model_, &crit from tsout, bestID
15730 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
15732 +      %end;
15733 + run;
15734 +quit;
15736 + /*%if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
15738 + %if &tsidvar = _NAME_ %then %do;
15739 +      data
15740 +            %let i=1;
15741 +            %do i=1 %to &n_mdl;
15742 +               %let _tmpdsname = _tmpds&i;
15743 +                    &_tmpdsname
15744 +            %end;
15745 +        ;
15746 +         set work.Bestmdl;
15747 +            %let i=1;
15748 +            %do i=1 %to &n_mdl;
15749 +               %let _tmpdsname = _tmpds&i;
15750 +                  if mdlID = &i then output &_tmpdsname;
15751 +            %end;
15752 +      run;
15754 +      data &out;
15755 +           set _out1;
15756 +           keep &timeid %EM_TARGET;
15757 +      run;
15758 +      %let i=1;
15759 +      %do i=1 %to &n_mdl;
15760 +          %let _tmpdsname = _tmpds&i;
15761 +          %let _outdsname = _out&i;
15763 +          data &out;
15764 +               set &out;
15765 +               set &_outdsname(keep=
15766 +               %let dsid=%sysfunc(open(&_tmpdsname));
15767 +               %if &dsid > 0 %then %do;
15768 +                  %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
15769 +                  %do %while(^%sysfunc(fetch(&dsid)));
15770 +                     %let _name  = %sysfunc(getvarc(&dsid, &vn_name));
15771 +                          &_name
15772 +                  %end;
15773 +                  %let dsid = %sysfunc(close(&dsid));
15774 +               %end;
15775 +               );
15776 +           run;
15777 +       %end;
15779 +%end;
15781 +data &out;
15782 +     set  &out;
15783 +      drop mdlID _MODEL_ &crit;
15784 +data &outest;
15785 +      set  &outest;
15786 +      drop mdlID &crit;
15787 +data &outfor;
15788 +     set &outfor;
15789 +     drop mdlID &crit;
15790 +data &outstat;
15791 +     set &outstat;
15792 +     drop mdlID;
15793 +data &outsum;
15794 +     set &outsum;
15795 +     drop mdlID &crit;
15796 +run;
15798 +%mend EM_TSESM_BestModelSel;
15802 +%macro EM_TSESM_MakeOutlierIndex(indata=,
15803 +                        target=,
15804 +                        timeid=,
15805 +                        outoutlier=,
15806 +                        outlierds=,
15807 +                        outdata=);
15808 +%let label_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlier, noquote));
15809 +%let str_Actual_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actualoutlier, noquote));
15810 +%let str_Actual = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actual, noquote));
15811 +data &outdata;
15812 +     set &indata;
15813 +     length OutlierIndex 8.;
15814 +     length Outlier  $40;
15815 +     label  OutlierIndex = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlierindex, noquote))";
15816 +     label  Outlier = "&label_Outlier";
15817 +   /*  if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&label_Outlier";end;
15818 +       else  do; OutlierIndex=0; outlier =" "; end; */
15819 +     if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&str_Actual_Outlier";end;
15820 +       else  do; OutlierIndex=0; outlier ="&str_Actual"; end;
15821 +run;
15823 +data  &outoutlier;
15824 +      set  &outdata;
15825 +      keep &timeid _TSID_ _SEGMENT_ _NAME_ _NAMEID_ OUTLIERINDEX OUTLIER PREDICT;
15826 +      if ACTUAL = . then delete;
15827 +run;
15829 +data &outlierds;
15830 +     set &outoutlier;
15831 +     if OUTLIERINDEX = 0 then delete;
15832 +     Drop OUTLIERINDEX;
15833 +run;
15835 +%mend  EM_TSESM_MakeOutlierIndex;
15838 +%macro EM_TSESM_MakeSmoothedOutds(indata=,
15839 +                         inoutlierds=,
15840 +                         target=,
15841 +                         timeid=,
15842 +                         tsidvar=_TSID_,
15843 +                         replace=,
15844 +                         outdata=);
15847 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
15850 +%let dsid=%sysfunc(open(&indata));
15851 +%let vn_tsid = 0;
15852 +%if &dsid > 0 %then %do;
15853 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
15854 +         %let dsid = %sysfunc(close(&dsid));
15855 +%end;
15857 +%if &vn_tsid <= 0  %then %do;
15858 +    %let tsidvar=_NAME_;
15859 +%end;
15861 +%if &tsidvar = _TSID_ %then %do;
15862 +/* %if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
15863 + /*    data &outdata;
15864 +          merge &indata &inoutlierds;
15865 +          by _TSID_ &timeid;
15866 +          if OutlierIndex > 0 then
15867 +          %if &replace eq PREDICT %then %do;
15868 +             &target = PREDICT;
15869 +          %end;
15870 +          %else %do;
15871 +             &target = .;
15872 +          %end;
15873 +           Drop Predict _NAME_ OutlierIndex;
15874 +     run;     */
15875 +  %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
15876 +     %if &dsid > 0 %then %do;
15877 +         %let vn_nameid =%sysfunc(varnum(&dsid, _VARNAME_));
15878 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
15879 +         %let i = 1;
15880 +              %do %while(^%sysfunc(fetch(&dsid)));
15881 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
15882 +                  %let _vartsid= %sysfunc(getvarn(&dsid, &vn_tsid));
15883 +                  %if &i eq 1 %then %do;
15884 +                      data _tmpoutlier;
15885 +                           set &inoutlierds;
15886 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid then output;
15887 +                      run;
15888 +                      data &outdata;
15889 +                           merge &indata _tmpoutlier;
15890 +                           by _TSID_ &timeid ;
15891 +                           if OutlierIndex  > 0 then
15892 +                              %if &replace eq PREDICT %then %do;
15893 +                                &_varname = PREDICT;
15894 +                              %end;
15895 +                              %else %do;
15896 +                                &_varname = .;
15897 +                              %end;
15898 +                            Drop Predict _NAME_  OutlierIndex Outlier;
15899 +                      run;
15900 +                   %end;
15901 +                   %else %do;
15902 +                      data _tmpoutlier;
15903 +                           set &inoutlierds;
15904 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid  then output;
15905 +                      run;
15906 +                      data &outdata;
15907 +                           merge &outdata _tmpoutlier;
15908 +                           by _TSID_ &timeid ;
15909 +                           if OutlierIndex  > 0 then
15910 +                              %if &replace eq PREDICT %then %do;
15911 +                                &_varname = PREDICT;
15912 +                              %end;
15913 +                              %else %do;
15914 +                                &_varname = .;
15915 +                              %end;
15916 +                           Drop Predict _NAME_  OutlierIndex Outlier;
15917 +                      run;
15918 +                   %end;
15919 +                   %let i = %eval(&i+1);
15921 +              %end;
15922 +           %let dsid = %sysfunc(close(&dsid));
15923 +      %end;
15924 +%end;
15925 +%else %do;  /*  %if &tsidvar = _NAME_ %then %do; */
15927 +     %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
15928 +     %if &dsid > 0 %then %do;
15929 +         %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
15930 +         %let i = 1;
15931 +              %do %while(^%sysfunc(fetch(&dsid)));
15932 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
15933 +                  %if &i eq 1 %then %do;
15934 +                      data _tmpoutlier;
15935 +                           set &inoutlierds;
15936 +                           if _NAME_ ="&_varname"  then output;
15937 +                      run;
15938 +                      data &outdata;
15939 +                           merge &indata _tmpoutlier;
15940 +                           by &timeid;
15941 +                           if OutlierIndex  > 0 then
15942 +                              %if &replace eq PREDICT %then %do;
15943 +                                &_varname = PREDICT;
15944 +                              %end;
15945 +                              %else %do;
15946 +                                &_varname = .;
15947 +                              %end;
15948 +                            Drop Predict _NAME_ OutlierIndex Outlier;
15949 +                      run;
15950 +                   %end;
15951 +                   %else %do;
15952 +                      data _tmpoutlier;
15953 +                           set &inoutlierds;
15954 +                           if _NAME_ ="&_varname"  then output;
15955 +                      run;
15956 +                      data &outdata;
15957 +                           merge &outdata _tmpoutlier;
15958 +                           by &timeid;
15959 +                           if OutlierIndex  > 0 then
15960 +                              %if &replace eq PREDICT %then %do;
15961 +                                &_varname = PREDICT;
15962 +                              %end;
15963 +                              %else %do;
15964 +                                &_varname = .;
15965 +                              %end;
15966 +                           Drop Predict _NAME_ OutlierIndex Outlier;
15967 +                      run;
15968 +                   %end;
15969 +                   %let i = %eval(&i+1);
15971 +              %end;
15972 +           %let dsid = %sysfunc(close(&dsid));
15973 +      %end;
15974 +      %else %do;
15975 +            /* this block is added 09022011*/
15976 +            /* works for wide table in which each time series has a column */
15978 +            proc transpose data=&indata out=_tmpdata1;
15979 +                by &timeID;
15980 +            run;
15982 +            proc sql;
15983 +                create table _tmpdata2 as
15984 +                    select a.*, b.outlierindex, b.outlier, b.predict
15985 +                        from _tmpdata1 as a left join &inoutlierds as b
15986 +                            on a.&timeID eq b.&timeID and a._name_ eq b._name_
15987 +                        order by a.&timeID, a._name_
15988 +                    ;
15989 +            quit;
15991 +            data _tmpdata2;
15992 +                set _tmpdata2;
15993 +                if outlierindex eq 1 then
15994 +                    if &replace eq PREDICT then col1=predict; else col1=.;
15995 +            run;
15997 +            proc transpose data=_tmpdata2 out=_tmpdata3(drop=_name_ _label_);
15998 +                by &timeID;
15999 +                ID _name_;
16000 +                var col1;
16001 +            proc sort data=&inoutlierds out=_tmpoutlier;
16002 +                by &timeID _name_;
16003 +            proc transpose data=_tmpoutlier out=_tmpdata4(drop=_name_ _label_) prefix=Outlier_;
16004 +                by &timeID;
16005 +                ID _name_;
16006 +                var outlier;
16007 +            run;
16009 +            data &outdata;
16010 +                merge _tmpdata3 _tmpdata4;
16011 +                by &timeID;
16012 +            run;
16013 +      %end;
16014 +%end;
16015 +%mend EM_TSESM_MakeSmoothedOutds;
16017 +%Macro EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
16018 +                  insumdata=&EM_USER_OUTSUM,
16019 +                target=&_targetVar,
16020 +                timeid=&_timeidVar,
16021 +                futurepoint=1,
16022 +                outKLD=&EM_USER_OUTKLD
16023 +                );
16025 +%if &futurepoint > 0 %then %do;
16027 +proc sort data=&indata out=_tmptimeid;
16028 +     by &timeid;
16029 +run;
16031 +data _tmptimeid(keep=&timeid);
16032 +      set _tmptimeid; by &timeid;
16033 +      if first.&timeid then output;
16034 +run;
16036 +%let _targetTime =;
16037 +%let dsid=%sysfunc(open(work._tmptimeid));
16038 +%if &dsid > 0 %then %do;
16039 +    %let vn_timeid =%sysfunc(varnum(&dsid, &timeid));
16040 +    %let i = 1;
16041 +    %do %while(^%sysfunc(fetch(&dsid)));
16042 +       %if &i eq &futurepoint %then %do;
16043 +       %let _targetTime  = %sysfunc(getvarn(&dsid, &vn_timeid));
16044 +       %end;
16045 +       %let i = %eval(&i+1);
16046 +    %end;
16047 +    %let dsid = %sysfunc(close(&dsid));
16048 +%end;
16050 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
16051 +   set &indata;
16052 +   if &timeid eq &_targetTime then output;
16053 +run;
16055 +%end;  /* end of %if &futurepoint > 0 %then %do; */
16056 +%else %do;
16059 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
16060 +   set &insumdata;
16061 +run;
16064 +%end;
16066 +%EM_TSESM_KLD(indata=work._tmpKLD, outdata=&outKLD);
16068 +/* Merge TSIDMAP  */
16070 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16071 +data &outKLD(rename=(_NAME_ =_NAMEID_));
16072 +       set &outKLD;
16073 +run;
16075 +%let dsid=%sysfunc(open(&outKLD));
16076 +%let vn_name =%sysfunc(varnum(&dsid, _TSID_));
16077 +%let dsid=%sysfunc(close(&dsid));
16079 +%if &vn_name > 0 %then %do;
16080 +      data &outKLD(drop=_NAMEID_);
16081 +           merge &EM_USER_TSIDMAP &outKLD;
16082 +           by _TSID_;
16083 +      run;
16084 +%end;
16085 +%else %do;
16086 +      proc sort data= &outKLD; by _NAMEID_;
16087 +      run;
16088 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
16089 +      run;
16090 +      data &outKLD(drop=_NAMEID_);
16091 +           merge &EM_USER_TSIDMAP &outKLD;
16092 +           by _NAMEID_;
16093 +      run;
16094 +%end;
16096 +/* delete _tmptimeid  _tmpKLD */
16097 +%Mend  EM_TSESM_MakeOutKLD;
16100 +%Macro EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
16101 +                 target=&_targetVar,
16102 +                 timeid=&_timeidVar,
16103 +                 outdata=&EM_USER_OUTPRED
16104 +                 );
16106 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
16107 +%let _EndTime = ;
16108 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
16109 +%if &dsid > 0 %then %do;
16110 +    %let vn_end =%sysfunc(varnum(&dsid, END));
16111 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
16112 +    %do %while(^%sysfunc(fetch(&dsid)));
16113 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
16114 +       /*--------------------------------------------------------
16115 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
16116 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
16117 +        ---------------------------------------------------------*/
16118 +    %end;
16119 +    %let dsid = %sysfunc(close(&dsid));
16120 +%end;
16122 +data &outdata(keep= _TSID_ _NAME_  &timeid PREDICT LOWER UPPER STD);
16123 +     set &indata;
16124 +     if &timeid > &_EndTime then output;
16125 +run;
16126 +%Mend  EM_TSESM_MakeOutPred;
16129 +%macro EM_TSESM_KLD(indata=work._tmp, outdata=_out);
16131 +%let std_x = ;
16132 +%let mu_y = ;
16134 +%let dsid=%sysfunc(open(&indata));
16135 +%if &dsid > 0 %then %do;
16136 +    %let vn_pred =%sysfunc(varnum(&dsid, PREDICT));
16137 +    %let vn_std  = %sysfunc(varnum(&dsid, STD));
16138 +    %let i=1;
16139 +    %do %while(^%sysfunc(fetch(&dsid)));
16140 +        %let _pred  = %sysfunc(getvarn(&dsid, &vn_pred));
16141 +        %let _std  = %sysfunc(getvarn(&dsid, &vn_std));
16142 +        %let _tsid = _TSID&i.;
16143 +        /* create new data set */
16144 +            %if &i = 1 %then %do;
16145 +            data _tmpindata;
16146 +                set &indata;
16147 +                  mu_x = &_pred;
16148 +                  std_x = &_std;
16149 +                  rename predict = mu_y;
16150 +                  rename std = std_y;
16151 +            run;
16152 +        data _tmpout;
16153 +                 set _tmpindata;
16154 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
16155 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
16156 +             &_tsid= (KLD1+KLD2)/2;
16157 +             if &_tsid < 0 then &_tsid = 0;
16158 +                   drop KLD1 KLD2;
16159 +         run;
16160 +             %end;
16161 +         %else %do;
16162 +         data _tmpindata;
16163 +                  set _tmpout;
16164 +                  mu_x = &_pred;
16165 +                  std_x = &_std;
16167 +             run;
16168 +         data _tmpout;
16169 +                 set _tmpindata;
16170 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
16171 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
16172 +             &_tsid= (KLD1+KLD2)/2;
16173 +             if &_tsid < 0 then &_tsid = 0;
16174 +                   drop KLD1 KLD2;
16175 +         run;
16177 +         %end;
16178 +             %let i = %eval(&i+1);
16180 +    %end;
16181 +    %let dsid = %sysfunc(close(&dsid));
16182 +    data &outdata;
16183 +         set _tmpout;
16184 +         drop mu_x mu_y std_x std_y;
16185 +    run;
16186 +%end;
16187 +%mend EM_TSESM_KLD;
16190 +%macro EM_TSESM_MakeOutClusInput(indata=,
16191 +                   target=,
16192 +                   timeid=,
16193 +                   tsidVar=,
16194 +                   percent=,
16195 +                   outlower=,
16196 +                   outupper=,
16197 +                   esmmethod=,
16198 +                   criterion=,
16199 +                   outdata=);
16201 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16203 +  data &outdata(rename=(_NAME_ =_NAMEID_));
16204 +       set &indata;
16205 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
16206 +  %if &esmmethod eq BEST %then %do;
16207 +      mdlID _MODEL_ &criterion
16209 +  %end;
16210 +  ;
16211 +  run;
16213 +  %let dsid=%sysfunc(open(&outdata));
16214 +       %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
16215 +  %let dsid=%sysfunc(close(&dsid));
16217 +  %if &vn_name > 0 %then %do;
16218 +      proc sort data= &outdata; by _TSID_;
16219 +      run;
16220 +      proc sort data = &EM_USER_TSIDMAP ;by _TSID_;
16221 +      run;
16223 +      data &outdata(drop=_NAMEID_);
16224 +           merge &EM_USER_TSIDMAP &outdata;
16225 +           by _TSID_;
16226 +      run;
16227 +  %end;
16228 +  %else %do;
16229 +      proc sort data= &outdata; by _NAMEID_;
16230 +      run;
16231 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
16232 +      run;
16233 +      data &outdata(drop=_NAMEID_);
16234 +           merge &EM_USER_TSIDMAP &outdata;
16235 +           by _NAMEID_;
16236 +      run;
16237 +  %end;
16239 +%mend EM_TSESM_MakeOutClusInput;
16241 +%macro EM_TSESM_MakeOutSimInput(indata=,
16242 +                   inoutfor=,
16243 +                   target=,
16244 +                   timeid=,
16245 +                   tsidVar=,
16246 +                   esmmethod=,
16247 +                   criterion=,
16248 +                   outdata=);
16251 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16252 +  %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
16254 +   %let _EndTime = ;
16255 +   %let dsid=%sysfunc(open(&EM_USER_TSMETA));
16256 +   %if &dsid > 0 %then %do;
16257 +   %let vn_end =%sysfunc(varnum(&dsid, END));
16258 +   %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
16259 +   %do %while(^%sysfunc(fetch(&dsid)));
16260 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
16261 +   %end;
16262 +   %let dsid = %sysfunc(close(&dsid));
16263 +   %end;
16265 +   %em_varMacro(name=tsesm_crossid, metadata= &EM_DATA_VARIABLESET, key=NAME,
16266 +       where=%nrbquote(ROLE='CROSSID' and USE ne 'N') , nummacro=tsesm_crossidNum);
16268 +   data _out1;
16269 +       set &indata;
16270 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
16271 +           %tsesm_crossid
16272 +   %if &esmmethod eq BEST %then %do;
16273 +      mdlID _MODEL_ &criterion
16274 +   %end;
16275 +   ;
16276 +   run;
16278 +    %let dsid=%sysfunc(open(work._out1));
16279 +    %if &dsid > 0 %then %do;
16280 +      %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
16281 +      %let dsid = %sysfunc(close(&dsid));
16282 +    %end;
16284 +    /*
16285 +    proc print data=_out1(obs=10);
16286 +    run;
16287 +    */
16288 +    %let _existtsid = Y;
16289 +    %if (&vn_tsid = 0)  %then %do;
16290 +    %let _existtsid = N;
16291 +    %goto NO_TSID_SIMINPUT;
16292 +    %end;
16294 +    data _out1;
16295 +        set _out1;
16296 +        where _name_ = "&target";
16297 +    run;
16298 +    %let target2 = &target._;
16299 +    proc transpose data=_out1 out=_out2 prefix=&target2;
16300 +            id _TSID_  ;
16301 +    run;
16302 +    /*
16303 +    proc print data=_out2(obs=11);
16304 +    run;
16305 +    */
16306 +    data _out2;
16307 +       length _index 8.;
16308 +       set _out2;
16309 +       _index=_N_;
16310 +       drop _NAME_ _LABEL_;
16311 +    run;
16314 +   data _out3;
16315 +       length _index 8.;
16316 +        set &inoutfor(where=(_TSID_=1 and &timeid > &_EndTime));
16317 +         _index =_N_;
16318 +        keep &timeid _index;
16320 +   run;
16321 +   /*
16322 +   proc print data=_out2(obs=12);
16323 +   proc print data =_out3(obs=13);
16324 +   run;
16325 +   */
16326 +   data &outdata(drop=_index);
16327 +        merge _out3 _out2;by _index;
16328 +        run;
16331 +  proc transpose data=&outdata out=_tout;
16332 +     id &timeid;
16333 +   run;
16334 +   data _tout;
16335 +        length _TSID_ 8.;
16336 +        set _tout;
16337 +        rename _NAME_= _NAMEID_;
16338 +        _TSID_ = _N_;
16339 +        label _NAME_ = "NAMEID";
16340 +        keep _NAME_ _TSID_;
16342 +   run;
16344 +   data &EM_USER_TSIDMAP;
16345 +        merge  _tout  &EM_USER_TSIDMAP; by _TSID_;
16346 +   run;
16347 +   /*
16348 +   proc print data=_tout(obs=14);
16349 +   run;
16350 +   */
16351 +   proc datasets lib=work nolist;
16352 +      delete  _out1 _tmpout1 _out2 _out3 _tout;
16353 +   run;
16356 +   %NO_TSID_SIMINPUT:
16357 +   %if  &_existtsid eq N %then %do;
16358 +   data &outdata;
16359 +        set &inoutfor(where=(&timeid > &_EndTime));
16360 +   run;
16361 +   %end;
16364 +%mend EM_TSESM_MakeOutSimInput;
16367 +%macro EM_TS_CONVERT_LONG_TO_WIDE(indata=, outdata=, wherevar=, nwherevalue=, targetvar=, timeid=);
16368 +%do i=1 %to &nwherevalue;
16369 +     %if &i = 1 %then %do;
16370 +        data &outdata(drop = &wherevar);
16371 +             set &indata;
16372 +               if &wherevar= &i;
16373 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
16374 +               %else %let newname = &wherevar_&i;
16375 +                rename  &targetvar= &newname;
16376 +                   label &targetvar ="&targetvar._&i";
16377 +           run;
16378 +       %end;
16379 +       %else %do;
16380 +        data _tmp_out(drop = &wherevar);
16381 +             set &indata;
16382 +               if &wherevar= &i;
16383 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
16384 +               %else %let newname = &wherevar_&i;
16385 +                rename  &targetvar= &newname;
16386 +                   label &targetvar ="&targetvar._&i";
16387 +           run;
16388 +             data &outdata;
16389 +                  merge &outdata  _tmp_out; by &timeid;
16390 +         run;
16391 +       %end;
16392 +%end;
16394 +%EM_TS_DELETE_DATA(lib=work, data=_tmp_out);
16396 +%mend EM_TS_CONVERT_LONG_TO_WIDE;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
16398 +/*
16399 +       MACRO: TS Utility macros
16401 +       PURPOSE: TS Utility macros
16402 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
16404 +       HISTORY:
16405 +       NOTE:
16407 +*/
16409 +/*
16410 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
16411 +                          timeid=, timeformat=, timeinformat=);
16412 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
16414 +    %do;
16415 +    %let m_data      = &data;
16416 +    %let m_decdata   = &decdata;
16417 +    %let m_decmeta   = &decmeta;
16418 +    %let m_cmeta     = &cmeta;
16419 +    %let m_outfile   = &outfile;
16420 +    %let m_crossid   = &crossid;
16421 +    %let m_timeid    = &timeid;
16422 +    %let m_timeformat    = &timeformat;
16423 +    %let m_timeinformat    = &timeinformat;
16424 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
16425 +  %end;
16426 +%mend EM_TS_CreateTsMetaDs;
16427 +*/
16428 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
16429 +proc sql;
16430 +      create table _tmp_inds
16431 +      as select distinct &timeid from  &indata;
16432 +quit;
16433 +run;
16434 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
16435 +  id &timeid
16436 +%if &timeinterval ne %then %do;
16437 +    %if &timeformattype eq DATE %then %do;
16438 +        interval=&timeinterval
16439 +    %end;
16440 +    %else %if &timeformattype eq DATETIME  %then %do;
16441 +        %let dttimeinterval= DT&timeinterval;
16442 +         interval=&dttimeinterval
16443 +    %end;
16444 +%end;
16445 +;
16446 +run;
16448 +data &outds;
16449 +     set _tmp_tsmeta;
16450 +     format START &timeformat;
16451 +     format END &timeformat;
16452 +     length APPLY_START_END $8;
16453 +     APPLY_START_END ="No";
16454 +     FORMAT = "&timeformat";
16455 +     ROLE ="TIMEID";
16456 +     rename TIMEID = NAME;
16457 +     rename SEASONALITY= LengthOfCycle;
16458 +     rename INTERVAL = TIMEINTERVAL ;
16459 +     rename FORMAT = TIMEFORMAT;
16460 +     output;
16461 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
16462 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
16463 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
16464 +run;
16466 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
16467 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
16469 +%mend EM_TS_CreateTSMetaData;
16473 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
16475 +/* if updated = Y it will pass the TSMETA created by just the previous node */
16477 +%let _tsmetads = ;
16479 +%if &updated = Y %then %do;
16480 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
16481 +%if %sysfunc(exist(&_tsmetads)) %then %do;
16482 +%goto endline;
16483 +%end;
16484 +%end;
16486 +%if &eminfodata eq %then %do;
16487 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
16488 +    data &EM_DATA_EMINFO;
16489 +         set &EM_IMPORT_DATA_EMINFO;
16490 +    run;
16491 +%end;
16492 +%else %do;
16493 +    %let dsid=%sysfunc(open(&eminfodata));
16494 +    data &EM_DATA_EMINFO;
16495 +         set &eminfodata;
16496 +    run;
16497 +%end;
16498 +%if &dsid > 0 %then %do;
16499 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
16500 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
16501 +    %do %while(^ %sysfunc(fetch(&dsid)));
16502 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
16503 +         %if &_key eq TSMETA %then %do;
16504 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
16505 +         %end;
16506 +    %end;
16507 +    %let dsid = %sysfunc(close(&dsid));
16508 +%end; /* the end of %if &dsid > 0 %then %do; */
16510 +%endline:
16512 +%if &_tsmetads ne %then %do;
16513 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
16514 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
16515 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
16516 +         data &EM_USER_TSMETA;
16517 +                   set &_tsmetads;
16518 +         run;
16519 +    %end;
16520 +%end;
16522 +*proc print data=&EM_DATA_EMINFO;
16523 +*proc print data=&EM_IMPORT_DATA_EMINFO;
16524 +*run;
16525 +%MEND EM_TS_GETTSMETA;
16528 +/*
16529 +%macro EM_GETTSMETAVARS(TimeInterval=);
16530 +%global &TimeInterval;
16531 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
16532 +%if &dsid > 0 %then %do;
16533 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
16534 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
16535 +%do %while(^ %sysfunc(fetch(&dsid)));
16536 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16537 +     %if &_role eq TIMEID %then %do;
16538 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
16539 +     %end;
16540 +%end;
16541 +%let dsid = %sysfunc(close(&dsid));
16542 +%end;
16543 +%MEND EM_GETTSMETAVARS;
16544 +*/
16545 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
16546 +%global &TimeInterval;
16547 +%global &TimeId;
16548 +%global &EndTime;
16549 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
16550 +proc print data=&EM_USER_TSMETA;
16551 +run;
16552 +%if &dsid > 0 %then %do;
16553 +%if &TimeInterval ne %then %do;
16554 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
16555 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
16556 +    %do %while(^ %sysfunc(fetch(&dsid)));
16557 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16558 +        %if &_role eq TIMEID %then %do;
16559 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
16560 +        %end;
16561 +     %end;
16562 +%end;
16563 +%if &TimeId ne %then %do;
16564 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
16565 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
16566 +    %do %while(^ %sysfunc(fetch(&dsid)));
16567 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16568 +        %if &_role eq TIMEID %then %do;
16569 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
16570 +        %end;
16571 +    %end;
16572 +%end;
16574 +%if &EndTime ne %then %do;
16575 +    %let vn_end =%sysfunc(varnum(&dsid, END));
16576 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
16577 +    %do %while(^ %sysfunc(fetch(&dsid)));
16578 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
16579 +        %if &_role eq TIMEID %then %do;
16580 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
16581 +        %end;
16582 +     %end;
16583 +%end;
16584 +%let dsid = %sysfunc(close(&dsid));
16585 +%end;
16586 +%MEND EM_TS_GETTSMETAVARS;
16590 +/*------------------------------------------------------------------
16592 +      Macro EM_GETTSIDMAP
16594 +------------------------------------------------------------------+*/
16597 +%macro EM_TS_GETTSIDMAP(updated=);
16599 +%let _tsidmap = ;
16601 +%if &updated = Y %then %do;
16602 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
16603 +%if %sysfunc(exist(&_tsidmap)) %then %do;
16604 +%goto endline;
16605 +%end;
16606 +%end;
16608 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
16609 +%if &dsid > 0 %then %do;
16610 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
16611 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
16612 +%do %while(^ %sysfunc(fetch(&dsid)));
16613 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
16614 +     %if &_key eq TSIDMAP %then %do;
16615 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
16616 +     %end;
16617 +%end;
16619 +%let dsid = %sysfunc(close(&dsid));
16620 +%end;
16622 +%endline:
16624 +%if &_tsidmap ne %then %do;
16626 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
16627 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16629 +%if %sysfunc(exist(&_tsidmap)) %then %do;
16630 +         data &EM_USER_TSIDMAP;
16631 +               set &_tsidmap;
16632 +         run;
16633 +    %end;
16634 +%end;
16635 +%MEND EM_TS_GETTSIDMAP;
16637 +/*------------------------------------------------------------------*/
16642 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
16643 +%global &value;
16646 +%let dsid = %sysfunc(open(&data));
16647 +%if &dsid > 0 %then %do;
16648 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
16649 +    %if &vn_var < 1 %then %do;
16650 +        %let &value = 0;
16651 +        %let dsid = %sysfunc(close(&dsid));
16652 +        %goto endline;
16653 +    %end;
16654 +%let dsid = %sysfunc(close(&dsid));
16655 +%end;
16657 +%let _tmp=_tmpDS;
16658 +proc means data=&data &stat;
16659 +     var &var;
16660 +     output out=&_tmp;
16661 +run;
16663 +%let dsid = %sysfunc(open(&_tmp));
16664 +%if &dsid > 0 %then %do;
16665 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
16666 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
16667 +     %do %while(^%sysfunc(fetch(&dsid)));
16668 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
16669 +         %if &_stat eq &stat %then %do;
16670 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
16671 +          %end;
16672 +      %end;
16673 +%let dsid = %sysfunc(close(&dsid));
16674 +%end;
16675 +proc datasets lib=work nolist;
16676 + delete &_tmp;
16677 +run;
16678 +%endline:
16679 +%MEND EM_TS_GET_STAT;
16682 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
16683 +%global &format;
16684 +%global &informat;
16685 +%let dsid = %sysfunc(open(&data));
16686 +%if &dsid > 0 %then %do;
16687 +%let vn_var =%sysfunc(varnum(&dsid, &var));
16688 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
16689 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
16690 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
16691 +%end;
16692 +%let dsid = %sysfunc(close(&dsid));
16693 +%end;
16694 +%MEND EM_TS_GET_VAR_FORMAT;
16696 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
16697 +      %if &lib eq %then %let lib=work;
16698 +       proc datasets lib=&lib nolist;
16699 +              delete &dsname;
16700 +       run;
16701 +%Mend  EM_TS_DELETE_DATA;
16704 +%macro EM_TS_GetNObs(inds=, nobs=);
16705 +    %global &nobs;
16706 +    %let &nobs=0;
16707 +    data _null_;
16708 +        set &inds end=eof;
16709 +        if eof then call symput("&nobs", _N_);
16710 +    run;
16711 +    quit;
16713 +    /*
16714 +    %let dsid=%sysfunc(open(&outdata));
16715 +    %if dsid > 0 %then %do;
16716 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
16717 +        %let dsid = %sysfunc(close(&dsid));
16718 +     %end;
16719 +    */
16720 +%mend  EM_TS_GetNObs;
16723 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
16724 +%global &time1;
16725 +%global &time2;
16726 +%if &default = Y %then %do;
16727 +   data _null_;
16728 +        set &data end=eof;
16729 +        if _N_ = 1 then  call symput("&time1", DATE);
16730 +        if eof then call symput("&time2", DATE);
16731 +    run;%end;
16732 +%else %do;
16733 +    %let dsid = %sysfunc(open(&data));
16734 +    %if &dsid > 0 %then %do;
16735 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
16736 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
16737 +        %do %while(^%sysfunc(fetch(&dsid)));
16738 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
16739 +             %if &_index eq 1 %then %do;
16740 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
16741 +             %end;
16742 +             %if &_index eq 2 %then %do;
16743 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
16744 +             %end;
16745 +        %end;
16746 +    %let dsid = %sysfunc(close(&dsid));
16747 +    %end;
16748 +%end;
16750 +%MEND EM_TS_GET_TIME_VALUES;
16752 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
16753 +%global &exist;
16754 + %let &exist = N;
16755 +%let dsid = %sysfunc(open(&data));
16756 +%if &dsid > 0 %then %do;
16757 +%let vn_var =%sysfunc(varnum(&dsid, &var));
16758 +%if &vn_var > 0 %then %do;
16759 +    %let &exist = Y;
16760 +%end;
16761 +%let dsid = %sysfunc(close(&dsid));
16762 +%end;
16763 +%MEND EM_TS_GET_VAR_EXIST;
16766 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
16767 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
16768 +      set &intreedata;
16769 +        LENGTH NodeType $32;
16770 +      if _PARENT_ eq " " then delete;
16771 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
16772 +        else NodeType = "CLUSTER";
16773 +        LinkID = _N_;
16774 +run;
16775 +%Mend EM_TS_MakeConstellPlotData;
16780 +%macro EM_TS_CreateIDMap(
16781 +/*-------------------------------------------------------------------------*/
16782 +/*---   Written by Xiangxiang Meng                                         */
16783 +/*-------------------------------------------------------------------------*/
16784 +inDS          =,      /* imported data set in TS data mining               */
16785 +outIDMap      =,      /* output data set of TS ID map                      */
16786 +outDS         =,      /* output data set of TS and TS ID merged            */
16787 +variableSet   =,      /* EM variable set                                   */
16788 +TSIDbyCrossID =Y,
16789 +inEM          =Y
16790 +/*-------------------------------------------------------------------------*/
16791 +);
16793 +%global EM_TS_ERR;
16794 +%let EM_TS_ERR = 0;
16796 +%if &inEM eq Y %then %do;
16797 +    %let num_crossIDVar = &EM_NUM_CROSSID;
16798 +    proc sql noprint;
16799 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
16800 +    quit;
16801 +%end;
16802 +%else %do;
16803 +    proc sql noprint;
16804 +         select count(*) into :num_crossIDVar from &variableSet
16805 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16806 +         ;
16807 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
16808 +         ;
16809 +    quit;
16810 +    %let num_crossIDVar=&num_crossIDVar;
16811 +%end;
16813 +* see if _TSID_ exists;
16815 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
16816 +run;
16818 +proc sql noprint;
16819 +    select count(*) into :has_TSID
16820 +        from _emtscm_contents
16821 +        where upcase(strip(name)) eq '_TSID_'
16822 +    ;
16823 +quit;
16825 +/*-------------------------------------------------------------------------*/
16826 +* Creating TSID map..;
16827 +/*-------------------------------------------------------------------------*/
16829 +%if (&num_crossIDVar gt 0) %then %do;
16831 +    data _emtscm_tmpIDMap;
16832 +        set &variableSet;
16833 +        where  (upcase(strip(level)) eq 'INTERVAL')
16834 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
16835 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
16836 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
16837 +          );
16838 +        _emts_dummy=1;
16839 +        keep name label role _emts_dummy;
16840 +    run;
16842 +    proc sql noprint;
16843 +        * create a string of crossID variable like A,B,C,D..;
16844 +        select distinct name into :crossIDVar separated by ','
16845 +            from &variableSet
16846 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16847 +            order by name
16848 +        ;
16849 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
16850 +            from &variableSet
16851 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16852 +            order by name
16853 +        ;
16854 +        * create the TSID map data set;
16855 +        create table _emtscm_tmp1 as
16856 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
16857 +        ;
16858 +        * create a level list of cross ID variables and time series variables;
16859 +        create table &outIDMap as
16860 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
16861 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
16862 +            where a._emts_dummy eq b._emts_dummy
16863 +            order by a.name, &crossIDVar
16864 +        ;
16865 +    quit;
16867 +    %if &TSIDbyCrossID = Y %then %do;
16868 +        * create unique TSID only by Cross ID;
16869 +        data &outIDMap;
16870 +            length _TSID_ 8;
16871 +            set &outIDMap;
16872 +            by _NAMEID_;
16873 +            if first._NAMEID_
16874 +                then _TSID_=1;
16875 +                else _TSID_+1;
16876 +        run;
16877 +        %if "&outDS" ne "" %then %do;
16878 +            * merge TSID into &inDS;
16879 +            proc sql noprint;
16880 +                create table &outDS as
16881 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
16882 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
16883 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
16884 +                        where %do i = 1 %to &num_crossIDVar;
16885 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
16886 +                              %end;
16887 +                             b._TSID_ is not missing
16888 +                    order by b._TSID_, a.&timeIDVar
16889 +                ;
16890 +            quit;
16891 +        %end;
16892 +    %end;
16893 +    %else %do;
16894 +        * create unique TSID by Cross ID and _NAMEID_;
16895 +        data &outIDMap;
16896 +            length _TSID_ 8;
16897 +            set &outIDMap;
16898 +            _TSID_=_n_;
16899 +        run;
16900 +        %if "&outDS" ne "" %then %do;
16901 +            *no merge in this output;
16902 +            data &outDS;
16903 +                set &inDS;
16904 +            run;
16905 +        %end;
16906 +    %end;
16908 +    proc sort data=&outIDMap;
16909 +        by _NAMEID_ _TSID_;
16910 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
16911 +        format _TSID_ best12. _NAMEID2_ $40.;
16912 +        set &outIDMap;
16913 +        by _NAMEID_;
16914 +        if first._NAMEID_
16915 +            then _emts_ind=1;
16916 +            else _emts_ind+1;
16917 +        drop _emts_ind;
16918 +        rename _NAMEID_=_VARNAME_;
16919 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
16920 +        if _labelID_ eq ' '
16921 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
16922 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
16923 +    run;
16925 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
16927 +%end;
16928 +%else %do; /* if no crossid's the nameid needs to be created */
16930 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
16931 +        length _TSID_ 8;
16932 +        set &variableSet;
16933 +        where  (upcase(strip(level)) eq 'INTERVAL')
16934 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
16935 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
16936 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
16937 +          );
16938 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
16939 +        rename ROLE = _ROLE_;
16940 +        _NAMEID_=strip(name);
16941 +        _VARNAME_=strip(name);
16942 +        if label eq ' '
16943 +            then _LABELID_ = strip(name);
16944 +            else _LABELID_ = strip(label);
16945 +        _TSID_=_n_;
16946 +    run;
16948 +    %if "&outDS" ne "" %then %do;
16949 +        *no merge in this output;
16950 +        data &outDS;
16951 +            set &inDS;
16952 +        run;
16953 +    %end;
16954 +%end;
16956 +data &outIDMap;
16957 +    set &outIDMap;
16958 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
16959 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
16960 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
16961 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
16962 +run;
16964 +proc datasets lib=work nolist;
16965 +    delete _emtscm_:;
16966 +run; quit;
16968 +%mend EM_TS_createIDMap;
16970 +%macro EM_TS_CreateMetaData(
16971 +/*-------------------------------------------------------------------------*/
16972 +  inDS          =,      /* imported data set in TS data mining             */
16973 +  outDS         =,      /* output data set of TS metadata                  */
16974 +  variableSet   =,      /* EM variable set                                 */
16975 +  timeInterval  =,      /* time interval                                   */
16976 +  rc            =       /* return code                                     */
16977 +/*-------------------------------------------------------------------------*/
16978 +);
16980 +%if %eval(
16981 +      &EM_NUM_BINARY_INPUT   +
16982 +      &EM_NUM_ORDINAL_INPUT  +
16983 +      &EM_NUM_NOMINAL_INPUT  +
16984 +      &EM_NUM_BINARY_REJECTED   +
16985 +      &EM_NUM_ORDINAL_REJECTED  +
16986 +      &EM_NUM_NOMINAL_REJECTED  +
16987 +      &EM_NUM_ORDINAL_TARGET  +
16988 +      &EM_NUM_NOMINAL_TARGET +
16989 +      &EM_NUM_BINARY_TARGET
16990 +      ) > 0
16991 +%then %do;
16992 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
16993 +        %put &em_codebar;
16994 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
16995 +        %put &errormsg;
16996 +        %put &em_codebar;
16997 +        %goto ENDLINE;
16998 +%end;
17000 +%global EM_TS_ERR;
17001 +%let EM_TS_ERR = 0;
17003 +%if &timeInterval eq AUTO
17004 +    %then %let timeInterval  = ;
17005 +    %else %let timeInterval  = %upcase(&timeInterval);
17007 +/*-------------------------------------------------------------------------*/
17008 +* check time ID variable;
17009 +/*-------------------------------------------------------------------------*/
17011 +* number of variables in the Variableset with ROLE=TIMEID;
17012 +proc sql noprint;
17013 +    select count(*) into :num_timeID from &variableset
17014 +        where upcase(role) eq 'TIMEID';
17015 +quit;
17017 +/*-------------------------------------------------------------------------*/
17018 +* process only when there is one Time ID, otherwise exception message;
17019 +/*-------------------------------------------------------------------------*/
17021 +%if &num_timeID eq 0 %then %do;
17023 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
17024 +    %let EM_TS_ERR = 11;
17025 +    %put &em_codebar;
17026 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
17027 +    %put &errormsg;
17028 +    %put &em_codebar;
17029 +    %goto tscm_endline;
17031 +%end;
17032 +%else %if &num_timeID gt 1 %then %do;
17034 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
17035 +    %let EM_TS_ERR = 12;
17036 +    %put &em_codebar;
17037 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
17038 +    %put &errormsg;
17039 +    %put &em_codebar;
17040 +    %goto tscm_endline;
17042 +%end;
17043 +%else %do;
17044 +    *** proceed when there is one Time ID;
17046 +    data _null_;
17047 +        set &variableset(where=(upcase(role)='TIMEID'));
17048 +        call symput('timeIDFormat',     strip(format));
17049 +        call symput('timeID',           strip(upcase(name)      ));
17050 +        call symput('timeIDLevel',      strip(upcase(level))     );
17051 +        call symput('timeIDFormatType', strip(upcase(formattype)));
17052 +    run;
17054 +    *** exception message if the time ID is not an interval variable;
17055 +    %if &timeIDLevel ne INTERVAL %then %do;
17056 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
17057 +        %let EM_TS_ERR = 13;
17058 +        %put &em_codebar;
17059 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
17060 +        %put &errormsg;
17061 +        %put &em_codebar;
17062 +        %goto tscm_endline;
17063 +    %end;
17065 +    %if (&timeIDFormatType ne DATETIME) and
17066 +        (&timeIDFormatType ne DATE) and
17067 +        (&timeIDFormatType ne TIME) and
17068 +        (&timeIDFormatType ne USER)
17069 +    %then %do;
17070 +        *** sequential format-type of time ID;
17072 +        %let timeInterval = DAY;
17073 +        %let timeIDFormatType = SEQ;
17075 +        proc sql noprint;
17076 +            create table _emtscm_inds as
17077 +                 select distinct &timeID from &inDS(keep=&timeID)
17078 +                 where &timeID is not missing;
17079 +            select count(*) into :num_nonInteger from _emtscm_inds
17080 +                where &timeID ne int(&timeID);
17081 +        quit;
17083 +        %if &num_nonInteger gt 0 %then %do;
17084 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
17085 +            %let EM_TS_ERR = 14;
17086 +            %put &em_codebar;
17087 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
17088 +            %put &errormsg;
17089 +            %put &em_codebar;
17090 +            %goto tscm_endline;
17091 +        %end;
17092 +    %end;
17093 +    %else %do;
17094 +        *** date, datetime, time format-type of time ID;
17096 +        *** must have a format;
17097 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
17098 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
17099 +            %let EM_TS_ERR = 15;
17100 +            %put &em_codebar;
17101 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
17102 +            %put &errormsg;
17103 +            %put &em_codebar;
17104 +            %goto tscm_endline;
17105 +        %end;
17107 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
17108 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
17109 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
17110 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
17111 +                %let EM_TS_ERR = 16;
17112 +                %put &em_codebar;
17113 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
17114 +                %put &errormsg;
17115 +                %put &em_codebar;
17116 +                %goto tscm_endline;
17117 +            %end;
17118 +        %end;
17120 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
17121 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
17122 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
17123 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
17124 +                %let EM_TS_ERR = 17;
17125 +                %put &em_codebar;
17126 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
17127 +                %put &errormsg;
17128 +                %put &em_codebar;
17129 +                %goto tscm_endline;
17130 +            %end;
17131 +        %end;
17133 +        *** the AUTO function is currently turned off for TIME timeID variable;
17134 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
17135 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
17136 +            %let EM_TS_ERR = 18;
17137 +            %put &em_codebar;
17138 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
17139 +            %put &errormsg;
17140 +            %put &em_codebar;
17141 +            %goto tscm_endline;
17142 +        %end;
17144 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
17145 +            %then %let timeInterval =DT&timeInterval;
17147 +        proc sql noprint;
17148 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
17149 +                where &timeID is not missing;
17150 +        quit;
17151 +    %end;
17153 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
17154 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
17155 +    run;
17157 +    %let hasValidInterval = 0;
17158 +    %let hasLengthOne     = 0;
17160 +    proc sql noprint;
17161 +        create table _emtscm_label as
17162 +            select name,label
17163 +            from dictionary.columns
17164 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
17165 +        ;
17166 +        create table _emtscm_meta2 as
17167 +            select a.*, b.label
17168 +            from _emtscm_meta as a, _emtscm_label as b
17169 +            where upcase(a.timeID) eq upcase(b.name)
17170 +        ;
17171 +    quit;
17173 +    data &outDS;
17174 +        set _emtscm_meta2;
17175 +        format
17176 +            timeformat      $30.
17177 +            role            $10.
17178 +            start           &timeIDformat
17179 +            end             &timeIDformat
17180 +            apply_start_end $8.
17181 +        ;
17182 +        rename
17183 +            timeID      = name
17184 +            seasonality = lengthOfCycle
17185 +            interval    = timeinterval
17186 +        ;
17187 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
17189 +        role            = "TIMEID";
17190 +        apply_start_end = 'N';
17191 +        timeformat      = symget('timeIDformat');
17192 +        timeformattype  = symget('timeIDformatType');
17194 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
17195 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
17196 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
17197 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
17198 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
17199 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
17200 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
17201 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
17202 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
17203 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
17205 +        if timeformattype eq 'SEQ' then do;
17206 +            timeformat='BEST12.';
17207 +            seasonality=1;
17208 +        end;
17210 +        call symput('_tinterval',interval);
17212 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
17214 +        if upcase(timeformattype) eq 'DATE' and
17215 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
17216 +            then call symput('hasValidInterval',1);
17218 +        if upcase(timeformattype) eq 'DATETIME' and
17219 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
17220 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
17221 +            then call symput('hasValidInterval',1);
17223 +        if upcase(timeformattype) eq 'TIME' and
17224 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
17225 +            then call symput('hasValidInterval',1);
17227 +        if upcase(timeformattype) eq 'SEQ'
17228 +            then call symput('hasValidInterval',1);
17230 +        if upcase(timeformattype) eq 'USER'
17231 +            then call symput('hasValidInterval',1);
17233 +        if start eq end
17234 +            then call symput('hasLengthOne',1);
17235 +    run;
17237 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
17239 +    *** detect any missing time interval after running PROC TIMEID;
17240 +    %if &_tinterval eq %then %do;
17241 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
17242 +        %let EM_TS_ERR = 19;
17243 +        %put &em_codebar;
17244 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
17245 +        %put &errormsg;
17246 +        %put &em_codebar;
17247 +        %goto tscm_endline;
17248 +    %end;
17250 +    *** detect any missing time interval after running PROC TIMEID;
17251 +    %if &hasValidInterval eq 0 %then %do;
17252 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
17253 +        %let EM_TS_ERR = 20;
17254 +        %put &em_codebar;
17255 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
17256 +        %put &errormsg;
17257 +        %put &em_codebar;
17258 +        %goto tscm_endline;
17259 +    %end;
17261 +    %if &hasLengthOne eq 1 %then %do;
17262 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
17263 +        %let EM_TS_ERR = 21;
17264 +        %put &em_codebar;
17265 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
17266 +        %put &errormsg;
17267 +        %put &em_codebar;
17268 +        %goto tscm_endline;
17269 +    %end;
17271 +%end;
17273 +%tscm_endline:;
17275 +%mend EM_TS_CreateMetaData;
17278 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
17280 +data _null_;
17281 +    set &tsmeta;
17282 +    call symput('_timeidFormatType', timeformattype);
17283 +    call symput('_timeid', strip(name));
17284 +    call symput('_seqstartnum',strip(put(start,best12.)));
17285 +run;
17287 +proc contents data=&inDS noprint
17288 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
17289 +run; quit;
17291 +data _null_;
17292 +    set _emts_tmpp1;
17293 +    call symput('_timeIDlabel',label);
17294 +run;
17296 +%if &_timeidFormatType eq SEQ
17297 +%then %do;
17298 +    proc sql noprint;
17299 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
17300 +    quit;
17301 +    %let _dummystarttime=&_dummystarttime;
17303 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
17304 +        set &inDS;
17305 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
17306 +        drop &_timeid;
17307 +        label _tsdp_tmpID = "&_timeIDlabel";
17309 +    run;
17310 +%end;
17312 +%mend;
17314 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
17316 +data _null_;
17317 +    set &tsmeta;
17318 +    call symput('_timeidFormatType', timeformattype);
17319 +    call symput('_timeidFormat', timeformat);
17320 +    call symput('_timeid', strip(name));
17321 +    call symput('_timeinterval',strip(upcase(timeinterval)));
17322 +run;
17324 +/* manually change time ID format to a longer enough time format */
17325 +/* because proc timeid returns time5. for second time interval */
17326 +/* which is not long enough for transpose with time unit as seconds */
17327 +%if &_timeinterval eq SECOND
17328 +%then %do;
17329 +    %let _timeIDformat = %str(time8.);
17330 +%end;
17332 +proc contents data=&inDS noprint
17333 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
17334 +run; quit;
17336 +data _null_;
17337 +    set _emts_tmpp1;
17338 +    call symput('_timeIDlabel',label);
17339 +run;
17341 +%if &_timeidFormatType eq TIME
17342 +%then %do;
17343 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
17344 +        set &inDS;
17345 +        _tsdp_tmpID = timepart(&_timeID);
17346 +        format _tsdp_tmpID &_timeidFormat;
17347 +        label  _tsdp_tmpID = "&_timeIDlabel";
17348 +        drop &_timeid;
17349 +    run;
17350 +%end;
17352 +%mend;
17354 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
17356 + proc sql noprint;
17357 +     create table _tmptimetable as
17358 +         select distinct &timeidvar as DATE from &inDS
17359 +         where &timeIDVar is not missing
17360 +         order by &timeIDVar;
17361 + quit;
17363 +%if &compare eq Y %then %do;
17364 +    * compare with the existing time table;
17365 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
17366 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
17367 +    run;
17369 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
17371 +    %if &_diffobs > 0 %then %do; /* create it again */
17372 +        data &outDS(keep=DATE _INDEX_);
17373 +            set _tmptimetable end = _eof_;
17374 +            if _N_ = 1
17375 +                then _INDEX_ = 1;
17376 +                else _INDEX_ = 0;
17377 +            if _eof_ then _INDEX_= 2;
17378 +        run;
17379 +    %end;
17381 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
17382 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
17383 +%end;
17384 +%else %do;
17385 +    * create a new time table directly;
17386 +    data &outDS(keep=DATE _INDEX_);
17387 +        set _tmptimetable end = _eof_;
17388 +        if _N_ = 1
17389 +            then _INDEX_ = 1;
17390 +            else _INDEX_ = 0;
17391 +        if _eof_ then _INDEX_= 2;
17392 +    run;
17394 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
17395 +%end;
17397 +* assign a defult format BEST12. for sequential time ID;
17399 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
17401 +%let _nodatefmt=N;
17403 +data _null_;
17404 +    set _tmpcontents;
17405 +    where upcase(name) eq 'DATE';
17406 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
17407 +run;
17409 +%if "&_nodatefmt" eq "Y" %then %do;
17410 +    data &outDS;
17411 +        set &outDS;
17412 +        format date best12.;
17413 +    run;
17414 +%end;
17416 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
17418 +%mend;
17422 +%macro EM_TS_Transpose(
17423 +/*-------------------------------------------------------------------------*/
17424 +  inDS          =,      /* imported data set in TS data mining             */
17425 +  inIDMap       =,      /* input TS ID map                                 */
17426 +  variableSet   =,      /* variable set                                    */
17427 +  transposeBy   =,      /* byTSID or byTimeID                              */
17428 +  outDS         =,      /* output transposed data set                      */
17429 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
17430 +  inEM          =Y,
17431 +  timePrefix    =_T
17432 +/*-------------------------------------------------------------------------*/
17433 +);
17435 +%let timePrefix = &timePrefix;
17437 +%if  &EM_NUM_CROSSID > 0 %then %do;
17439 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
17440 +    set &inIDMap;
17441 +    drop _NAMEID_;
17442 +    run;
17443 +%let inIDMap=_emtstp_map0;
17445 +%end;
17447 +proc sql noprint;
17448 +    * number of TS Variables to be transposed;
17449 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
17450 +    ;
17451 +    * number of TS Variables to be transposed;
17452 +    select max(_TSID_) into :num_TSID from &inIDMap
17453 +    ;
17454 +    * name list of TS Variables;
17455 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
17456 +        from &inIDMap
17457 +        order by _NAMEID_
17458 +    ;
17459 +    * total number of time series =max(_TSID_)*&num_TSVar;
17460 +    * and the number of digits of this variable is &num_digits;
17461 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
17462 +        from &inIDMap
17463 +    ;
17464 +      * Time ID variable;
17465 +    select name into:timeIDVar from &variableset
17466 +        where upcase(role) eq 'TIMEID'
17467 +    ;
17468 +quit;
17469 +%let num_digits = &num_digits;
17470 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
17472 +/*-------------------------------------------------------------------------*/
17474 +* get number of cross IDs and also the TIME ID variable name;
17475 +%if &inEM eq Y %then %do;
17476 +    %let num_crossIDVar = &EM_NUM_CROSSID;
17477 +    %let crossIDVar     = %EM_CROSSID;
17478 +%end;
17479 +%else %do;
17480 +    proc sql noprint;
17481 +        * number of cross ID;
17482 +        select count(*) into :num_crossIDVar
17483 +            from &variableSet
17484 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17485 +        ;
17486 +        * create a string of crossID variable like A B C D..;
17487 +        select distinct name into :crossIDVar separated by ' '
17488 +            from &variableSet
17489 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17490 +            order by name
17491 +        ;
17492 +    quit;
17493 +    %let num_crossIDVar=&num_crossIDVar;
17494 +%end;
17496 +/*-------------------------------------------------------------------------*/
17498 +%if (&num_crossIDVar gt 0) %then %do;
17500 +    data _emtstp_tmpDat;
17501 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
17502 +        _NAMEID_ = cats("_TS_",_TSID_);
17503 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
17504 +    run;
17506 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
17508 +        * update the ID maps;
17509 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
17510 +            by _NAMEID_ _TSID_;
17511 +        data &outIDMap;
17512 +            set _emtstp_tmpmap;
17513 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
17514 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
17515 +        run;
17517 +        * get the names for the new variables;
17518 +        proc sql noprint;
17519 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
17520 +            ;
17521 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
17522 +            ;
17523 +        quit;
17525 +        * data must be sorted before transposed;
17526 +        proc sort data=_emtstp_tmpDat;
17527 +            by &timeIDvar;
17528 +        run;
17530 +        %do i = 1 %to &num_TSVar;
17531 +            %let i = &i;
17532 +            * transpose one cross-type time series data by TSID;
17533 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
17534 +                id _NAMEID_;
17535 +                by &timeIDVar;
17536 +                var &&&TSVar&i;
17537 +            run;
17538 +        %end;
17540 +        * merge all vertical time series, rename and label them;
17541 +        data &outDS;
17542 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
17543 +            by &timeIDVar;
17544 +            rename
17545 +                %do i = 1 %to &num_TSVar;
17546 +                    %do j = 1 %to &num_TSID;
17547 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
17548 +                        /* %put &i &j &num1 &num_TSID; */
17549 +                        _V_&i._TS_&j = &&&tsname&num1
17550 +                    %end;
17551 +                %end;
17552 +            ;
17553 +            label
17554 +                %do i = 1 %to &num_TSVar;
17555 +                    %do j = 1 %to &num_TSID;
17556 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
17557 +                        /* %put &i &j &num1 &num_TSID; */
17558 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
17559 +                    %end;
17560 +                %end;
17561 +            ;
17562 +        run;
17563 +    %end;
17564 +    %else %do;
17566 +        * update the ID maps;
17567 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
17568 +            by _NAMEID_ _TSID_;
17569 +        data &outIDMap;
17570 +            set _emtstp_tmpmap;
17571 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
17572 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
17573 +        run;
17575 +        proc sql noprint;
17576 +            * get the roles for the new variables;
17577 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
17578 +                from &inIDMap
17579 +                order by _NAMEID_
17580 +            ;
17581 +            * get the length of the time series;
17582 +            select count(distinct &timeIDvar) into :num_T
17583 +                from _emtstp_tmpDat
17584 +            ;
17585 +        quit;
17587 +        * data must be sorted before transposed;
17588 +        proc sort data=_emtstp_tmpDat;
17589 +            by _TSID_ &crossIDVar &timeIDvar;
17590 +        run;
17592 +        %do i = 1 %to &num_TSVar;
17593 +            %let i = &i;
17594 +            * transpose one cross-type time series data by TIMEID;
17595 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
17596 +                by _TSID_ &crossIDVar;
17597 +                var &&&TSVar&i;
17598 +            run;
17599 +        %end;
17601 +        * stack all horizontal time series;
17602 +        data &outDS;
17603 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
17604 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
17605 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
17606 +            %do i=1 %to &num_TSVar;
17607 +                if in&i then do;
17608 +                    _NAMEID_ ="&&&TSVar&i";
17609 +                    _ROLE_   ="&&&TSRole&i";
17610 +                end;
17611 +            %end;
17612 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
17613 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
17614 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
17615 +        run;
17616 +    %end;
17617 +%end;
17618 +%else %do;
17620 +    proc sql noprint;
17621 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
17622 +            order by _NAMEID_
17623 +        ;
17624 +    quit;
17626 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
17627 +        * transpose the panel-type time series data by TSID;
17628 +        proc sort data=&inDS out=_emtstp_tmpDat;
17629 +            by &timeIDvar;
17630 +        proc transpose data=_emtstp_tmpDat
17631 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
17632 +            by &timeIDVar;
17633 +            var &panelTSVar;
17634 +        run;
17635 +        proc datasets lib=work nolist;
17636 +            modify _emtstp_tmpDat2;
17637 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
17638 +            run; quit;
17639 +    %end;
17640 +    %else %do;
17641 +        * transpose the panel-type time series data by TIMEID;
17642 +        proc sort data=&inDS out=_emtstp_tmpDat;
17643 +            by &timeIDvar;
17644 +        data _emtstp_tmpDat;
17645 +            set _emtstp_tmpDat;
17646 +            _tmp_ind=_n_;
17647 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
17648 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
17649 +            ID _tmp_ind;
17650 +            var &panelTSVar;
17651 +        run;
17652 +    %end;
17654 +      * merge ID maps to the transpose data set;
17655 +      proc sql noprint;
17656 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
17657 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
17658 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
17659 +          ;
17660 +      quit;
17662 +      * update the TS ID map;
17663 +      data &outIDMap;
17664 +          set &inIDMap;
17665 +      run;
17666 +%end;
17668 +proc datasets lib=work nolist;
17669 +    delete _emtstp:;
17670 +run; quit;
17672 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_TRAIN.SOURCE.
17674 +/*----------------------------------------------------------------------------------+
17675 + |
17676 + |   Title :  TS ESM Forecasting Node
17677 + |
17678 + |
17679 + |   SUPPORT: Taiyeong Lee (taiyeong.lee@sas.com)
17680 + |
17681 + +-----------------------------------------------------------------------------------*/
17683 +%macro EM_TSESM_TRAIN;
17685 +   /*---------- Check and assign the input data set --------------------------*/
17687 +    %let _IMPORT_DATA  = ;
17688 +    %let _IMPORT_CMETA = ;
17689 +    %let _DATA_EMINFO  = ;
17690 +    %let _EXPORT_DATA  = ;
17691 +    %let _FILE_CDELTA  = ;
17693 +    %if &EM_IMPORT_DATA ne  %then %do;
17694 +           %let _IMPORT_DATA   = &EM_IMPORT_DATA;
17695 +           %let _IMPORT_CMETA  = &EM_IMPORT_DATA_CMETA;
17696 +           %let _DATA_EMINFO   = &EM_IMPORT_DATA_EMINFO;
17697 +           %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
17698 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
17700 +    %end;
17701 +    %else %if &EM_IMPORT_TRANSACTION ne  %then %do;
17702 +           %let _IMPORT_DATA   = &EM_IMPORT_TRANSACTION;
17703 +           %let _IMPORT_CMETA  = &EM_IMPORT_TRANSACTION_CMETA;
17704 +           %let _DATA_EMINFO   = &EM_IMPORT_TRANSACTION_EMINFO;
17705 +           %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
17706 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRANSACTION;
17707 +    %end;
17708 +    %else %do;
17709 +           %let  EMEXCEPTIONSTRING = exception.server.tsdm.noinputdata;
17710 +           %goto ENDLINE;
17711 +    %end;
17712 +/*-------------  check time id variable -----------------------------*/
17713 +%local _numTimeIDs;
17714 +%let _numTimeIDs=0;
17716 +proc sql noprint;
17717 +    select count(*) into :_numTimeIDs
17718 +    from &EM_DATA_VARIABLESET
17719 +    where upcase(role) eq 'TIMEID' and upcase(strip(level)) eq 'INTERVAL' and upcase(strip(use)) in ('Y' 'D');
17720 +quit;
17722 +%if &_numTimeIDs eq 0 %then %do;
17724 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
17725 +    %put &em_codebar;
17726 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
17727 +    %put &errormsg;
17728 +    %put &em_codebar;
17729 +    %goto ENDLINE;
17731 +%end;
17732 +%else %if &_numTimeIDs gt 1 %then %do;
17734 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
17735 +    %put &em_codebar;
17736 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
17737 +    %put &errormsg;
17738 +    %put &em_codebar;
17739 +    %goto ENDLINE;
17741 +%end;
17743 +   %let _nivars = %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED);
17744 +   %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17745 +        %if &_nivars < 1 %then %do;
17746 +              %put &em_codebar;
17747 +              %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.need1intervalrejectinput_ERR , NOQUOTE));
17748 +              %put &errormsg;
17749 +              %put &em_codebar;
17750 +              %let  EMEXCEPTIONSTRING = exception.server.tsdm.need1intervalrejectinput;
17751 +              %goto ENDLINE;
17752 +         %end;
17754 +   %end;
17755 +   %else %do;
17757 +        /* will forecast a target variable (with crossids) or variables (panel) */
17759 +        %if &EM_NUM_INTERVAL_TARGET < 1 %then %do;
17760 +             %put &em_codebar;
17761 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.USE1INTERVALTARGET_ERR , NOQUOTE));
17762 +             %put &errormsg;
17763 +             %put &em_codebar;
17764 +             %let EMEXCEPTIONSTRING = exception.server.tsdm.USE1INTERVALTARGET;
17765 +             %goto ENDLINE;
17766 +        %end;
17768 +        %if (&EM_NUM_CROSSID > 0) and (&EM_NUM_INTERVAL_TARGET > 1) %then %do;
17770 +             %put &em_codebar;
17771 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.csidonly1inttarget_err , NOQUOTE));
17772 +             %put &errormsg;
17773 +             %put &em_codebar;
17774 +             %let EMEXCEPTIONSTRING = exception.server.tsdm.csidonly1inttarget;
17775 +             %goto ENDLINE;
17776 +        %end;
17778 +    %end;
17780 +    %if  &EM_PROPERTY_STARTSUM > &EM_PROPERTY_FCLEAD %then %do;
17782 +             %put &em_codebar;
17783 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.startsumlessflead_err , NOQUOTE));
17784 +             %put &errormsg;
17785 +             %put &em_codebar;
17786 +             %let  EMEXCEPTIONSTRING =exception.server.tsdm.startsumlessflead;
17787 +             %goto ENDLINE;
17788 +    %end;
17790 +   /* Check strictly positive seq for &EM_PROPERTY_FCMETHOD eq WINTERS or MULTSEASONAL */
17792 +%macro TSESM_input_varlist(varlist);
17793 +   %local outlist i;
17794 +   %let i = 2;
17795 +   %let outlist = %scan(&varlist, 1, ' ' );
17797 +   %do %while (%scan(&varlist, &i, ' ' ) ne );
17799 +      %let outlist = &outlist  %str(,) %scan(&varlist, &i, ' ' );
17800 +      %let i  = %eval(&i+1);
17801 +   %end;
17803 +   &outlist
17804 +%mend TSESM_input_varlist;
17806 +    %if  &EM_PROPERTY_FCMETHOD eq WINTERS or &EM_PROPERTY_FCMETHOD eq MULTSEASONAL %then %do;
17807 +       %let _tsseq_flag = 0;
17809 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17810 +          proc sql noprint;
17811 +             select min(min( %TSESM_input_varlist(%EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED)),100 )  into :_tsseq_min from &_IMPORT_DATA;
17812 +          quit;
17813 +          %if %sysfunc(floor(&_tsseq_min))  < 0 %then  %let  _tsseq_flag = 1;
17814 +       %end;
17815 +       %else %do;
17816 +         proc sql noprint;
17817 +            select min(min( %TSESM_input_varlist(%EM_TARGET)),100 ) into :_tsseq_min from &_IMPORT_DATA;
17818 +         quit;
17819 +         %if %sysfunc(floor(&_tsseq_min))  < 0 %then  %let  _tsseq_flag = 1;
17820 +       %end;
17821 +       %if &_tsseq_flag = 1 %then %do;
17822 +             %put &em_codebar;
17823 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.strictpositive_err , NOQUOTE));
17824 +             %put &errormsg;
17825 +             %put &em_codebar;
17826 +             %let  EMEXCEPTIONSTRING =exception.server.tsdm.strictpositive;
17827 +             %goto ENDLINE;
17828 +       %end;
17829 +    %end;
17833 +   /* When Forecast Input Time Series is Yes, Output Data Type is always Default */
17834 +   %let _EXPORTDATA = &EM_PROPERTY_EXPORTDATA;
17835 +   %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17836 +      %let _EXPORTDATA = DEFAULT   ;
17837 +      %let EM_PROPERTY_EXPORTDATA  = DEFAULT   ;
17839 +   %end;
17841 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
17842 +    %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
17844 +    /*---- EM_TS_CreateMetadata do validation of Time ID and return EM_TS_ERR   ----------------------------*/
17846 +    %EM_TS_CreateMetadata(inDS=&_IMPORT_DATA, outDS =&EM_USER_TSMETA, variableSet =&EM_DATA_VARIABLESET, timeInterval=&EM_PROPERTY_TIMEINTERVAL, rc=);
17848 +    %if &EM_TS_ERR > 0 %then  %do;
17850 +       %let EM_TS_ERR = 0;
17851 +       %goto ENDLINE;
17852 +    %end;
17854 +    /*----- Get time interval ---------------------------*/
17856 +    %EM_TS_GETTSMETAVARS(TimeInterval=_timeinterval);
17858 +    /*--- _EXPORT_DATA will be used as an input data becuase  _TSID_  is needed to run TS ESM Node */
17860 +    %EM_TS_CreateIDMap(inDS=&_IMPORT_DATA, outIDMap =&EM_USER_TSIDMAP, outDS =&_EXPORT_DATA, variableSet =&EM_DATA_VARIABLESET, TSIDbyCrossID =Y);
17862 +    /*----------- Modify TSID MAP --------------------------------*/
17864 +    %if (&EM_NUM_CROSSID > 0) %then %do;
17865 +         %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17866 +             data &EM_USER_TSIDMAP;
17867 +                  set &EM_USER_TSIDMAP;
17868 +                  if upcase(strip(_ROLE_)) ="INPUT" then output;
17869 +             run;
17870 +         %end;
17871 +         %else %do;
17872 +             data &EM_USER_TSIDMAP;
17873 +                  set &EM_USER_TSIDMAP;
17874 +                  if upcase(strip(_ROLE_)) ="TARGET" then output;
17875 +             run;
17876 +         %end;
17877 +    %end;
17878 +    %else %do;
17879 +         %if &_EXPORTDATA ne DEFAULT  %then %do;
17881 +             %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
17882 +                 data &EM_USER_TSIDMAP;
17883 +                      set &EM_USER_TSIDMAP; retain _tmptsid 0;
17884 +                      if upcase(strip(_ROLE_)) ="INPUT" then do; _tmptsid=_tmptsid+1; _TSID_=_tmptsid;output;end;
17885 +                      drop _tmptsid;
17886 +                 run;
17887 +             %end;
17888 +             %else %do;
17889 +                 data &EM_USER_TSIDMAP;
17890 +                      set &EM_USER_TSIDMAP; retain _tmptsid 0;
17891 +                      if upcase(strip(_ROLE_)) ="TARGET" then do; _tmptsid=_tmptsid+1; _TSID_=_tmptsid;output;end;
17892 +                      drop _tmptsid;
17893 +                 run;
17895 +             %end;
17896 +         %end;
17897 +    %end;
17902 +    %let _tsidVar = ;
17903 +    %let _existsgmtvar = N;
17905 +    %if %EM_CROSSID ne %then %do;
17906 +        %let _tsidVar =_TSID_ ;
17907 +        /*---------  check Segmentvar : may not need implement, will decided at the next version -----------
17908 +                     So the _segment_ related codes have not been removed in other source codes
17909 +         ---------------------------------------------------------------------------------------------------
17910 +        %let j=1;
17911 +        %do %while(%scan(%EM_CROSSID, &j) ne );
17912 +            %let _csvar=%scan(%EM_CROSSID, &j);
17913 +            %if &_csvar = _SEGMENT_ %then %let _existsgmtvar =Y;
17914 +            %let j=%eval(&j+1);
17915 +        %end;
17916 +        %if &_existsgmtvar = Y %then %let _tsidVar = _SEGMENT_;
17917 +        +-------------------------------------------*/
17918 +    %end;
17920 +    /*----------- Forecasting ----------------------------------*/
17922 +    %EM_GETNAME(KEY=OUTEST, TYPE=DATA);
17923 +    %EM_GETNAME(KEY=OUTDATA, TYPE=DATA);
17924 +    %EM_GETNAME(KEY=OUTFORCST, TYPE=DATA);
17925 +    %EM_GETNAME(KEY=OUTSTAT, TYPE=DATA);
17926 +    %EM_GETNAME(KEY=OUTSUM, TYPE=DATA);
17927 +    %EM_GETNAME(KEY=OUTCLUS, TYPE=DATA);
17928 +    %EM_GETNAME(KEY=OUTLIER, TYPE=DATA);
17929 +    %EM_GETNAME(KEY=OUTPRED, TYPE=DATA);
17930 +    %EM_GETNAME(KEY=OUTKLD, TYPE=DATA);
17931 +    %EM_GETNAME(KEY=OUTLIERDS, TYPE=DATA);
17934 +    %if &EM_PROPERTY_FCMETHOD ne BEST %then %do;
17936 +       %if &EM_PROPERTY_SEASONALITY eq DEFAULT %then %do;
17937 +           %if ( &_timeinterval eq YEAR ) or ( &_timeinterval eq DTYEAR ) %then %do;
17938 +               %if (&EM_PROPERTY_FCMETHOD eq ADDSEASONAL ) or (&EM_PROPERTY_FCMETHOD eq MULTSEASONAL)
17939 +                   or (&EM_PROPERTY_FCMETHOD eq ADDWINTERS) or (&EM_PROPERTY_FCMETHOD eq WINTERS) %then %do;
17940 +                   %let  EMEXCEPTIONSTRING =exception.server.tsdm.requirenonseasonalmodel;
17941 +                   %goto ENDLINE;
17942 +               %end;
17943 +           %end;
17944 +       %end;
17946 +       %EM_TSESM_Forecast(indata=&_EXPORT_DATA,
17947 +                          method=&EM_PROPERTY_FCMETHOD,
17948 +                          timeinterval=&_timeinterval,
17949 +                          timeid=%EM_TIMEID ,
17950 +                          target=%EM_TARGET ,
17951 +                          tsidvar = &_tsidVar,
17952 +                          lead=&EM_PROPERTY_FCLEAD,
17953 +                          back=&EM_PROPERTY_FCBACK,
17954 +                          startsum=&EM_PROPERTY_STARTSUM,
17955 +                          seasonality=&EM_PROPERTY_SEASONALITY,
17956 +                          alpha=&EM_PROPERTY_ALPHA,
17957 +                          accumulate=&EM_PROPERTY_ACCUMULATE,
17958 +                          extendedvalue = &EM_PROPERTY_EXTENDEDVALUE,
17959 +                          outest=&EM_USER_OUTEST,
17960 +                          outdata=&EM_USER_OUTDATA,
17961 +                          outfor =&EM_USER_OUTFORCST ,
17962 +                          outstat = &EM_USER_OUTSTAT ,
17963 +                          outsum=&EM_USER_OUTSUM
17964 +                          );
17965 +    %end;
17966 +    %else %do;
17967 +           %let n_model = 0;
17968 +           %if &EM_PROPERTY_SIMPLE eq Y %then %let n_model = %eval(&n_model+1);
17969 +           %if &EM_PROPERTY_DOUBLE eq Y %then %let n_model = %eval(&n_model+1);
17970 +           %if &EM_PROPERTY_LINEAR eq Y %then %let n_model = %eval(&n_model+1);
17971 +           %if &EM_PROPERTY_DAMPTREND eq Y %then %let n_model = %eval(&n_model+1);
17972 +           %if (&_timeinterval ne YEAR ) and ( &_timeinterval ne DTYEAR ) %then %do;
17973 +               %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then  %let n_model = %eval(&n_model+1);
17974 +               %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %let n_model = %eval(&n_model+1);
17975 +               %if (&EM_PROPERTY_ADDWINTERS eq Y) %then   %let n_model = %eval(&n_model+1);
17976 +               %if (&EM_PROPERTY_WINTERS eq Y) %then      %let n_model = %eval(&n_model+1);
17977 +           %end;
17978 +           %if &n_model eq 0 %then %do;
17979 +                %let  EMEXCEPTIONSTRING =exception.server.tsdm.zerocandidatemodel;
17980 +                %GOTO ENDLINE;
17981 +           %end;
17983 +       %EM_TSESM_Best_Forecast(indata=&_EXPORT_DATA,
17984 +                          method=&EM_PROPERTY_FCMETHOD,
17985 +                          criterion=&EM_PROPERTY_BESTCRIT,
17986 +                          timeinterval=&_timeinterval,
17987 +                          timeid=%EM_TIMEID ,
17988 +                          target=%EM_TARGET ,
17989 +                          tsidvar = &_tsidVar,
17990 +                          lead=&EM_PROPERTY_FCLEAD,
17991 +                          back=&EM_PROPERTY_FCBACK,
17992 +                          startsum=&EM_PROPERTY_STARTSUM,
17993 +                          seasonality=&EM_PROPERTY_SEASONALITY,
17994 +                          alpha=&EM_PROPERTY_ALPHA,
17995 +                          accumulate=&EM_PROPERTY_ACCUMULATE,
17996 +                          extendedvalue = &EM_PROPERTY_EXTENDEDVALUE,
17997 +                          outest=&EM_USER_OUTEST,
17998 +                          outdata=&EM_USER_OUTDATA,
17999 +                          outfor =&EM_USER_OUTFORCST ,
18000 +                          outstat = &EM_USER_OUTSTAT ,
18001 +                          outsum=&EM_USER_OUTSUM
18002 +                         );
18003 +    %end;
18005 +    %EM_TS_Time2Seq(inDS=&EM_USER_OUTFORCST,tsmeta=&EM_USER_TSMETA);
18006 +    %EM_TS_Time2Seq(inDS=&EM_USER_OUTDATA,tsmeta=&EM_USER_TSMETA);
18007 +    %EM_TS_Time2Seq(inDS=&_EXPORT_DATA,tsmeta=&EM_USER_TSMETA);
18010 +    %EM_TSESM_MakeOutlierIndex(indata=&EM_USER_OUTFORCST,
18011 +                               timeid=%EM_TIMEID,
18012 +                               outoutlier=&EM_USER_OUTLIER,
18013 +                               outlierds=&EM_USER_OUTLIERDS,
18014 +                               outdata=&EM_USER_OUTFORCST
18015 +                               );
18017 +    %EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
18018 +                          target=%EM_TARGET,
18019 +                          timeid=%EM_TIMEID,
18020 +                          outdata=&EM_USER_OUTPRED
18021 +                         );
18024 +    %ENDLINE:
18025 +%mend EM_TSESM_TRAIN;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM4_VARIABLESET.
      WHERE UPCASE(role)='TIMEID';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK._EMTSCM_INDS created, with 100 rows and 1 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of time vectors processed: 1
NOTE: There were 100 observations read from the data set WORK._EMTSCM_INDS.
NOTE: The data set WORK._EMTSCM_META has 1 observations and 24 variables.
NOTE: PROCEDURE TIMEID used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK._EMTSCM_LABEL created, with 1 rows and 2 columns.
 
NOTE: Table WORK._EMTSCM_META2 created, with 1 rows and 25 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      379:48    399:62    415:122   425:137   435:136   445:152
NOTE: There were 1 observations read from the data set WORK._EMTSCM_META2.
NOTE: The data set EMWS5.TSESM4_TSMETA has 1 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: The file WORK._EM_TSCM: (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM4_TSMETA.
NOTE: The PROCEDURE PRINT printed page 2.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTSCM_CONTENTS has 6 observations and 1 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 5 observations read from the data set EMWS5.TSESM4_VARIABLESET.
      WHERE (UPCASE(STRIP(level))='INTERVAL') and (((UPCASE(STRIP(role))='INPUT') and UPCASE(STRIP(use)) in ('D', 'Y')) or ((UPCASE(STRIP(role))='REJECTED') and (UPCASE(STRIP(use))='Y')) or ((UPCASE(STRIP(role))='TARGET') and UPCASE(STRIP(use)) in ('D',
      'Y')));
NOTE: The data set EMWS5.TSESM4_TSIDMAP has 5 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 100 observations read from the data set EMWS5.TSDP4_TRAIN.
NOTE: The data set EMWS5.TSESM4_TRAIN has 100 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Variable _varname_ is uninitialized.
NOTE: There were 5 observations read from the data set EMWS5.TSESM4_TSIDMAP.
NOTE: The data set EMWS5.TSESM4_TSIDMAP has 5 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK._EMTSCM_CONTENTS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_INDS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_LABEL (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META2 (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 100 observations read from the data set EMWS5.TSESM4_TRAIN.
NOTE: The data set WORK._TMPDATA has 100 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 100 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT1 has 106 observations and 6 variables.
NOTE: The data set WORK._OUTEST1 has 1 observations and 8 variables.
NOTE: The data set WORK._OUTFOR1 has 106 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT1 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM1 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 100 observations read from the data set EMWS5.TSESM4_TRAIN.
NOTE: The data set WORK._TMPDATA has 100 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 100 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT2 has 106 observations and 6 variables.
NOTE: The data set WORK._OUTEST2 has 1 observations and 8 variables.
NOTE: The data set WORK._OUTFOR2 has 106 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT2 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM2 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 100 observations read from the data set EMWS5.TSESM4_TRAIN.
NOTE: The data set WORK._TMPDATA has 100 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 100 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT3 has 106 observations and 6 variables.
NOTE: The data set WORK._OUTEST3 has 2 observations and 8 variables.
NOTE: The data set WORK._OUTFOR3 has 106 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT3 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM3 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 100 observations read from the data set EMWS5.TSESM4_TRAIN.
NOTE: The data set WORK._TMPDATA has 100 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 100 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT4 has 106 observations and 6 variables.
NOTE: The data set WORK._OUTEST4 has 3 observations and 8 variables.
NOTE: The data set WORK._OUTFOR4 has 106 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT4 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM4 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 100 observations read from the data set EMWS5.TSESM4_TRAIN.
NOTE: The data set WORK._TMPDATA has 100 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 100 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT5 has 106 observations and 6 variables.
NOTE: The data set WORK._OUTEST5 has 3 observations and 8 variables.
NOTE: The data set WORK._OUTFOR5 has 106 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT5 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM5 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 100 observations read from the data set EMWS5.TSESM4_TRAIN.
NOTE: The data set WORK._TMPDATA has 100 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 100 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT6 has 106 observations and 6 variables.
NOTE: The data set WORK._OUTEST6 has 2 observations and 8 variables.
NOTE: The data set WORK._OUTFOR6 has 106 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT6 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM6 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 100 observations read from the data set EMWS5.TSESM4_TRAIN.
NOTE: The data set WORK._TMPDATA has 100 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 100 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT7 has 106 observations and 6 variables.
NOTE: The data set WORK._OUTEST7 has 2 observations and 8 variables.
NOTE: The data set WORK._OUTFOR7 has 106 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT7 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM7 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 100 observations read from the data set EMWS5.TSESM4_TRAIN.
NOTE: The data set WORK._TMPDATA has 100 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed: 5
NOTE: Number of forecasts requested: 1
NOTE: Number of forecasts failed: 0
NOTE: There were 100 observations read from the data set WORK._TMPDATA.
NOTE: The data set WORK._OUT8 has 106 observations and 6 variables.
NOTE: The data set WORK._OUTEST8 has 3 observations and 8 variables.
NOTE: The data set WORK._OUTFOR8 has 106 observations and 8 variables.
NOTE: The data set WORK._OUTSTAT8 has 1 observations and 57 variables.
NOTE: The data set WORK._OUTSUM8 has 5 observations and 19 variables.
NOTE: PROCEDURE ESM used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
NOTE: Table WORK.TSSTAT created, with 8 rows and 58 columns.
 
NOTE: Table WORK.TSEST created, with 17 rows and 9 columns.
 
NOTE: Table WORK.TSFOR created, with 848 rows and 9 columns.
 
NOTE: Table WORK.TSOUT created, with 848 rows and 7 columns.
 
NOTE: Table WORK.TSSUM created, with 40 rows and 20 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 8 observations read from the data set WORK.TSSTAT.
NOTE: The data set WORK.BESTMDL has 8 observations and 58 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 8 observations read from the data set WORK.BESTMDL.
NOTE: The data set WORK.BESTMDL has 1 observations and 58 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK.BESTID created, with 1 rows and 4 columns.
 
NOTE: Table EMWS5.TSESM4_OUTFORCST created, with 106 rows and 11 columns.
 
NOTE: Table EMWS5.TSESM4_OUTSTAT created, with 1 rows and 59 columns.
 
NOTE: Table EMWS5.TSESM4_OUTEST created, with 2 rows and 10 columns.
 
NOTE: Table EMWS5.TSESM4_OUTSUM created, with 1 rows and 22 columns.
 
NOTE: PROC SQL statements are executed immediately; The RUN statement has no effect.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK.BESTMDL.
NOTE: The data set WORK._TMPDS1 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS2 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS3 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS4 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS5 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS6 has 1 observations and 58 variables.
NOTE: The data set WORK._TMPDS7 has 0 observations and 58 variables.
NOTE: The data set WORK._TMPDS8 has 0 observations and 58 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 106 observations read from the data set WORK._OUT1.
NOTE: The data set EMWS5.TSESM4_OUTDATA has 106 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: There were 106 observations read from the data set WORK._OUT1.
NOTE: The data set EMWS5.TSESM4_OUTDATA has 106 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: There were 106 observations read from the data set WORK._OUT2.
NOTE: The data set EMWS5.TSESM4_OUTDATA has 106 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: There were 106 observations read from the data set WORK._OUT3.
NOTE: The data set EMWS5.TSESM4_OUTDATA has 106 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: There were 106 observations read from the data set WORK._OUT4.
NOTE: The data set EMWS5.TSESM4_OUTDATA has 106 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: There were 106 observations read from the data set WORK._OUT5.
NOTE: The data set EMWS5.TSESM4_OUTDATA has 106 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: There were 106 observations read from the data set WORK._OUT6.
NOTE: The data set EMWS5.TSESM4_OUTDATA has 106 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: There were 106 observations read from the data set WORK._OUT7.
NOTE: The data set EMWS5.TSESM4_OUTDATA has 106 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: There were 106 observations read from the data set WORK._OUT8.
NOTE: The data set EMWS5.TSESM4_OUTDATA has 106 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
WARNING: The variable mdlID in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable _MODEL_ in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable MSE in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: The data set EMWS5.TSESM4_OUTDATA has 106 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 2 observations read from the data set EMWS5.TSESM4_OUTEST.
NOTE: The data set EMWS5.TSESM4_OUTEST has 2 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTFORCST.
NOTE: The data set EMWS5.TSESM4_OUTFORCST has 106 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM4_OUTSTAT.
NOTE: The data set EMWS5.TSESM4_OUTSTAT has 1 observations and 58 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM4_OUTSUM.
NOTE: The data set EMWS5.TSESM4_OUTSUM has 1 observations and 20 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM4_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM4_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM4_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTFORCST.
NOTE: The data set EMWS5.TSESM4_OUTFORCST has 106 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
WARNING: The variable _TSID_ in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable _SEGMENT_ in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable _NAMEID_ in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTFORCST.
NOTE: The data set EMWS5.TSESM4_OUTLIER has 100 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 100 observations read from the data set EMWS5.TSESM4_OUTLIER.
NOTE: The data set EMWS5.TSESM4_OUTLIERDS has 5 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
WARNING: The variable _TSID_ in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTFORCST.
NOTE: The data set EMWS5.TSESM4_OUTPRED has 6 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
18029
18030
18031  *------------------------------------------------------------*;
18032  * End TRAIN: TSESM4;
18033  *------------------------------------------------------------*;
 
18034  *------------------------------------------------------------*;
18035  * Close any missing semi colons;
18036  *------------------------------------------------------------*;
18037  ;
18038  ;
18039  ;
18040  ;
18041  quit;
18042  *------------------------------------------------------------*;
18043  * Close any unbalanced quotes;
18044  *------------------------------------------------------------*;
18045  /*; *"; *'; */
18046  ;
18047  run;
18048  quit;
18049  /* Reset EM Options */
18050  options formchar="|----|+|---+=|-/\<>*";
18051  options nocenter ls=256 ps=10000;
18052  goptions reset=all device=GIF NODISPLAY;
 
*------------------------------------------------------------*
* Score Log
Date:                December 19, 2019
Time:                13:06:43
*------------------------------------------------------------*
18154  %let EMEXCEPTIONSTRING=;
18155  *------------------------------------------------------------*;
18156  * SCORE: TSESM4;
18157  *------------------------------------------------------------*;
18158  %let EM_ACTION = SCORE;
18159  %let syscc = 0;
18160
18161  %macro EM_TSESM_MAIN;
18162
18163     filename temp catalog 'sashelp.emtsdm.tsesm_macros.source';
18164     %include temp;
18165     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
18166     %include temp;
18167     filename temp;
18168
18169     %if %upcase(&EM_ACTION) = CREATE %then %do;
18170         filename temp catalog 'sashelp.emtsdm.tsesm_create.source';
18171         %include temp;
18172         filename temp;
18173         %EM_TSESM_CREATE;
18174     %end;
18175     %else
18176     %if %upcase(&EM_ACTION) = TRAIN %then %do;
18177          filename temp catalog 'sashelp.emtsdm.tsesm_train.source';
18178             %include temp;
18179             filename temp;
18180          %EM_TSESM_TRAIN;
18181     %end;
18182     %else
18183     %if %upcase(&EM_ACTION) = SCORE %then %do;
18184             filename temp catalog 'sashelp.emtsdm.tsesm_score.source';
18185             %include temp;
18186             filename temp;
18187           %EM_TSESM_SCORE;
18188     %end;
18189     %else
18190     %if %upcase(&EM_ACTION) = REPORT %then %do;
18191             filename temp catalog 'sashelp.emtsdm.tsesm_report.source';
18192             %include temp;
18193             filename temp;
18194            %EM_TSESM_REPORT;
18195     %end;
18196  %mend EM_TSESM_MAIN;
18197  %EM_TSESM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_MACROS.SOURCE.
18198 +/*----------------------------------------------------------------------------------+
18199 + |
18200 + |   Title :  Time Series data Mining Forcating Macros
18201 + |
18202 + |   SUPPORT: Ruiwen Zhang (Ruiwen.Zhang@sas.com)
18203 + |
18204 + |
18205 + +-----------------------------------------------------------------------------------*/
18208 +%macro EM_TSESM_Forecast(indata=,
18209 +                method=,
18210 +                timeinterval=,
18211 +                timeid= ,
18212 +                target= ,
18213 +                tsidvar=,
18214 +                lead=,
18215 +                back=,
18216 +                startsum=,
18217 +                accumulate=,
18218 +                seasonality=,
18219 +                alpha=,
18220 +                extendedvalue=,
18221 +                outest = ,
18222 +                outdata = ,
18223 +                outfor = ,
18224 +                outstat = ,
18225 +                outsum=
18226 +   );
18229 +   %if &tsidvar eq _SEGMENT_ %then %do;
18230 +       proc sort data=&indata out=_tmpdata;
18231 +            by  &tsidvar %EM_CROSSID &timeid ;
18232 +       run;
18233 +       proc timeseries  data =_tmpdata out=_tmpdata;
18234 +            by  &tsidvar %EM_CROSSID;
18235 +            id &timeid interval=&timeinterval accumulate=&accumulate;
18236 +            var &target / ;
18237 +       run;
18238 +       proc esm data =_tmpdata
18239 +   %end;
18240 +   %else %do;
18241 +       proc sort data= &indata out=_tmpdata;
18242 +            by  &tsidvar %EM_CROSSID &timeid ;
18243 +       run;
18244 +       proc esm data = _tmpdata
18245 +   %end;
18246 +            lead=&lead  back=&back startsum=&startsum
18248 +   %if &seasonality ne DEFAULT %then %do;
18249 +            seasonality = &seasonality
18250 +   %end;
18253 +            out=&outdata
18254 +            outest=&outest
18255 +            outfor =&outfor
18256 +            outstat=&outstat
18257 +            outsum= &outsum
18258 +       ;
18259 +        id &timeid  interval = &timeinterval   accumulate=&accumulate ;
18261 +        %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18262 +            %if &target ne %then %do;
18263 +            forecast &target   /  model = none alpha=&alpha;
18264 +            %end;
18265 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18266 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /  model = &method alpha=&alpha use=&extendedvalue;
18267 +            %end;
18268 +        %end;
18269 +        %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
18270 +            %if &target ne %then %do;
18271 +            forecast &target /  model =&method alpha=&alpha;
18272 +            %end;
18273 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18274 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
18275 +            %end;
18276 +        %end;
18277 +        %else %do; /* for KLD, FORECAST Cluster , SIMILARITY */
18278 +            forecast &target /*%EM_INTERVAL_INPUT*/ /  model = &method alpha=&alpha use=predict;
18279 +        %end;
18281 +   %if &tsidvar ne %then %do;
18282 +        by &tsidvar %EM_CROSSID ;
18283 +   %end;
18284 +   run;
18285 +%mend EM_TSESM_Forecast;
18288 +%macro EM_TSESM_CreateOutFor(indata=,
18289 +                            target=,
18290 +                            timeid=,
18291 +                            tsidVar=,
18292 +                            percent=,
18293 +                            outdata=);
18295 +  %let lowerBound = L&percent;
18296 +  %let upperBound = U&percent;
18298 +  data ds_fore(rename=(&target=FORECAST)  drop=_TYPE_)
18299 +       ds_resid(rename=(&target=RESIDUAL) drop=_TYPE_)
18300 +       ds_act(rename=(&target=ACTUAL) drop=_TYPE_)
18301 +       ds_lower(rename=(&target=LBOUND)  drop=_TYPE_)
18302 +       ds_upper(rename=(&target=UBOUND) drop=_TYPE_)
18303 +       ds_std(rename=(&target=STD) drop=_TYPE_);
18304 +     set &indata;
18305 +       if _TYPE_="FORECAST" then output ds_fore;
18306 +       if _TYPE_="RESIDUAL" then output ds_resid;
18307 +       if _TYPE_="ACTUAL" then output ds_act;
18308 +       if _TYPE_="&lowerBound" then output ds_lower;
18309 +       if _TYPE_="&upperBound" then output ds_upper;
18310 +       if _TYPE_="STD" then output ds_std;
18311 +  run;
18313 +  data &outdata;
18314 +       merge ds_fore ds_resid ds_act ds_lower ds_upper ds_std;
18315 +       by &tsidVar &timeid;
18316 +       label  FORECAST = "Forecast";
18317 +       label  ACTUAL = "Actual";
18318 +       label  RESIDUAL = "Residual";
18319 +       label  LBOUND = "Lower Bound";
18320 +       label  UBOUND = "Upper Bound";
18321 +       label   STD = "Standard Deviation";
18322 +  run;
18323 +%mend EM_TSESM_CreateOutFor;
18326 +%macro EM_TSESM_CreateOutExpand(indata=,
18327 +                       target=,
18328 +                       timeid=,
18329 +                       tsidVar=,
18330 +                       percent=,
18331 +                       outlower=,
18332 +                       outupper=,
18333 +                       outdata=);
18335 +  %let lowerBound = L&percent;
18336 +  %let upperBound = U&percent;
18338 +  /*proc print data=&indata(obs=200);
18339 +  run;
18340 +  */
18342 +  data ds_fore(drop=&target)
18343 +       ds_lower(drop=&target)
18344 +       ds_upper(drop=&target)
18345 +       ds_act;
18346 +     set &indata;
18347 +       if _TYPE_="FORECAST" and _LEAD_  > 0 then output ds_fore;
18348 +       if _TYPE_="&lowerBound" and  _LEAD_  > 0 then output ds_lower;
18349 +       if _TYPE_="&upperBound" and  _LEAD_  > 0 then output ds_upper;
18350 +       if _TYPE_="ACTUAL" then output ds_act;
18351 +  run;
18353 +  /*
18354 +  proc print data = ds_fore;
18355 +  proc print data=ds_act;
18356 +  run;
18357 +  */
18358 +  data &outdata;
18359 +       merge ds_act ds_fore;
18360 +       by &tsidVar &timeid;
18361 +  run;
18363 +  data &outlower;
18364 +       merge ds_act ds_lower;
18365 +       by &tsidVar &timeid;
18366 +  run;
18368 +  data &outupper;
18369 +       merge ds_act ds_upper;
18370 +       by &tsidVar &timeid;
18371 +  run;
18372 +  /*
18373 +  proc print data=&outdata(obs=300);
18374 +  proc print data=&outlower(obs=300);
18375 +  proc print data=&outupper(obs=300);
18376 +  run;
18377 +  */
18378 +%mend EM_TSESM_CreateOutExpand;
18382 +%macro EM_TSESM_MakeOutClus(indata=,
18383 +                   target=,
18384 +                   timeid=,
18385 +                   tsidVar=,
18386 +                   percent=,
18387 +                   outlower=,
18388 +                   outupper=,
18389 +                   outdata=);
18392 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
18394 +  data &outdata(rename=(_NAME_ =_NAMEID_));
18395 +       set &indata;
18396 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD;
18397 +  run;
18399 +  %let dsid=%sysfunc(open(&outdata));
18400 +  %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
18401 +  %let dsid=%sysfunc(close(&dsid));
18403 +  %if &vn_name > 0 %then %do;
18404 +      data &outdata(drop=_NAMEID_);
18405 +           merge &EM_USER_TSIDMAP &outdata;
18406 +           by _TSID_;
18407 +      run;
18408 +  %end;
18409 +  %else %do;
18410 +      proc sort data= &outdata; by _NAMEID_;
18411 +      run;
18412 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
18413 +      run;
18414 +      data &outdata(drop=_NAMEID_);
18415 +           merge &EM_USER_TSIDMAP &outdata;
18416 +           by _NAMEID_;
18417 +      run;
18418 +  %end;
18420 +%mend EM_TSESM_MakeOutClus;
18423 +%macro EM_TSESM_CreateOutEst(indata=,
18424 +                    target=,
18425 +                    timeid=,
18426 +                    outdata=);
18428 +%mend EM_TSESM_CreateOutEst;
18431 +%macro EM_TSESM_Best_Forecast(indata=,
18432 +                method=,
18433 +                timeinterval=,
18434 +                timeid= ,
18435 +                target= ,
18436 +                tsidvar=,
18437 +                lead=,
18438 +                back=,
18439 +                startsum=,
18440 +                accumulate=,
18441 +                seasonality=,
18442 +                alpha=,
18443 +                criterion=,
18444 +                extendedvalue=,
18445 +                outest = ,
18446 +                outdata = ,
18447 +                outfor = ,
18448 +                outstat = ,
18449 +                outsum=
18450 +   );
18452 +   %let _indata = &indata;
18454 +   %if &tsidvar eq _SEGMENT_ %then %do;
18455 +       proc sort data=&indata out=_tmpdata;
18456 +            by  &tsidvar %EM_CROSSID &timeid ;
18457 +       run;
18458 +       proc timeseries  data =_tmpdata out=_tmpdata;
18459 +            by  &tsidvar %EM_CROSSID ;
18460 +            id &timeid interval=&timeinterval accumulate=&accumulate;
18461 +            var &target / ;
18462 +       run;
18463 +       %let _indata = _tmpdata;
18464 +   %end;
18466 +   %let n_model = 0;
18468 +   %if &EM_PROPERTY_SIMPLE eq Y %then %do;
18470 +       %let n_model = %eval(&n_model+1);
18472 +       %let _ds_out =_out&n_model;
18473 +       %let _ds_outest =_outest&n_model;
18474 +       %let _ds_outfor =_outfor&n_model;
18475 +       %let _ds_outstat =_outstat&n_model;
18476 +       %let _ds_outsum=_outsum&n_model;
18478 +       %EM_TSESM_ESM(method=SIMPLE,
18479 +        timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18480 +        lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18481 +        out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18482 +        );
18484 +   %end;
18485 +   %if &EM_PROPERTY_DOUBLE eq Y %then %do;
18487 +       %let n_model = %eval(&n_model+1);
18489 +       %let _ds_out =_out&n_model;
18490 +       %let _ds_outest =_outest&n_model;
18491 +       %let _ds_outfor =_outfor&n_model;
18492 +       %let _ds_outstat =_outstat&n_model;
18493 +       %let _ds_outsum=_outsum&n_model;
18495 +       %EM_TSESM_ESM(method=DOUBLE,
18496 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18497 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18498 +             out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18499 +       );
18500 +   %end;
18502 +   %if &EM_PROPERTY_LINEAR eq Y %then %do;
18504 +       %let n_model = %eval(&n_model+1);
18505 +       %let _ds_out =_out&n_model;
18506 +       %let _ds_outest =_outest&n_model;
18507 +       %let _ds_outfor =_outfor&n_model;
18508 +       %let _ds_outstat =_outstat&n_model;
18509 +       %let _ds_outsum=_outsum&n_model;
18511 +       %EM_TSESM_ESM(method=LINEAR,
18512 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18513 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18514 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18515 +        );
18516 +   %end;
18518 +   %if &EM_PROPERTY_DAMPTREND eq Y %then %do;
18520 +       %let n_model = %eval(&n_model+1);
18522 +       %let _ds_out =_out&n_model;
18523 +       %let _ds_outest =_outest&n_model;
18524 +       %let _ds_outfor =_outfor&n_model;
18525 +       %let _ds_outstat =_outstat&n_model;
18526 +       %let _ds_outsum=_outsum&n_model;
18528 +       %EM_TSESM_ESM(method=DAMPTREND,
18529 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18530 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18531 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18532 +            );
18533 +   %end;
18534 +   /*------- Seasonal model ------*/
18536 +   %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do;
18538 +   %if (&EM_PROPERTY_WINTERS eq Y) %then %do;
18540 +       %let n_model = %eval(&n_model+1);
18542 +       %let _ds_out =_out&n_model;
18543 +       %let _ds_outest =_outest&n_model;
18544 +       %let _ds_outfor =_outfor&n_model;
18545 +       %let _ds_outstat =_outstat&n_model;
18546 +       %let _ds_outsum=_outsum&n_model;
18548 +       %EM_TSESM_ESM(method=WINTERS,
18549 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18550 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18551 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18552 +        );
18553 +   %end;
18555 +   %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then %do;
18557 +       %let n_model = %eval(&n_model+1);
18559 +       %let _ds_out =_out&n_model;
18560 +       %let _ds_outest =_outest&n_model;
18561 +       %let _ds_outfor =_outfor&n_model;
18562 +       %let _ds_outstat =_outstat&n_model;
18563 +       %let _ds_outsum=_outsum&n_model;
18565 +       %EM_TSESM_ESM(method=ADDSEASONAL,
18566 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18567 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18568 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18569 +       );
18570 +   %end;
18572 +   %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %do;
18574 +       %let n_model = %eval(&n_model+1);
18576 +       %let _ds_out =_out&n_model;
18577 +       %let _ds_outest =_outest&n_model;
18578 +       %let _ds_outfor =_outfor&n_model;
18579 +       %let _ds_outstat =_outstat&n_model;
18580 +       %let _ds_outsum=_outsum&n_model;
18582 +       %EM_TSESM_ESM(method=MULTSEASONAL,
18583 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18584 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18585 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18586 +       );
18587 +   %end;
18589 +   %if (&EM_PROPERTY_ADDWINTERS eq Y) %then %do;
18591 +       %let n_model = %eval(&n_model+1);
18593 +       %let _ds_out =_out&n_model;
18594 +       %let _ds_outest =_outest&n_model;
18595 +       %let _ds_outfor =_outfor&n_model;
18596 +       %let _ds_outstat =_outstat&n_model;
18597 +       %let _ds_outsum=_outsum&n_model;
18599 +       %EM_TSESM_ESM(method=ADDWINTERS,
18600 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
18601 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
18602 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
18603 +            );
18604 +   %end;
18607 +   %end; /* end of %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do; */
18608 +   /*-------- end of seasonal model  ------------------------------------------------------*/
18610 +   %if &n_model eq 0 %then %do;
18612 +       /*---- %PUT  ERROR:THE NUMBER OF CANDIDATE MODELS IS ZERO;  */
18613 +       %let  EMEXCEPTIONSTRING = exception.server.tsdm.zerocandidatemodel;
18614 +   %end;
18615 +   %else %do;
18616 +         %EM_TSESM_BestModelSel(crit=&criterion,
18617 +                               n_mdl=&n_model,
18618 +                               tsidvar=&tsidvar,
18619 +                               timeid=&timeid,
18620 +                               out=&outdata,
18621 +                               outest=&outest,
18622 +                               outfor =&outfor,
18623 +                               outstat=&outstat,
18624 +                               outsum=&outsum
18625 +                  );
18626 +   %end;
18628 +%mend EM_TSESM_Best_Forecast;
18631 +%macro EM_TSESM_ESM(method= ,
18632 +           timeinterval=,
18633 +           timeid= ,
18634 +           target= ,
18635 +           tsidvar=,
18636 +           lead=,
18637 +           back=,
18638 +           startsum=,
18639 +           accumulate=,
18640 +           seasonality=,
18641 +           alpha=,
18642 +           out= ,
18643 +           outest= ,
18644 +           outfor= ,
18645 +           outstat= ,
18646 +           outsum=
18647 +           );
18649 +       proc sort data= &_indata out=_tmpdata;
18650 +            by  &tsidvar %EM_CROSSID &timeid ;
18651 +       run;
18652 +       proc esm data = _tmpdata  lead=&lead    back=&back  startsum=&startsum
18654 +       %if &seasonality ne DEFAULT %then %do;
18655 +                     seasonality = &seasonality
18656 +       %end;
18657 +            out=&out
18658 +            outest=&outest
18659 +            outfor =&outfor
18660 +            outstat=&outstat
18661 +            outsum= &outsum
18662 +            ;
18663 +       id &timeid  interval = &timeinterval  accumulate=&accumulate  ;
18665 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18666 +            %if &target ne %then %do;
18667 +            forecast &target   /  model = none alpha=&alpha;
18668 +            %end;
18669 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18670 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha use=&extendedvalue;
18671 +            %end;
18672 +       %end;
18673 +       %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
18674 +            %if &target ne %then %do;
18675 +            forecast &target /  model =&method alpha=&alpha;
18676 +            %end;
18677 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18678 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
18679 +            %end;
18680 +       %end;
18681 +       %else %do;   /*----- CLUSTER INPUT , KLD, SIMILARITY INPUT ------*/
18682 +            %if &target ne %then %do;
18683 +            forecast &target   /  model = &method alpha=&alpha;
18684 +            %end;
18685 +            /*
18686 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
18687 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha;
18688 +            %end;
18689 +            */
18690 +       %end;
18692 +       %if &tsidvar ne %then %do;
18693 +        by &tsidvar %EM_CROSSID;
18694 +       %end;
18695 +       run;
18697 +%mend EM_TSESM_ESM;
18701 +%macro EM_TSESM_BestModelSel(crit=,
18702 +                    n_mdl=,
18703 +                    tsidvar=_TSID_,
18704 +                    timeid=MNTH_YR,
18705 +                    out=&_outdata,
18706 +                    outest=&_outest,
18707 +                    outfor =&_outfor,
18708 +                    outstat=&_outstat,
18709 +                    outsum=&_outsum
18710 +    );
18712 +   %let statbls=select *, 1 as mdlID from _outstat1;
18713 +   %let estbls=select *,  1 as mdlID from _outest1;
18714 +   %let fortbls=select *, 1 as mdlID from _outfor1;
18715 +   %let outbls=select *,  1 as mdlID from _out1;
18716 +   %let sumtbls=select *, 1 as mdlID from _outsum1;
18717 +   %do i=2 %to &n_mdl;
18718 +      %let statbls=&statbls union all select *, &i as mdlID from _outstat&i;
18719 +        %let estbls=&estbls union all select *, &i as mdlID from _outest&i;
18720 +        %let fortbls=&fortbls union all select *, &i as mdlID from _outfor&i;
18721 +        %let outbls=&outbls union all select *, &i as mdlID from _out&i;
18722 +        %let sumtbls=&sumtbls union all select *, &i as mdlID from _outsum&i;
18723 +   %end;
18725 +   %let dsid=%sysfunc(open(_out1));
18726 +   %let vn_tsid = 0;
18728 +   %if &dsid > 0 %then %do;
18729 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
18730 +         %let dsid = %sysfunc(close(&dsid));
18731 +   %end;
18733 +   %if &vn_tsid <= 0  %then %do;
18734 +       %let tsidvar=_NAME_;
18735 +   %end;
18737 +  /*
18738 +  %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18739 +     %let tsidvar=_NAME_;
18740 +   %end;
18741 +  */
18743 +   proc sql;
18744 +     create table tsstat as &statbls;
18745 +     create table tsest  as &estbls;
18746 +     create table tsfor  as &fortbls;
18747 +     create table tsout  as &outbls;
18748 +     create table tssum  as &sumtbls;
18749 +   quit;
18751 +    proc sort data=tsstat out=bestmdl;
18752 +        by &tsidvar &crit mdlID;
18753 +    run;
18755 +    * when multiple BEST model found;
18756 +    * use the one with smallest model ID;
18757 +    data bestmdl;
18758 +        set bestmdl;
18759 +        by &tsIDvar;
18760 +        if first.&tsIDVar;
18761 +    run;
18763 +   proc sql;
18764 +      create table bestID as
18765 +        select distinct(tsest.&tsidvar), _model_, &crit, bestmdl.mdlID
18766 +        from bestmdl,tsest
18767 +        where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar;
18769 +      create table &outfor
18770 +        as select tsfor.*, _model_, &crit from tsfor, bestID
18771 +        where tsfor.&tsidvar=bestID.&tsidvar and tsfor.mdlID=bestID.mdlID order by &tsidvar, &timeid;
18773 +        create table &outstat
18774 +        as select tsstat.*, _model_ from tsstat, bestID
18775 +      where tsstat.&tsidvar=bestID.&tsidvar and tsstat.mdlID=bestID.mdlID order by &tsidvar;
18777 +        create table &outest
18778 +        as select tsest.*, &crit from bestmdl, tsest
18779 +      where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar order by &tsidvar;
18781 +      create table &outsum
18782 +        as select tssum.*, _model_, &crit from tssum, bestID
18783 +      where tssum.&tsidvar=bestID.&tsidvar and tssum.mdlID=bestID.mdlID order by &tsidvar;
18785 +      /*
18786 +      %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
18787 +        create table &out
18788 +          as select tsout.*, _model_, &crit from tsout, bestID
18789 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
18790 +      %end;
18791 +      */
18793 +      %if &tsidvar eq _TSID_ %then %do;
18795 +         create table &out
18796 +          as select tsout.*, _model_, &crit from tsout, bestID
18797 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
18799 +      %end;
18800 + run;
18801 +quit;
18803 + /*%if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
18805 + %if &tsidvar = _NAME_ %then %do;
18806 +      data
18807 +            %let i=1;
18808 +            %do i=1 %to &n_mdl;
18809 +               %let _tmpdsname = _tmpds&i;
18810 +                    &_tmpdsname
18811 +            %end;
18812 +        ;
18813 +         set work.Bestmdl;
18814 +            %let i=1;
18815 +            %do i=1 %to &n_mdl;
18816 +               %let _tmpdsname = _tmpds&i;
18817 +                  if mdlID = &i then output &_tmpdsname;
18818 +            %end;
18819 +      run;
18821 +      data &out;
18822 +           set _out1;
18823 +           keep &timeid %EM_TARGET;
18824 +      run;
18825 +      %let i=1;
18826 +      %do i=1 %to &n_mdl;
18827 +          %let _tmpdsname = _tmpds&i;
18828 +          %let _outdsname = _out&i;
18830 +          data &out;
18831 +               set &out;
18832 +               set &_outdsname(keep=
18833 +               %let dsid=%sysfunc(open(&_tmpdsname));
18834 +               %if &dsid > 0 %then %do;
18835 +                  %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
18836 +                  %do %while(^%sysfunc(fetch(&dsid)));
18837 +                     %let _name  = %sysfunc(getvarc(&dsid, &vn_name));
18838 +                          &_name
18839 +                  %end;
18840 +                  %let dsid = %sysfunc(close(&dsid));
18841 +               %end;
18842 +               );
18843 +           run;
18844 +       %end;
18846 +%end;
18848 +data &out;
18849 +     set  &out;
18850 +      drop mdlID _MODEL_ &crit;
18851 +data &outest;
18852 +      set  &outest;
18853 +      drop mdlID &crit;
18854 +data &outfor;
18855 +     set &outfor;
18856 +     drop mdlID &crit;
18857 +data &outstat;
18858 +     set &outstat;
18859 +     drop mdlID;
18860 +data &outsum;
18861 +     set &outsum;
18862 +     drop mdlID &crit;
18863 +run;
18865 +%mend EM_TSESM_BestModelSel;
18869 +%macro EM_TSESM_MakeOutlierIndex(indata=,
18870 +                        target=,
18871 +                        timeid=,
18872 +                        outoutlier=,
18873 +                        outlierds=,
18874 +                        outdata=);
18875 +%let label_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlier, noquote));
18876 +%let str_Actual_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actualoutlier, noquote));
18877 +%let str_Actual = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actual, noquote));
18878 +data &outdata;
18879 +     set &indata;
18880 +     length OutlierIndex 8.;
18881 +     length Outlier  $40;
18882 +     label  OutlierIndex = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlierindex, noquote))";
18883 +     label  Outlier = "&label_Outlier";
18884 +   /*  if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&label_Outlier";end;
18885 +       else  do; OutlierIndex=0; outlier =" "; end; */
18886 +     if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&str_Actual_Outlier";end;
18887 +       else  do; OutlierIndex=0; outlier ="&str_Actual"; end;
18888 +run;
18890 +data  &outoutlier;
18891 +      set  &outdata;
18892 +      keep &timeid _TSID_ _SEGMENT_ _NAME_ _NAMEID_ OUTLIERINDEX OUTLIER PREDICT;
18893 +      if ACTUAL = . then delete;
18894 +run;
18896 +data &outlierds;
18897 +     set &outoutlier;
18898 +     if OUTLIERINDEX = 0 then delete;
18899 +     Drop OUTLIERINDEX;
18900 +run;
18902 +%mend  EM_TSESM_MakeOutlierIndex;
18905 +%macro EM_TSESM_MakeSmoothedOutds(indata=,
18906 +                         inoutlierds=,
18907 +                         target=,
18908 +                         timeid=,
18909 +                         tsidvar=_TSID_,
18910 +                         replace=,
18911 +                         outdata=);
18914 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
18917 +%let dsid=%sysfunc(open(&indata));
18918 +%let vn_tsid = 0;
18919 +%if &dsid > 0 %then %do;
18920 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
18921 +         %let dsid = %sysfunc(close(&dsid));
18922 +%end;
18924 +%if &vn_tsid <= 0  %then %do;
18925 +    %let tsidvar=_NAME_;
18926 +%end;
18928 +%if &tsidvar = _TSID_ %then %do;
18929 +/* %if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
18930 + /*    data &outdata;
18931 +          merge &indata &inoutlierds;
18932 +          by _TSID_ &timeid;
18933 +          if OutlierIndex > 0 then
18934 +          %if &replace eq PREDICT %then %do;
18935 +             &target = PREDICT;
18936 +          %end;
18937 +          %else %do;
18938 +             &target = .;
18939 +          %end;
18940 +           Drop Predict _NAME_ OutlierIndex;
18941 +     run;     */
18942 +  %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
18943 +     %if &dsid > 0 %then %do;
18944 +         %let vn_nameid =%sysfunc(varnum(&dsid, _VARNAME_));
18945 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
18946 +         %let i = 1;
18947 +              %do %while(^%sysfunc(fetch(&dsid)));
18948 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
18949 +                  %let _vartsid= %sysfunc(getvarn(&dsid, &vn_tsid));
18950 +                  %if &i eq 1 %then %do;
18951 +                      data _tmpoutlier;
18952 +                           set &inoutlierds;
18953 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid then output;
18954 +                      run;
18955 +                      data &outdata;
18956 +                           merge &indata _tmpoutlier;
18957 +                           by _TSID_ &timeid ;
18958 +                           if OutlierIndex  > 0 then
18959 +                              %if &replace eq PREDICT %then %do;
18960 +                                &_varname = PREDICT;
18961 +                              %end;
18962 +                              %else %do;
18963 +                                &_varname = .;
18964 +                              %end;
18965 +                            Drop Predict _NAME_  OutlierIndex Outlier;
18966 +                      run;
18967 +                   %end;
18968 +                   %else %do;
18969 +                      data _tmpoutlier;
18970 +                           set &inoutlierds;
18971 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid  then output;
18972 +                      run;
18973 +                      data &outdata;
18974 +                           merge &outdata _tmpoutlier;
18975 +                           by _TSID_ &timeid ;
18976 +                           if OutlierIndex  > 0 then
18977 +                              %if &replace eq PREDICT %then %do;
18978 +                                &_varname = PREDICT;
18979 +                              %end;
18980 +                              %else %do;
18981 +                                &_varname = .;
18982 +                              %end;
18983 +                           Drop Predict _NAME_  OutlierIndex Outlier;
18984 +                      run;
18985 +                   %end;
18986 +                   %let i = %eval(&i+1);
18988 +              %end;
18989 +           %let dsid = %sysfunc(close(&dsid));
18990 +      %end;
18991 +%end;
18992 +%else %do;  /*  %if &tsidvar = _NAME_ %then %do; */
18994 +     %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
18995 +     %if &dsid > 0 %then %do;
18996 +         %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
18997 +         %let i = 1;
18998 +              %do %while(^%sysfunc(fetch(&dsid)));
18999 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
19000 +                  %if &i eq 1 %then %do;
19001 +                      data _tmpoutlier;
19002 +                           set &inoutlierds;
19003 +                           if _NAME_ ="&_varname"  then output;
19004 +                      run;
19005 +                      data &outdata;
19006 +                           merge &indata _tmpoutlier;
19007 +                           by &timeid;
19008 +                           if OutlierIndex  > 0 then
19009 +                              %if &replace eq PREDICT %then %do;
19010 +                                &_varname = PREDICT;
19011 +                              %end;
19012 +                              %else %do;
19013 +                                &_varname = .;
19014 +                              %end;
19015 +                            Drop Predict _NAME_ OutlierIndex Outlier;
19016 +                      run;
19017 +                   %end;
19018 +                   %else %do;
19019 +                      data _tmpoutlier;
19020 +                           set &inoutlierds;
19021 +                           if _NAME_ ="&_varname"  then output;
19022 +                      run;
19023 +                      data &outdata;
19024 +                           merge &outdata _tmpoutlier;
19025 +                           by &timeid;
19026 +                           if OutlierIndex  > 0 then
19027 +                              %if &replace eq PREDICT %then %do;
19028 +                                &_varname = PREDICT;
19029 +                              %end;
19030 +                              %else %do;
19031 +                                &_varname = .;
19032 +                              %end;
19033 +                           Drop Predict _NAME_ OutlierIndex Outlier;
19034 +                      run;
19035 +                   %end;
19036 +                   %let i = %eval(&i+1);
19038 +              %end;
19039 +           %let dsid = %sysfunc(close(&dsid));
19040 +      %end;
19041 +      %else %do;
19042 +            /* this block is added 09022011*/
19043 +            /* works for wide table in which each time series has a column */
19045 +            proc transpose data=&indata out=_tmpdata1;
19046 +                by &timeID;
19047 +            run;
19049 +            proc sql;
19050 +                create table _tmpdata2 as
19051 +                    select a.*, b.outlierindex, b.outlier, b.predict
19052 +                        from _tmpdata1 as a left join &inoutlierds as b
19053 +                            on a.&timeID eq b.&timeID and a._name_ eq b._name_
19054 +                        order by a.&timeID, a._name_
19055 +                    ;
19056 +            quit;
19058 +            data _tmpdata2;
19059 +                set _tmpdata2;
19060 +                if outlierindex eq 1 then
19061 +                    if &replace eq PREDICT then col1=predict; else col1=.;
19062 +            run;
19064 +            proc transpose data=_tmpdata2 out=_tmpdata3(drop=_name_ _label_);
19065 +                by &timeID;
19066 +                ID _name_;
19067 +                var col1;
19068 +            proc sort data=&inoutlierds out=_tmpoutlier;
19069 +                by &timeID _name_;
19070 +            proc transpose data=_tmpoutlier out=_tmpdata4(drop=_name_ _label_) prefix=Outlier_;
19071 +                by &timeID;
19072 +                ID _name_;
19073 +                var outlier;
19074 +            run;
19076 +            data &outdata;
19077 +                merge _tmpdata3 _tmpdata4;
19078 +                by &timeID;
19079 +            run;
19080 +      %end;
19081 +%end;
19082 +%mend EM_TSESM_MakeSmoothedOutds;
19084 +%Macro EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
19085 +                  insumdata=&EM_USER_OUTSUM,
19086 +                target=&_targetVar,
19087 +                timeid=&_timeidVar,
19088 +                futurepoint=1,
19089 +                outKLD=&EM_USER_OUTKLD
19090 +                );
19092 +%if &futurepoint > 0 %then %do;
19094 +proc sort data=&indata out=_tmptimeid;
19095 +     by &timeid;
19096 +run;
19098 +data _tmptimeid(keep=&timeid);
19099 +      set _tmptimeid; by &timeid;
19100 +      if first.&timeid then output;
19101 +run;
19103 +%let _targetTime =;
19104 +%let dsid=%sysfunc(open(work._tmptimeid));
19105 +%if &dsid > 0 %then %do;
19106 +    %let vn_timeid =%sysfunc(varnum(&dsid, &timeid));
19107 +    %let i = 1;
19108 +    %do %while(^%sysfunc(fetch(&dsid)));
19109 +       %if &i eq &futurepoint %then %do;
19110 +       %let _targetTime  = %sysfunc(getvarn(&dsid, &vn_timeid));
19111 +       %end;
19112 +       %let i = %eval(&i+1);
19113 +    %end;
19114 +    %let dsid = %sysfunc(close(&dsid));
19115 +%end;
19117 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
19118 +   set &indata;
19119 +   if &timeid eq &_targetTime then output;
19120 +run;
19122 +%end;  /* end of %if &futurepoint > 0 %then %do; */
19123 +%else %do;
19126 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
19127 +   set &insumdata;
19128 +run;
19131 +%end;
19133 +%EM_TSESM_KLD(indata=work._tmpKLD, outdata=&outKLD);
19135 +/* Merge TSIDMAP  */
19137 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19138 +data &outKLD(rename=(_NAME_ =_NAMEID_));
19139 +       set &outKLD;
19140 +run;
19142 +%let dsid=%sysfunc(open(&outKLD));
19143 +%let vn_name =%sysfunc(varnum(&dsid, _TSID_));
19144 +%let dsid=%sysfunc(close(&dsid));
19146 +%if &vn_name > 0 %then %do;
19147 +      data &outKLD(drop=_NAMEID_);
19148 +           merge &EM_USER_TSIDMAP &outKLD;
19149 +           by _TSID_;
19150 +      run;
19151 +%end;
19152 +%else %do;
19153 +      proc sort data= &outKLD; by _NAMEID_;
19154 +      run;
19155 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
19156 +      run;
19157 +      data &outKLD(drop=_NAMEID_);
19158 +           merge &EM_USER_TSIDMAP &outKLD;
19159 +           by _NAMEID_;
19160 +      run;
19161 +%end;
19163 +/* delete _tmptimeid  _tmpKLD */
19164 +%Mend  EM_TSESM_MakeOutKLD;
19167 +%Macro EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
19168 +                 target=&_targetVar,
19169 +                 timeid=&_timeidVar,
19170 +                 outdata=&EM_USER_OUTPRED
19171 +                 );
19173 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19174 +%let _EndTime = ;
19175 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19176 +%if &dsid > 0 %then %do;
19177 +    %let vn_end =%sysfunc(varnum(&dsid, END));
19178 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
19179 +    %do %while(^%sysfunc(fetch(&dsid)));
19180 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19181 +       /*--------------------------------------------------------
19182 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
19183 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
19184 +        ---------------------------------------------------------*/
19185 +    %end;
19186 +    %let dsid = %sysfunc(close(&dsid));
19187 +%end;
19189 +data &outdata(keep= _TSID_ _NAME_  &timeid PREDICT LOWER UPPER STD);
19190 +     set &indata;
19191 +     if &timeid > &_EndTime then output;
19192 +run;
19193 +%Mend  EM_TSESM_MakeOutPred;
19196 +%macro EM_TSESM_KLD(indata=work._tmp, outdata=_out);
19198 +%let std_x = ;
19199 +%let mu_y = ;
19201 +%let dsid=%sysfunc(open(&indata));
19202 +%if &dsid > 0 %then %do;
19203 +    %let vn_pred =%sysfunc(varnum(&dsid, PREDICT));
19204 +    %let vn_std  = %sysfunc(varnum(&dsid, STD));
19205 +    %let i=1;
19206 +    %do %while(^%sysfunc(fetch(&dsid)));
19207 +        %let _pred  = %sysfunc(getvarn(&dsid, &vn_pred));
19208 +        %let _std  = %sysfunc(getvarn(&dsid, &vn_std));
19209 +        %let _tsid = _TSID&i.;
19210 +        /* create new data set */
19211 +            %if &i = 1 %then %do;
19212 +            data _tmpindata;
19213 +                set &indata;
19214 +                  mu_x = &_pred;
19215 +                  std_x = &_std;
19216 +                  rename predict = mu_y;
19217 +                  rename std = std_y;
19218 +            run;
19219 +        data _tmpout;
19220 +                 set _tmpindata;
19221 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
19222 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
19223 +             &_tsid= (KLD1+KLD2)/2;
19224 +             if &_tsid < 0 then &_tsid = 0;
19225 +                   drop KLD1 KLD2;
19226 +         run;
19227 +             %end;
19228 +         %else %do;
19229 +         data _tmpindata;
19230 +                  set _tmpout;
19231 +                  mu_x = &_pred;
19232 +                  std_x = &_std;
19234 +             run;
19235 +         data _tmpout;
19236 +                 set _tmpindata;
19237 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
19238 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
19239 +             &_tsid= (KLD1+KLD2)/2;
19240 +             if &_tsid < 0 then &_tsid = 0;
19241 +                   drop KLD1 KLD2;
19242 +         run;
19244 +         %end;
19245 +             %let i = %eval(&i+1);
19247 +    %end;
19248 +    %let dsid = %sysfunc(close(&dsid));
19249 +    data &outdata;
19250 +         set _tmpout;
19251 +         drop mu_x mu_y std_x std_y;
19252 +    run;
19253 +%end;
19254 +%mend EM_TSESM_KLD;
19257 +%macro EM_TSESM_MakeOutClusInput(indata=,
19258 +                   target=,
19259 +                   timeid=,
19260 +                   tsidVar=,
19261 +                   percent=,
19262 +                   outlower=,
19263 +                   outupper=,
19264 +                   esmmethod=,
19265 +                   criterion=,
19266 +                   outdata=);
19268 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19270 +  data &outdata(rename=(_NAME_ =_NAMEID_));
19271 +       set &indata;
19272 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
19273 +  %if &esmmethod eq BEST %then %do;
19274 +      mdlID _MODEL_ &criterion
19276 +  %end;
19277 +  ;
19278 +  run;
19280 +  %let dsid=%sysfunc(open(&outdata));
19281 +       %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
19282 +  %let dsid=%sysfunc(close(&dsid));
19284 +  %if &vn_name > 0 %then %do;
19285 +      proc sort data= &outdata; by _TSID_;
19286 +      run;
19287 +      proc sort data = &EM_USER_TSIDMAP ;by _TSID_;
19288 +      run;
19290 +      data &outdata(drop=_NAMEID_);
19291 +           merge &EM_USER_TSIDMAP &outdata;
19292 +           by _TSID_;
19293 +      run;
19294 +  %end;
19295 +  %else %do;
19296 +      proc sort data= &outdata; by _NAMEID_;
19297 +      run;
19298 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
19299 +      run;
19300 +      data &outdata(drop=_NAMEID_);
19301 +           merge &EM_USER_TSIDMAP &outdata;
19302 +           by _NAMEID_;
19303 +      run;
19304 +  %end;
19306 +%mend EM_TSESM_MakeOutClusInput;
19308 +%macro EM_TSESM_MakeOutSimInput(indata=,
19309 +                   inoutfor=,
19310 +                   target=,
19311 +                   timeid=,
19312 +                   tsidVar=,
19313 +                   esmmethod=,
19314 +                   criterion=,
19315 +                   outdata=);
19318 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19319 +  %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19321 +   %let _EndTime = ;
19322 +   %let dsid=%sysfunc(open(&EM_USER_TSMETA));
19323 +   %if &dsid > 0 %then %do;
19324 +   %let vn_end =%sysfunc(varnum(&dsid, END));
19325 +   %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
19326 +   %do %while(^%sysfunc(fetch(&dsid)));
19327 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19328 +   %end;
19329 +   %let dsid = %sysfunc(close(&dsid));
19330 +   %end;
19332 +   %em_varMacro(name=tsesm_crossid, metadata= &EM_DATA_VARIABLESET, key=NAME,
19333 +       where=%nrbquote(ROLE='CROSSID' and USE ne 'N') , nummacro=tsesm_crossidNum);
19335 +   data _out1;
19336 +       set &indata;
19337 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
19338 +           %tsesm_crossid
19339 +   %if &esmmethod eq BEST %then %do;
19340 +      mdlID _MODEL_ &criterion
19341 +   %end;
19342 +   ;
19343 +   run;
19345 +    %let dsid=%sysfunc(open(work._out1));
19346 +    %if &dsid > 0 %then %do;
19347 +      %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
19348 +      %let dsid = %sysfunc(close(&dsid));
19349 +    %end;
19351 +    /*
19352 +    proc print data=_out1(obs=10);
19353 +    run;
19354 +    */
19355 +    %let _existtsid = Y;
19356 +    %if (&vn_tsid = 0)  %then %do;
19357 +    %let _existtsid = N;
19358 +    %goto NO_TSID_SIMINPUT;
19359 +    %end;
19361 +    data _out1;
19362 +        set _out1;
19363 +        where _name_ = "&target";
19364 +    run;
19365 +    %let target2 = &target._;
19366 +    proc transpose data=_out1 out=_out2 prefix=&target2;
19367 +            id _TSID_  ;
19368 +    run;
19369 +    /*
19370 +    proc print data=_out2(obs=11);
19371 +    run;
19372 +    */
19373 +    data _out2;
19374 +       length _index 8.;
19375 +       set _out2;
19376 +       _index=_N_;
19377 +       drop _NAME_ _LABEL_;
19378 +    run;
19381 +   data _out3;
19382 +       length _index 8.;
19383 +        set &inoutfor(where=(_TSID_=1 and &timeid > &_EndTime));
19384 +         _index =_N_;
19385 +        keep &timeid _index;
19387 +   run;
19388 +   /*
19389 +   proc print data=_out2(obs=12);
19390 +   proc print data =_out3(obs=13);
19391 +   run;
19392 +   */
19393 +   data &outdata(drop=_index);
19394 +        merge _out3 _out2;by _index;
19395 +        run;
19398 +  proc transpose data=&outdata out=_tout;
19399 +     id &timeid;
19400 +   run;
19401 +   data _tout;
19402 +        length _TSID_ 8.;
19403 +        set _tout;
19404 +        rename _NAME_= _NAMEID_;
19405 +        _TSID_ = _N_;
19406 +        label _NAME_ = "NAMEID";
19407 +        keep _NAME_ _TSID_;
19409 +   run;
19411 +   data &EM_USER_TSIDMAP;
19412 +        merge  _tout  &EM_USER_TSIDMAP; by _TSID_;
19413 +   run;
19414 +   /*
19415 +   proc print data=_tout(obs=14);
19416 +   run;
19417 +   */
19418 +   proc datasets lib=work nolist;
19419 +      delete  _out1 _tmpout1 _out2 _out3 _tout;
19420 +   run;
19423 +   %NO_TSID_SIMINPUT:
19424 +   %if  &_existtsid eq N %then %do;
19425 +   data &outdata;
19426 +        set &inoutfor(where=(&timeid > &_EndTime));
19427 +   run;
19428 +   %end;
19431 +%mend EM_TSESM_MakeOutSimInput;
19434 +%macro EM_TS_CONVERT_LONG_TO_WIDE(indata=, outdata=, wherevar=, nwherevalue=, targetvar=, timeid=);
19435 +%do i=1 %to &nwherevalue;
19436 +     %if &i = 1 %then %do;
19437 +        data &outdata(drop = &wherevar);
19438 +             set &indata;
19439 +               if &wherevar= &i;
19440 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
19441 +               %else %let newname = &wherevar_&i;
19442 +                rename  &targetvar= &newname;
19443 +                   label &targetvar ="&targetvar._&i";
19444 +           run;
19445 +       %end;
19446 +       %else %do;
19447 +        data _tmp_out(drop = &wherevar);
19448 +             set &indata;
19449 +               if &wherevar= &i;
19450 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
19451 +               %else %let newname = &wherevar_&i;
19452 +                rename  &targetvar= &newname;
19453 +                   label &targetvar ="&targetvar._&i";
19454 +           run;
19455 +             data &outdata;
19456 +                  merge &outdata  _tmp_out; by &timeid;
19457 +         run;
19458 +       %end;
19459 +%end;
19461 +%EM_TS_DELETE_DATA(lib=work, data=_tmp_out);
19463 +%mend EM_TS_CONVERT_LONG_TO_WIDE;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
19465 +/*
19466 +       MACRO: TS Utility macros
19468 +       PURPOSE: TS Utility macros
19469 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
19471 +       HISTORY:
19472 +       NOTE:
19474 +*/
19476 +/*
19477 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
19478 +                          timeid=, timeformat=, timeinformat=);
19479 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
19481 +    %do;
19482 +    %let m_data      = &data;
19483 +    %let m_decdata   = &decdata;
19484 +    %let m_decmeta   = &decmeta;
19485 +    %let m_cmeta     = &cmeta;
19486 +    %let m_outfile   = &outfile;
19487 +    %let m_crossid   = &crossid;
19488 +    %let m_timeid    = &timeid;
19489 +    %let m_timeformat    = &timeformat;
19490 +    %let m_timeinformat    = &timeinformat;
19491 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
19492 +  %end;
19493 +%mend EM_TS_CreateTsMetaDs;
19494 +*/
19495 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
19496 +proc sql;
19497 +      create table _tmp_inds
19498 +      as select distinct &timeid from  &indata;
19499 +quit;
19500 +run;
19501 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
19502 +  id &timeid
19503 +%if &timeinterval ne %then %do;
19504 +    %if &timeformattype eq DATE %then %do;
19505 +        interval=&timeinterval
19506 +    %end;
19507 +    %else %if &timeformattype eq DATETIME  %then %do;
19508 +        %let dttimeinterval= DT&timeinterval;
19509 +         interval=&dttimeinterval
19510 +    %end;
19511 +%end;
19512 +;
19513 +run;
19515 +data &outds;
19516 +     set _tmp_tsmeta;
19517 +     format START &timeformat;
19518 +     format END &timeformat;
19519 +     length APPLY_START_END $8;
19520 +     APPLY_START_END ="No";
19521 +     FORMAT = "&timeformat";
19522 +     ROLE ="TIMEID";
19523 +     rename TIMEID = NAME;
19524 +     rename SEASONALITY= LengthOfCycle;
19525 +     rename INTERVAL = TIMEINTERVAL ;
19526 +     rename FORMAT = TIMEFORMAT;
19527 +     output;
19528 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
19529 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
19530 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
19531 +run;
19533 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
19534 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
19536 +%mend EM_TS_CreateTSMetaData;
19540 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
19542 +/* if updated = Y it will pass the TSMETA created by just the previous node */
19544 +%let _tsmetads = ;
19546 +%if &updated = Y %then %do;
19547 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
19548 +%if %sysfunc(exist(&_tsmetads)) %then %do;
19549 +%goto endline;
19550 +%end;
19551 +%end;
19553 +%if &eminfodata eq %then %do;
19554 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19555 +    data &EM_DATA_EMINFO;
19556 +         set &EM_IMPORT_DATA_EMINFO;
19557 +    run;
19558 +%end;
19559 +%else %do;
19560 +    %let dsid=%sysfunc(open(&eminfodata));
19561 +    data &EM_DATA_EMINFO;
19562 +         set &eminfodata;
19563 +    run;
19564 +%end;
19565 +%if &dsid > 0 %then %do;
19566 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
19567 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
19568 +    %do %while(^ %sysfunc(fetch(&dsid)));
19569 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19570 +         %if &_key eq TSMETA %then %do;
19571 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
19572 +         %end;
19573 +    %end;
19574 +    %let dsid = %sysfunc(close(&dsid));
19575 +%end; /* the end of %if &dsid > 0 %then %do; */
19577 +%endline:
19579 +%if &_tsmetads ne %then %do;
19580 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
19581 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19582 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
19583 +         data &EM_USER_TSMETA;
19584 +                   set &_tsmetads;
19585 +         run;
19586 +    %end;
19587 +%end;
19589 +*proc print data=&EM_DATA_EMINFO;
19590 +*proc print data=&EM_IMPORT_DATA_EMINFO;
19591 +*run;
19592 +%MEND EM_TS_GETTSMETA;
19595 +/*
19596 +%macro EM_GETTSMETAVARS(TimeInterval=);
19597 +%global &TimeInterval;
19598 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19599 +%if &dsid > 0 %then %do;
19600 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19601 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
19602 +%do %while(^ %sysfunc(fetch(&dsid)));
19603 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19604 +     %if &_role eq TIMEID %then %do;
19605 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19606 +     %end;
19607 +%end;
19608 +%let dsid = %sysfunc(close(&dsid));
19609 +%end;
19610 +%MEND EM_GETTSMETAVARS;
19611 +*/
19612 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
19613 +%global &TimeInterval;
19614 +%global &TimeId;
19615 +%global &EndTime;
19616 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19617 +proc print data=&EM_USER_TSMETA;
19618 +run;
19619 +%if &dsid > 0 %then %do;
19620 +%if &TimeInterval ne %then %do;
19621 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19622 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19623 +    %do %while(^ %sysfunc(fetch(&dsid)));
19624 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19625 +        %if &_role eq TIMEID %then %do;
19626 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19627 +        %end;
19628 +     %end;
19629 +%end;
19630 +%if &TimeId ne %then %do;
19631 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
19632 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19633 +    %do %while(^ %sysfunc(fetch(&dsid)));
19634 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19635 +        %if &_role eq TIMEID %then %do;
19636 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
19637 +        %end;
19638 +    %end;
19639 +%end;
19641 +%if &EndTime ne %then %do;
19642 +    %let vn_end =%sysfunc(varnum(&dsid, END));
19643 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19644 +    %do %while(^ %sysfunc(fetch(&dsid)));
19645 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19646 +        %if &_role eq TIMEID %then %do;
19647 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19648 +        %end;
19649 +     %end;
19650 +%end;
19651 +%let dsid = %sysfunc(close(&dsid));
19652 +%end;
19653 +%MEND EM_TS_GETTSMETAVARS;
19657 +/*------------------------------------------------------------------
19659 +      Macro EM_GETTSIDMAP
19661 +------------------------------------------------------------------+*/
19664 +%macro EM_TS_GETTSIDMAP(updated=);
19666 +%let _tsidmap = ;
19668 +%if &updated = Y %then %do;
19669 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
19670 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19671 +%goto endline;
19672 +%end;
19673 +%end;
19675 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19676 +%if &dsid > 0 %then %do;
19677 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
19678 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
19679 +%do %while(^ %sysfunc(fetch(&dsid)));
19680 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19681 +     %if &_key eq TSIDMAP %then %do;
19682 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
19683 +     %end;
19684 +%end;
19686 +%let dsid = %sysfunc(close(&dsid));
19687 +%end;
19689 +%endline:
19691 +%if &_tsidmap ne %then %do;
19693 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
19694 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19696 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19697 +         data &EM_USER_TSIDMAP;
19698 +               set &_tsidmap;
19699 +         run;
19700 +    %end;
19701 +%end;
19702 +%MEND EM_TS_GETTSIDMAP;
19704 +/*------------------------------------------------------------------*/
19709 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
19710 +%global &value;
19713 +%let dsid = %sysfunc(open(&data));
19714 +%if &dsid > 0 %then %do;
19715 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
19716 +    %if &vn_var < 1 %then %do;
19717 +        %let &value = 0;
19718 +        %let dsid = %sysfunc(close(&dsid));
19719 +        %goto endline;
19720 +    %end;
19721 +%let dsid = %sysfunc(close(&dsid));
19722 +%end;
19724 +%let _tmp=_tmpDS;
19725 +proc means data=&data &stat;
19726 +     var &var;
19727 +     output out=&_tmp;
19728 +run;
19730 +%let dsid = %sysfunc(open(&_tmp));
19731 +%if &dsid > 0 %then %do;
19732 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
19733 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
19734 +     %do %while(^%sysfunc(fetch(&dsid)));
19735 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
19736 +         %if &_stat eq &stat %then %do;
19737 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
19738 +          %end;
19739 +      %end;
19740 +%let dsid = %sysfunc(close(&dsid));
19741 +%end;
19742 +proc datasets lib=work nolist;
19743 + delete &_tmp;
19744 +run;
19745 +%endline:
19746 +%MEND EM_TS_GET_STAT;
19749 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
19750 +%global &format;
19751 +%global &informat;
19752 +%let dsid = %sysfunc(open(&data));
19753 +%if &dsid > 0 %then %do;
19754 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19755 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
19756 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
19757 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
19758 +%end;
19759 +%let dsid = %sysfunc(close(&dsid));
19760 +%end;
19761 +%MEND EM_TS_GET_VAR_FORMAT;
19763 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
19764 +      %if &lib eq %then %let lib=work;
19765 +       proc datasets lib=&lib nolist;
19766 +              delete &dsname;
19767 +       run;
19768 +%Mend  EM_TS_DELETE_DATA;
19771 +%macro EM_TS_GetNObs(inds=, nobs=);
19772 +    %global &nobs;
19773 +    %let &nobs=0;
19774 +    data _null_;
19775 +        set &inds end=eof;
19776 +        if eof then call symput("&nobs", _N_);
19777 +    run;
19778 +    quit;
19780 +    /*
19781 +    %let dsid=%sysfunc(open(&outdata));
19782 +    %if dsid > 0 %then %do;
19783 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
19784 +        %let dsid = %sysfunc(close(&dsid));
19785 +     %end;
19786 +    */
19787 +%mend  EM_TS_GetNObs;
19790 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
19791 +%global &time1;
19792 +%global &time2;
19793 +%if &default = Y %then %do;
19794 +   data _null_;
19795 +        set &data end=eof;
19796 +        if _N_ = 1 then  call symput("&time1", DATE);
19797 +        if eof then call symput("&time2", DATE);
19798 +    run;%end;
19799 +%else %do;
19800 +    %let dsid = %sysfunc(open(&data));
19801 +    %if &dsid > 0 %then %do;
19802 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
19803 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
19804 +        %do %while(^%sysfunc(fetch(&dsid)));
19805 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
19806 +             %if &_index eq 1 %then %do;
19807 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
19808 +             %end;
19809 +             %if &_index eq 2 %then %do;
19810 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
19811 +             %end;
19812 +        %end;
19813 +    %let dsid = %sysfunc(close(&dsid));
19814 +    %end;
19815 +%end;
19817 +%MEND EM_TS_GET_TIME_VALUES;
19819 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
19820 +%global &exist;
19821 + %let &exist = N;
19822 +%let dsid = %sysfunc(open(&data));
19823 +%if &dsid > 0 %then %do;
19824 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19825 +%if &vn_var > 0 %then %do;
19826 +    %let &exist = Y;
19827 +%end;
19828 +%let dsid = %sysfunc(close(&dsid));
19829 +%end;
19830 +%MEND EM_TS_GET_VAR_EXIST;
19833 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
19834 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
19835 +      set &intreedata;
19836 +        LENGTH NodeType $32;
19837 +      if _PARENT_ eq " " then delete;
19838 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
19839 +        else NodeType = "CLUSTER";
19840 +        LinkID = _N_;
19841 +run;
19842 +%Mend EM_TS_MakeConstellPlotData;
19847 +%macro EM_TS_CreateIDMap(
19848 +/*-------------------------------------------------------------------------*/
19849 +/*---   Written by Xiangxiang Meng                                         */
19850 +/*-------------------------------------------------------------------------*/
19851 +inDS          =,      /* imported data set in TS data mining               */
19852 +outIDMap      =,      /* output data set of TS ID map                      */
19853 +outDS         =,      /* output data set of TS and TS ID merged            */
19854 +variableSet   =,      /* EM variable set                                   */
19855 +TSIDbyCrossID =Y,
19856 +inEM          =Y
19857 +/*-------------------------------------------------------------------------*/
19858 +);
19860 +%global EM_TS_ERR;
19861 +%let EM_TS_ERR = 0;
19863 +%if &inEM eq Y %then %do;
19864 +    %let num_crossIDVar = &EM_NUM_CROSSID;
19865 +    proc sql noprint;
19866 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
19867 +    quit;
19868 +%end;
19869 +%else %do;
19870 +    proc sql noprint;
19871 +         select count(*) into :num_crossIDVar from &variableSet
19872 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19873 +         ;
19874 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
19875 +         ;
19876 +    quit;
19877 +    %let num_crossIDVar=&num_crossIDVar;
19878 +%end;
19880 +* see if _TSID_ exists;
19882 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
19883 +run;
19885 +proc sql noprint;
19886 +    select count(*) into :has_TSID
19887 +        from _emtscm_contents
19888 +        where upcase(strip(name)) eq '_TSID_'
19889 +    ;
19890 +quit;
19892 +/*-------------------------------------------------------------------------*/
19893 +* Creating TSID map..;
19894 +/*-------------------------------------------------------------------------*/
19896 +%if (&num_crossIDVar gt 0) %then %do;
19898 +    data _emtscm_tmpIDMap;
19899 +        set &variableSet;
19900 +        where  (upcase(strip(level)) eq 'INTERVAL')
19901 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
19902 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
19903 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
19904 +          );
19905 +        _emts_dummy=1;
19906 +        keep name label role _emts_dummy;
19907 +    run;
19909 +    proc sql noprint;
19910 +        * create a string of crossID variable like A,B,C,D..;
19911 +        select distinct name into :crossIDVar separated by ','
19912 +            from &variableSet
19913 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19914 +            order by name
19915 +        ;
19916 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
19917 +            from &variableSet
19918 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19919 +            order by name
19920 +        ;
19921 +        * create the TSID map data set;
19922 +        create table _emtscm_tmp1 as
19923 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
19924 +        ;
19925 +        * create a level list of cross ID variables and time series variables;
19926 +        create table &outIDMap as
19927 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
19928 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
19929 +            where a._emts_dummy eq b._emts_dummy
19930 +            order by a.name, &crossIDVar
19931 +        ;
19932 +    quit;
19934 +    %if &TSIDbyCrossID = Y %then %do;
19935 +        * create unique TSID only by Cross ID;
19936 +        data &outIDMap;
19937 +            length _TSID_ 8;
19938 +            set &outIDMap;
19939 +            by _NAMEID_;
19940 +            if first._NAMEID_
19941 +                then _TSID_=1;
19942 +                else _TSID_+1;
19943 +        run;
19944 +        %if "&outDS" ne "" %then %do;
19945 +            * merge TSID into &inDS;
19946 +            proc sql noprint;
19947 +                create table &outDS as
19948 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
19949 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
19950 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
19951 +                        where %do i = 1 %to &num_crossIDVar;
19952 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
19953 +                              %end;
19954 +                             b._TSID_ is not missing
19955 +                    order by b._TSID_, a.&timeIDVar
19956 +                ;
19957 +            quit;
19958 +        %end;
19959 +    %end;
19960 +    %else %do;
19961 +        * create unique TSID by Cross ID and _NAMEID_;
19962 +        data &outIDMap;
19963 +            length _TSID_ 8;
19964 +            set &outIDMap;
19965 +            _TSID_=_n_;
19966 +        run;
19967 +        %if "&outDS" ne "" %then %do;
19968 +            *no merge in this output;
19969 +            data &outDS;
19970 +                set &inDS;
19971 +            run;
19972 +        %end;
19973 +    %end;
19975 +    proc sort data=&outIDMap;
19976 +        by _NAMEID_ _TSID_;
19977 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
19978 +        format _TSID_ best12. _NAMEID2_ $40.;
19979 +        set &outIDMap;
19980 +        by _NAMEID_;
19981 +        if first._NAMEID_
19982 +            then _emts_ind=1;
19983 +            else _emts_ind+1;
19984 +        drop _emts_ind;
19985 +        rename _NAMEID_=_VARNAME_;
19986 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
19987 +        if _labelID_ eq ' '
19988 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
19989 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
19990 +    run;
19992 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
19994 +%end;
19995 +%else %do; /* if no crossid's the nameid needs to be created */
19997 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
19998 +        length _TSID_ 8;
19999 +        set &variableSet;
20000 +        where  (upcase(strip(level)) eq 'INTERVAL')
20001 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
20002 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
20003 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
20004 +          );
20005 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
20006 +        rename ROLE = _ROLE_;
20007 +        _NAMEID_=strip(name);
20008 +        _VARNAME_=strip(name);
20009 +        if label eq ' '
20010 +            then _LABELID_ = strip(name);
20011 +            else _LABELID_ = strip(label);
20012 +        _TSID_=_n_;
20013 +    run;
20015 +    %if "&outDS" ne "" %then %do;
20016 +        *no merge in this output;
20017 +        data &outDS;
20018 +            set &inDS;
20019 +        run;
20020 +    %end;
20021 +%end;
20023 +data &outIDMap;
20024 +    set &outIDMap;
20025 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
20026 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
20027 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
20028 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
20029 +run;
20031 +proc datasets lib=work nolist;
20032 +    delete _emtscm_:;
20033 +run; quit;
20035 +%mend EM_TS_createIDMap;
20037 +%macro EM_TS_CreateMetaData(
20038 +/*-------------------------------------------------------------------------*/
20039 +  inDS          =,      /* imported data set in TS data mining             */
20040 +  outDS         =,      /* output data set of TS metadata                  */
20041 +  variableSet   =,      /* EM variable set                                 */
20042 +  timeInterval  =,      /* time interval                                   */
20043 +  rc            =       /* return code                                     */
20044 +/*-------------------------------------------------------------------------*/
20045 +);
20047 +%if %eval(
20048 +      &EM_NUM_BINARY_INPUT   +
20049 +      &EM_NUM_ORDINAL_INPUT  +
20050 +      &EM_NUM_NOMINAL_INPUT  +
20051 +      &EM_NUM_BINARY_REJECTED   +
20052 +      &EM_NUM_ORDINAL_REJECTED  +
20053 +      &EM_NUM_NOMINAL_REJECTED  +
20054 +      &EM_NUM_ORDINAL_TARGET  +
20055 +      &EM_NUM_NOMINAL_TARGET +
20056 +      &EM_NUM_BINARY_TARGET
20057 +      ) > 0
20058 +%then %do;
20059 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
20060 +        %put &em_codebar;
20061 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
20062 +        %put &errormsg;
20063 +        %put &em_codebar;
20064 +        %goto ENDLINE;
20065 +%end;
20067 +%global EM_TS_ERR;
20068 +%let EM_TS_ERR = 0;
20070 +%if &timeInterval eq AUTO
20071 +    %then %let timeInterval  = ;
20072 +    %else %let timeInterval  = %upcase(&timeInterval);
20074 +/*-------------------------------------------------------------------------*/
20075 +* check time ID variable;
20076 +/*-------------------------------------------------------------------------*/
20078 +* number of variables in the Variableset with ROLE=TIMEID;
20079 +proc sql noprint;
20080 +    select count(*) into :num_timeID from &variableset
20081 +        where upcase(role) eq 'TIMEID';
20082 +quit;
20084 +/*-------------------------------------------------------------------------*/
20085 +* process only when there is one Time ID, otherwise exception message;
20086 +/*-------------------------------------------------------------------------*/
20088 +%if &num_timeID eq 0 %then %do;
20090 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
20091 +    %let EM_TS_ERR = 11;
20092 +    %put &em_codebar;
20093 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
20094 +    %put &errormsg;
20095 +    %put &em_codebar;
20096 +    %goto tscm_endline;
20098 +%end;
20099 +%else %if &num_timeID gt 1 %then %do;
20101 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
20102 +    %let EM_TS_ERR = 12;
20103 +    %put &em_codebar;
20104 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
20105 +    %put &errormsg;
20106 +    %put &em_codebar;
20107 +    %goto tscm_endline;
20109 +%end;
20110 +%else %do;
20111 +    *** proceed when there is one Time ID;
20113 +    data _null_;
20114 +        set &variableset(where=(upcase(role)='TIMEID'));
20115 +        call symput('timeIDFormat',     strip(format));
20116 +        call symput('timeID',           strip(upcase(name)      ));
20117 +        call symput('timeIDLevel',      strip(upcase(level))     );
20118 +        call symput('timeIDFormatType', strip(upcase(formattype)));
20119 +    run;
20121 +    *** exception message if the time ID is not an interval variable;
20122 +    %if &timeIDLevel ne INTERVAL %then %do;
20123 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
20124 +        %let EM_TS_ERR = 13;
20125 +        %put &em_codebar;
20126 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
20127 +        %put &errormsg;
20128 +        %put &em_codebar;
20129 +        %goto tscm_endline;
20130 +    %end;
20132 +    %if (&timeIDFormatType ne DATETIME) and
20133 +        (&timeIDFormatType ne DATE) and
20134 +        (&timeIDFormatType ne TIME) and
20135 +        (&timeIDFormatType ne USER)
20136 +    %then %do;
20137 +        *** sequential format-type of time ID;
20139 +        %let timeInterval = DAY;
20140 +        %let timeIDFormatType = SEQ;
20142 +        proc sql noprint;
20143 +            create table _emtscm_inds as
20144 +                 select distinct &timeID from &inDS(keep=&timeID)
20145 +                 where &timeID is not missing;
20146 +            select count(*) into :num_nonInteger from _emtscm_inds
20147 +                where &timeID ne int(&timeID);
20148 +        quit;
20150 +        %if &num_nonInteger gt 0 %then %do;
20151 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
20152 +            %let EM_TS_ERR = 14;
20153 +            %put &em_codebar;
20154 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
20155 +            %put &errormsg;
20156 +            %put &em_codebar;
20157 +            %goto tscm_endline;
20158 +        %end;
20159 +    %end;
20160 +    %else %do;
20161 +        *** date, datetime, time format-type of time ID;
20163 +        *** must have a format;
20164 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
20165 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
20166 +            %let EM_TS_ERR = 15;
20167 +            %put &em_codebar;
20168 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
20169 +            %put &errormsg;
20170 +            %put &em_codebar;
20171 +            %goto tscm_endline;
20172 +        %end;
20174 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
20175 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
20176 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
20177 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
20178 +                %let EM_TS_ERR = 16;
20179 +                %put &em_codebar;
20180 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
20181 +                %put &errormsg;
20182 +                %put &em_codebar;
20183 +                %goto tscm_endline;
20184 +            %end;
20185 +        %end;
20187 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
20188 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
20189 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
20190 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
20191 +                %let EM_TS_ERR = 17;
20192 +                %put &em_codebar;
20193 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
20194 +                %put &errormsg;
20195 +                %put &em_codebar;
20196 +                %goto tscm_endline;
20197 +            %end;
20198 +        %end;
20200 +        *** the AUTO function is currently turned off for TIME timeID variable;
20201 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
20202 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
20203 +            %let EM_TS_ERR = 18;
20204 +            %put &em_codebar;
20205 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
20206 +            %put &errormsg;
20207 +            %put &em_codebar;
20208 +            %goto tscm_endline;
20209 +        %end;
20211 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
20212 +            %then %let timeInterval =DT&timeInterval;
20214 +        proc sql noprint;
20215 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
20216 +                where &timeID is not missing;
20217 +        quit;
20218 +    %end;
20220 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
20221 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
20222 +    run;
20224 +    %let hasValidInterval = 0;
20225 +    %let hasLengthOne     = 0;
20227 +    proc sql noprint;
20228 +        create table _emtscm_label as
20229 +            select name,label
20230 +            from dictionary.columns
20231 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
20232 +        ;
20233 +        create table _emtscm_meta2 as
20234 +            select a.*, b.label
20235 +            from _emtscm_meta as a, _emtscm_label as b
20236 +            where upcase(a.timeID) eq upcase(b.name)
20237 +        ;
20238 +    quit;
20240 +    data &outDS;
20241 +        set _emtscm_meta2;
20242 +        format
20243 +            timeformat      $30.
20244 +            role            $10.
20245 +            start           &timeIDformat
20246 +            end             &timeIDformat
20247 +            apply_start_end $8.
20248 +        ;
20249 +        rename
20250 +            timeID      = name
20251 +            seasonality = lengthOfCycle
20252 +            interval    = timeinterval
20253 +        ;
20254 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
20256 +        role            = "TIMEID";
20257 +        apply_start_end = 'N';
20258 +        timeformat      = symget('timeIDformat');
20259 +        timeformattype  = symget('timeIDformatType');
20261 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
20262 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
20263 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
20264 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
20265 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
20266 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
20267 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
20268 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
20269 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
20270 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
20272 +        if timeformattype eq 'SEQ' then do;
20273 +            timeformat='BEST12.';
20274 +            seasonality=1;
20275 +        end;
20277 +        call symput('_tinterval',interval);
20279 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
20281 +        if upcase(timeformattype) eq 'DATE' and
20282 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
20283 +            then call symput('hasValidInterval',1);
20285 +        if upcase(timeformattype) eq 'DATETIME' and
20286 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
20287 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
20288 +            then call symput('hasValidInterval',1);
20290 +        if upcase(timeformattype) eq 'TIME' and
20291 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
20292 +            then call symput('hasValidInterval',1);
20294 +        if upcase(timeformattype) eq 'SEQ'
20295 +            then call symput('hasValidInterval',1);
20297 +        if upcase(timeformattype) eq 'USER'
20298 +            then call symput('hasValidInterval',1);
20300 +        if start eq end
20301 +            then call symput('hasLengthOne',1);
20302 +    run;
20304 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
20306 +    *** detect any missing time interval after running PROC TIMEID;
20307 +    %if &_tinterval eq %then %do;
20308 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
20309 +        %let EM_TS_ERR = 19;
20310 +        %put &em_codebar;
20311 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
20312 +        %put &errormsg;
20313 +        %put &em_codebar;
20314 +        %goto tscm_endline;
20315 +    %end;
20317 +    *** detect any missing time interval after running PROC TIMEID;
20318 +    %if &hasValidInterval eq 0 %then %do;
20319 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
20320 +        %let EM_TS_ERR = 20;
20321 +        %put &em_codebar;
20322 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
20323 +        %put &errormsg;
20324 +        %put &em_codebar;
20325 +        %goto tscm_endline;
20326 +    %end;
20328 +    %if &hasLengthOne eq 1 %then %do;
20329 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
20330 +        %let EM_TS_ERR = 21;
20331 +        %put &em_codebar;
20332 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
20333 +        %put &errormsg;
20334 +        %put &em_codebar;
20335 +        %goto tscm_endline;
20336 +    %end;
20338 +%end;
20340 +%tscm_endline:;
20342 +%mend EM_TS_CreateMetaData;
20345 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
20347 +data _null_;
20348 +    set &tsmeta;
20349 +    call symput('_timeidFormatType', timeformattype);
20350 +    call symput('_timeid', strip(name));
20351 +    call symput('_seqstartnum',strip(put(start,best12.)));
20352 +run;
20354 +proc contents data=&inDS noprint
20355 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20356 +run; quit;
20358 +data _null_;
20359 +    set _emts_tmpp1;
20360 +    call symput('_timeIDlabel',label);
20361 +run;
20363 +%if &_timeidFormatType eq SEQ
20364 +%then %do;
20365 +    proc sql noprint;
20366 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
20367 +    quit;
20368 +    %let _dummystarttime=&_dummystarttime;
20370 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20371 +        set &inDS;
20372 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
20373 +        drop &_timeid;
20374 +        label _tsdp_tmpID = "&_timeIDlabel";
20376 +    run;
20377 +%end;
20379 +%mend;
20381 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
20383 +data _null_;
20384 +    set &tsmeta;
20385 +    call symput('_timeidFormatType', timeformattype);
20386 +    call symput('_timeidFormat', timeformat);
20387 +    call symput('_timeid', strip(name));
20388 +    call symput('_timeinterval',strip(upcase(timeinterval)));
20389 +run;
20391 +/* manually change time ID format to a longer enough time format */
20392 +/* because proc timeid returns time5. for second time interval */
20393 +/* which is not long enough for transpose with time unit as seconds */
20394 +%if &_timeinterval eq SECOND
20395 +%then %do;
20396 +    %let _timeIDformat = %str(time8.);
20397 +%end;
20399 +proc contents data=&inDS noprint
20400 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20401 +run; quit;
20403 +data _null_;
20404 +    set _emts_tmpp1;
20405 +    call symput('_timeIDlabel',label);
20406 +run;
20408 +%if &_timeidFormatType eq TIME
20409 +%then %do;
20410 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20411 +        set &inDS;
20412 +        _tsdp_tmpID = timepart(&_timeID);
20413 +        format _tsdp_tmpID &_timeidFormat;
20414 +        label  _tsdp_tmpID = "&_timeIDlabel";
20415 +        drop &_timeid;
20416 +    run;
20417 +%end;
20419 +%mend;
20421 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
20423 + proc sql noprint;
20424 +     create table _tmptimetable as
20425 +         select distinct &timeidvar as DATE from &inDS
20426 +         where &timeIDVar is not missing
20427 +         order by &timeIDVar;
20428 + quit;
20430 +%if &compare eq Y %then %do;
20431 +    * compare with the existing time table;
20432 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
20433 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
20434 +    run;
20436 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
20438 +    %if &_diffobs > 0 %then %do; /* create it again */
20439 +        data &outDS(keep=DATE _INDEX_);
20440 +            set _tmptimetable end = _eof_;
20441 +            if _N_ = 1
20442 +                then _INDEX_ = 1;
20443 +                else _INDEX_ = 0;
20444 +            if _eof_ then _INDEX_= 2;
20445 +        run;
20446 +    %end;
20448 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
20449 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20450 +%end;
20451 +%else %do;
20452 +    * create a new time table directly;
20453 +    data &outDS(keep=DATE _INDEX_);
20454 +        set _tmptimetable end = _eof_;
20455 +        if _N_ = 1
20456 +            then _INDEX_ = 1;
20457 +            else _INDEX_ = 0;
20458 +        if _eof_ then _INDEX_= 2;
20459 +    run;
20461 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20462 +%end;
20464 +* assign a defult format BEST12. for sequential time ID;
20466 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
20468 +%let _nodatefmt=N;
20470 +data _null_;
20471 +    set _tmpcontents;
20472 +    where upcase(name) eq 'DATE';
20473 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
20474 +run;
20476 +%if "&_nodatefmt" eq "Y" %then %do;
20477 +    data &outDS;
20478 +        set &outDS;
20479 +        format date best12.;
20480 +    run;
20481 +%end;
20483 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
20485 +%mend;
20489 +%macro EM_TS_Transpose(
20490 +/*-------------------------------------------------------------------------*/
20491 +  inDS          =,      /* imported data set in TS data mining             */
20492 +  inIDMap       =,      /* input TS ID map                                 */
20493 +  variableSet   =,      /* variable set                                    */
20494 +  transposeBy   =,      /* byTSID or byTimeID                              */
20495 +  outDS         =,      /* output transposed data set                      */
20496 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
20497 +  inEM          =Y,
20498 +  timePrefix    =_T
20499 +/*-------------------------------------------------------------------------*/
20500 +);
20502 +%let timePrefix = &timePrefix;
20504 +%if  &EM_NUM_CROSSID > 0 %then %do;
20506 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
20507 +    set &inIDMap;
20508 +    drop _NAMEID_;
20509 +    run;
20510 +%let inIDMap=_emtstp_map0;
20512 +%end;
20514 +proc sql noprint;
20515 +    * number of TS Variables to be transposed;
20516 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
20517 +    ;
20518 +    * number of TS Variables to be transposed;
20519 +    select max(_TSID_) into :num_TSID from &inIDMap
20520 +    ;
20521 +    * name list of TS Variables;
20522 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
20523 +        from &inIDMap
20524 +        order by _NAMEID_
20525 +    ;
20526 +    * total number of time series =max(_TSID_)*&num_TSVar;
20527 +    * and the number of digits of this variable is &num_digits;
20528 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
20529 +        from &inIDMap
20530 +    ;
20531 +      * Time ID variable;
20532 +    select name into:timeIDVar from &variableset
20533 +        where upcase(role) eq 'TIMEID'
20534 +    ;
20535 +quit;
20536 +%let num_digits = &num_digits;
20537 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
20539 +/*-------------------------------------------------------------------------*/
20541 +* get number of cross IDs and also the TIME ID variable name;
20542 +%if &inEM eq Y %then %do;
20543 +    %let num_crossIDVar = &EM_NUM_CROSSID;
20544 +    %let crossIDVar     = %EM_CROSSID;
20545 +%end;
20546 +%else %do;
20547 +    proc sql noprint;
20548 +        * number of cross ID;
20549 +        select count(*) into :num_crossIDVar
20550 +            from &variableSet
20551 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20552 +        ;
20553 +        * create a string of crossID variable like A B C D..;
20554 +        select distinct name into :crossIDVar separated by ' '
20555 +            from &variableSet
20556 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20557 +            order by name
20558 +        ;
20559 +    quit;
20560 +    %let num_crossIDVar=&num_crossIDVar;
20561 +%end;
20563 +/*-------------------------------------------------------------------------*/
20565 +%if (&num_crossIDVar gt 0) %then %do;
20567 +    data _emtstp_tmpDat;
20568 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
20569 +        _NAMEID_ = cats("_TS_",_TSID_);
20570 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
20571 +    run;
20573 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20575 +        * update the ID maps;
20576 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20577 +            by _NAMEID_ _TSID_;
20578 +        data &outIDMap;
20579 +            set _emtstp_tmpmap;
20580 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20581 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20582 +        run;
20584 +        * get the names for the new variables;
20585 +        proc sql noprint;
20586 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
20587 +            ;
20588 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
20589 +            ;
20590 +        quit;
20592 +        * data must be sorted before transposed;
20593 +        proc sort data=_emtstp_tmpDat;
20594 +            by &timeIDvar;
20595 +        run;
20597 +        %do i = 1 %to &num_TSVar;
20598 +            %let i = &i;
20599 +            * transpose one cross-type time series data by TSID;
20600 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
20601 +                id _NAMEID_;
20602 +                by &timeIDVar;
20603 +                var &&&TSVar&i;
20604 +            run;
20605 +        %end;
20607 +        * merge all vertical time series, rename and label them;
20608 +        data &outDS;
20609 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
20610 +            by &timeIDVar;
20611 +            rename
20612 +                %do i = 1 %to &num_TSVar;
20613 +                    %do j = 1 %to &num_TSID;
20614 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20615 +                        /* %put &i &j &num1 &num_TSID; */
20616 +                        _V_&i._TS_&j = &&&tsname&num1
20617 +                    %end;
20618 +                %end;
20619 +            ;
20620 +            label
20621 +                %do i = 1 %to &num_TSVar;
20622 +                    %do j = 1 %to &num_TSID;
20623 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20624 +                        /* %put &i &j &num1 &num_TSID; */
20625 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
20626 +                    %end;
20627 +                %end;
20628 +            ;
20629 +        run;
20630 +    %end;
20631 +    %else %do;
20633 +        * update the ID maps;
20634 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20635 +            by _NAMEID_ _TSID_;
20636 +        data &outIDMap;
20637 +            set _emtstp_tmpmap;
20638 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20639 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20640 +        run;
20642 +        proc sql noprint;
20643 +            * get the roles for the new variables;
20644 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
20645 +                from &inIDMap
20646 +                order by _NAMEID_
20647 +            ;
20648 +            * get the length of the time series;
20649 +            select count(distinct &timeIDvar) into :num_T
20650 +                from _emtstp_tmpDat
20651 +            ;
20652 +        quit;
20654 +        * data must be sorted before transposed;
20655 +        proc sort data=_emtstp_tmpDat;
20656 +            by _TSID_ &crossIDVar &timeIDvar;
20657 +        run;
20659 +        %do i = 1 %to &num_TSVar;
20660 +            %let i = &i;
20661 +            * transpose one cross-type time series data by TIMEID;
20662 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
20663 +                by _TSID_ &crossIDVar;
20664 +                var &&&TSVar&i;
20665 +            run;
20666 +        %end;
20668 +        * stack all horizontal time series;
20669 +        data &outDS;
20670 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
20671 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
20672 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
20673 +            %do i=1 %to &num_TSVar;
20674 +                if in&i then do;
20675 +                    _NAMEID_ ="&&&TSVar&i";
20676 +                    _ROLE_   ="&&&TSRole&i";
20677 +                end;
20678 +            %end;
20679 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
20680 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
20681 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
20682 +        run;
20683 +    %end;
20684 +%end;
20685 +%else %do;
20687 +    proc sql noprint;
20688 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
20689 +            order by _NAMEID_
20690 +        ;
20691 +    quit;
20693 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20694 +        * transpose the panel-type time series data by TSID;
20695 +        proc sort data=&inDS out=_emtstp_tmpDat;
20696 +            by &timeIDvar;
20697 +        proc transpose data=_emtstp_tmpDat
20698 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
20699 +            by &timeIDVar;
20700 +            var &panelTSVar;
20701 +        run;
20702 +        proc datasets lib=work nolist;
20703 +            modify _emtstp_tmpDat2;
20704 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
20705 +            run; quit;
20706 +    %end;
20707 +    %else %do;
20708 +        * transpose the panel-type time series data by TIMEID;
20709 +        proc sort data=&inDS out=_emtstp_tmpDat;
20710 +            by &timeIDvar;
20711 +        data _emtstp_tmpDat;
20712 +            set _emtstp_tmpDat;
20713 +            _tmp_ind=_n_;
20714 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
20715 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
20716 +            ID _tmp_ind;
20717 +            var &panelTSVar;
20718 +        run;
20719 +    %end;
20721 +      * merge ID maps to the transpose data set;
20722 +      proc sql noprint;
20723 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
20724 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
20725 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
20726 +          ;
20727 +      quit;
20729 +      * update the TS ID map;
20730 +      data &outIDMap;
20731 +          set &inIDMap;
20732 +      run;
20733 +%end;
20735 +proc datasets lib=work nolist;
20736 +    delete _emtstp:;
20737 +run; quit;
20739 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_SCORE.SOURCE.
20741 +/*----------------------------------------------------------------------------------+
20742 + |
20743 + |   Title :  TS ESM Node
20744 + |
20745 + |   SUPPORT: Taiyeong Lee (Taiyeong.Lee@sas.com)
20746 + |
20747 + +-----------------------------------------------------------------------------------*/
20749 +%macro EM_TSESM_SCORE;
20751 +    /* the case when Targets and Inputs have the same format, apply the format to the output statistics*/
20752 +    /* defect S1014292 */
20753 +    %global  _seriesFormat;
20754 +    %let _seriesFormat =;
20755 +    proc sql noprint;
20756 +        select count(distinct format) into :_numSeriesFormat
20757 +        from &EM_DATA_VARIABLESET
20758 +        where upcase(role) eq 'TARGET' or upcase(role) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D');
20759 +    quit;
20760 +    %if &_numSeriesFormat = 1 %then %do;
20761 +        proc sql noprint;
20762 +            select distinct format into :_seriesFormat
20763 +            from &EM_DATA_VARIABLESET
20764 +            where upcase(role) eq 'TARGET' or upcase(role) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D');
20765 +        quit;
20766 +    %end;
20768 +   /* When Forecast Input Time Series is Yes, Output Data Type is always Default */
20769 +   %let _EXPORTDATA = &EM_PROPERTY_EXPORTDATA;
20770 +   %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
20771 +      %let _EXPORTDATA = DEFAULT  ;
20772 +   %end;
20775 +    %EM_GETNAME(KEY=OUTFORCST, TYPE=DATA);
20776 +    %EM_GETNAME(KEY=FORCSTPLOTDS, TYPE=DATA);
20779 +%if &EM_PROPERTY_PLOTLENGTH ne MAX %then %do;
20782 +    %if &EM_PROPERTY_PLOTLENGTH eq DEFAULT %then %do;
20783 +        %let _nobs = 0;
20784 +        %let dsid=%sysfunc(open(&EM_USER_OUTFORCST));
20785 +        %if dsid > 0 %then %do;
20786 +            %let _nobs = %sysfunc(attrn(&dsid, NOBS));
20787 +            %let dsid = %sysfunc(close(&dsid));
20788 +        %end;
20790 +        %if &_nobs > 20000 %then %let _PLOTLENGTH = 3;
20791 +        %else %let _PLOTLENGTH = MAX;
20793 +    %end;
20794 +    %else %do;
20795 +        %let _PLOTLENGTH = &EM_PROPERTY_PLOTLENGTH;
20796 +    %end;
20798 +    %if &_PLOTLENGTH ne MAX %then %do;
20799 +         %let _timeidvar =%EM_TIMEID;
20800 +         data _tmptimeds;
20801 +            set   &EM_USER_OUTFORCST ;
20802 +            keep=&_timeidvar;
20803 +         run;
20804 +         proc sql;
20805 +              create table _tmptimeds2
20806 +              as
20807 +             select distinct(_tmptimeds.&_timeidvar) from _tmptimeds;
20808 +         run;
20809 +         quit;
20811 +         proc sort data=_tmptimeds2   out= _tmptimeds2  ;
20812 +              by descending &_timeidvar;
20813 +         run;
20814 +         %let _nplot =%sysevalf(&EM_PROPERTY_FCLEAD * (1+ &_PLOTLENGTH));
20816 +         %let _ntimeid = 0;
20817 +         %let dsid=%sysfunc(open(work._tmptimeds2));
20818 +         %if dsid > 0 %then %do;
20819 +             %let _ntimeid = %sysfunc(attrn(&dsid, NOBS));
20820 +             %let dsid = %sysfunc(close(&dsid));
20821 +         %end;
20822 +         %if &_ntimeid > &_nplot %then %do;
20823 +             data _null_;
20824 +                 set _tmptimeds2;
20825 +                 if _N_ eq &_nplot then do;
20826 +                 call symput("_start", &_timeidvar);
20827 +                 end;
20828 +             run;
20830 +             data &EM_USER_FORCSTPLOTDS;
20831 +               set  &EM_USER_OUTFORCST;
20832 +               if &_timeidvar >= &_start then output;
20833 +             run;
20834 +         %end;
20835 +         %else %do;
20836 +               data &EM_USER_FORCSTPLOTDS;
20837 +                    set  &EM_USER_OUTFORCST;
20838 +               run;
20839 +         %end;
20840 +    %end; /* end of %if &_PLOTLENGTH ne MAX %then %do; */
20841 +    %else %do;
20842 +         data &EM_USER_FORCSTPLOTDS;
20843 +              set  &EM_USER_OUTFORCST;
20844 +         run;
20845 +    %end;
20847 +%end; /* end of ne MAX */
20848 +%else %do;
20849 +    data &EM_USER_FORCSTPLOTDS;
20850 +         set  &EM_USER_OUTFORCST;
20851 +    run;
20852 +%end;  /* end of eq Max  */
20854 +/* Apply series format */
20855 +    /* defect S1014292 */
20856 +%if &_seriesFormat ^= %then %do;
20858 +    data &EM_USER_FORCSTPLOTDS;
20859 +         set  &EM_USER_FORCSTPLOTDS;
20860 +         format ACTUAL &_seriesFormat;
20861 +         format PREDICT &_seriesFormat;
20862 +         format LOWER &_seriesFormat;
20863 +         format UPPER &_seriesFormat;
20864 +         format ERROR &_seriesFormat;
20865 +         format STD &_seriesFormat;
20866 +    run;
20869 +%end;
20871 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptimeds);
20872 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptimeds2);
20876 +/* moved from training macro by ruzhan */
20878 +   %EM_GETNAME(KEY=OUTPRED, TYPE=DATA);
20879 +   %EM_GETNAME(KEY=OUTSUM, TYPE=DATA);
20880 +   %EM_GETNAME(KEY=OUTDATA, TYPE=DATA);
20881 +   %EM_GETNAME(KEY=OUTLIER, TYPE=DATA);
20882 +   %EM_GETNAME(KEY=OUTKLD, TYPE=DATA);
20883 +   %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
20885 +/* Apply series format */
20886 +    /* defect S1014292 */
20887 +%if &_seriesFormat ^= %then %do;
20889 +    data &EM_USER_OUTSUM;
20890 +        set  &EM_USER_OUTSUM;
20891 +        format MIN &_seriesFormat;
20892 +        format MAX &_seriesFormat;
20893 +        format MEAN &_seriesFormat;
20894 +        format STDDEV &_seriesFormat;
20895 +        format PREDICT &_seriesFormat;
20896 +        format LOWER &_seriesFormat;
20897 +        format UPPER &_seriesFormat;
20898 +        format STD &_seriesFormat;
20899 +        %let _lead_num_ = 1;
20900 +        %do %while (&_lead_num_ <= &em_property_FCLead);
20901 +            %let _FCLead_ = _LEAD&_lead_num_._;
20902 +            format &_FCLead_ &_seriesFormat;
20903 +            %let _lead_num_ = %eval(&_lead_num_ +1);
20904 +        %end;
20906 +    run;
20909 +%end;
20912 +   /*---------- Check and assign the input data set --------------------------*/
20915 +    %let _EXPORT_DATA  = ;
20916 +    %let _FILE_CDELTA  = ;
20918 +    %if &EM_IMPORT_DATA ne  %then %do;
20920 +           %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
20921 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
20923 +    %end;
20924 +    %else %if &EM_IMPORT_TRANSACTION ne  %then %do;
20926 +           %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
20927 +           %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRANSACTION;
20928 +    %end;
20929 +    %else %do;
20930 +           %let  EMEXCEPTIONSTRING = exception.server.tsdm.noinputdata;
20931 +           %goto ENDLINE;
20932 +    %end;
20936 +   %if &_EXPORTDATA eq KLD %then %do;
20937 +       %if  &EM_PROPERTY_CLUSLEADPOINT > %eval(&EM_PROPERTY_FCLEAD-&EM_PROPERTY_FCBACK) %then %do;
20938 +           %put &em_codebar;
20939 +           %let errormsg = %sysfunc(sasmsg(sashelp.dmine, tsdm.invalidleadpointforkld_err, NOQUOTE));
20940 +           %put &errormsg;
20941 +           %put &em_codebar;
20942 +           %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidleadpointforkld;
20943 +           %goto ENDLINE;
20944 +       %end;
20945 +       %else %do;
20946 +            %let _clusLeadPoint =  &EM_PROPERTY_CLUSLEADPOINT;
20947 +       %end;
20948 +       %EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
20949 +                            target=%EM_TARGET,
20950 +                            timeid=%EM_TIMEID,
20951 +                            futurepoint=&_clusLeadPoint,
20952 +                            outKLD=&EM_USER_OUTKLD
20953 +                            );
20955 +       data &_EXPORT_DATA;
20956 +           set &EM_USER_OUTKLD;
20957 +       run;
20958 +   %end;
20959 +    %else %if &_EXPORTDATA eq FORECAST %then %do;
20961 +              %EM_TSESM_MakeOutClusInput(indata=&EM_USER_OUTSUM,
20962 +                                         esmmethod=&EM_PROPERTY_FCMETHOD,
20963 +                                         criterion=&EM_PROPERTY_BESTCRIT,
20964 +                                         outdata= &_EXPORT_DATA);
20965 +    %end;
20966 +    %else %if &_EXPORTDATA eq SIMILARITY %then %do;
20968 +              %EM_TSESM_MakeOutSimInput(indata=&EM_USER_OUTSUM,
20969 +                                        inoutfor=&EM_USER_OUTDATA,
20970 +                                        target=%EM_TARGET,
20971 +                                        timeid=%EM_TIMEID,
20972 +                                        esmmethod=&EM_PROPERTY_FCMETHOD,
20973 +                                        criterion=&EM_PROPERTY_BESTCRIT,
20974 +                                        outdata= &_EXPORT_DATA
20975 +                                       );
20976 +    %end;
20977 +    %else %do;
20979 +             data &_EXPORT_DATA;
20980 +                  set &EM_USER_OUTDATA;
20981 +             run;
20983 +        * number of outliers;
20984 +        /* this block is added 09022011 */
20985 +        proc sql noprint;
20986 +            select count(*) into :_has_outlier from &EM_USER_OUTLIER where outlierindex eq 1;
20987 +        quit;
20989 +        %if &EM_PROPERTY_SMOOTHOUTLIER eq Y and &_has_outlier gt 0 %then %do;
20990 +            /* this block is moved from below 09022011 */
20991 +            %EM_TSESM_MakeSmoothedOutds(indata=&_EXPORT_DATA,
20992 +                                        inoutlierds=&EM_USER_OUTLIER,
20993 +                                        target=%EM_TARGET,
20994 +                                        timeid=%EM_TIMEID,
20995 +                                        replace=&EM_PROPERTY_OUTLIERREPLACE,
20996 +                                        outdata=&_EXPORT_DATA
20997 +                                        );
20999 +            * in this type of output DO NOT keep outlier flags;
21000 +            /* this block is added 09022011 */
21001 +            %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
21002 +                data &_EXPORT_DATA;
21003 +                    set &_EXPORT_DATA;
21004 +                    drop outlier:;
21005 +                run;
21006 +            %end;
21008 +        %end;
21009 +    %end;
21011 +   /*--------------- Modify and export columnsMeta ------------------------------------*/
21014 +      data _null_;
21015 +       length string $34;
21016 +       filename X "&_FILE_CDELTA";
21017 +       file X;
21020 +      %if (&_EXPORTDATA eq KLD)
21021 +       or (&_EXPORTDATA eq FORECAST)
21022 +       or (&_EXPORTDATA eq SIMILARITY)
21023 +      %then %do;
21025 +         %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
21026 +         %if &dsid > 0 %then %do;
21027 +            %let nvar = %sysfunc(attrn(&dsid, NVAR));
21028 +            %do i = 1 %to &nvar;  /* not 1= _NAMEID_   2=_TSID_ */
21029 +                 %let varname = %sysfunc(varname(&dsid, &i));
21031 +                      %if ~(( &varname eq _TSID_ ) or ( &varname eq _NAMEID_ ) ) %then  %do;
21032 +                          put "if UPCASE(STRIP(NAME)) eq UPCASE(STRIP('&varname')) then ROLE='CROSSID';";
21033 +                      %end;
21034 +             %end;
21036 +             %if (&_EXPORTDATA eq SIMILARITY)   %then %do;
21037 +                  put "if upcase(strip(ROLE)) eq 'TARGET' then ROLE = 'INPUT'; ";
21038 +             %end;
21040 +             %let dsid = %sysfunc(close(&dsid));
21041 +           %end;
21042 +           put "if UPCASE(STRIP(NAME)) eq '_TSID_' then ROLE='ID';";
21043 +           put "if UPCASE(STRIP(NAME)) eq '_VARNAME_' then ROLE='REJECTED';";
21044 +           put "if UPCASE(STRIP(NAME)) eq '_ROLE_' then ROLE='REJECTED';";
21045 +           put "if UPCASE(STRIP(NAME)) eq '_NAMEID_' then ROLE='ID';";
21047 +    %end;
21048 +    %else %do;
21049 +           put "if UPCASE(STRIP(NAME)) eq '_TSID_' then ROLE='ID';";
21050 +    %end;
21053 +    run;
21058 +    %ENDLINE:
21059 +%mend EM_TSESM_SCORE;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTFORCST.
NOTE: The data set EMWS5.TSESM4_FORCSTPLOTDS has 106 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_FORCSTPLOTDS.
NOTE: The data set EMWS5.TSESM4_FORCSTPLOTDS has 106 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The file WORK._TMPTIMEDS (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The file WORK._TMPTIMEDS2 (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM4_OUTSUM.
NOTE: The data set EMWS5.TSESM4_OUTSUM has 1 observations and 20 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: The data set EMWS5.TSESM4_TRAIN has 106 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Variable string is uninitialized.
NOTE: The file X is:
      Filename=F:\WQD7005\MalaysiaStockPrediction-master\SAS\Mildstone5\Milestone5-Insight\Workspaces\EMWS5\TSESM4\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=19Dec2019:13:06:42,
      Create Time=19Dec2019:12:28:35
 
NOTE: 1 record was written to the file X.
      The minimum record length was 50.
      The maximum record length was 50.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
21062
21063
21064  *------------------------------------------------------------*;
21065  * End SCORE: TSESM4;
21066  *------------------------------------------------------------*;
 
21068  *------------------------------------------------------------*;
21069  * TSESM4: Computing metadata for TRAIN data;
21070  *------------------------------------------------------------*;
 
*------------------------------------------------------------*
* Report Log
Date:                December 19, 2019
Time:                13:06:43
*------------------------------------------------------------*
21440  %let EMEXCEPTIONSTRING=;
21441  *------------------------------------------------------------*;
21442  * REPORT: TSESM4;
21443  *------------------------------------------------------------*;
21444  %let EM_ACTION = REPORT;
21445  %let syscc = 0;
21446
21447  %macro EM_TSESM_MAIN;
21448
21449     filename temp catalog 'sashelp.emtsdm.tsesm_macros.source';
21450     %include temp;
21451     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
21452     %include temp;
21453     filename temp;
21454
21455     %if %upcase(&EM_ACTION) = CREATE %then %do;
21456         filename temp catalog 'sashelp.emtsdm.tsesm_create.source';
21457         %include temp;
21458         filename temp;
21459         %EM_TSESM_CREATE;
21460     %end;
21461     %else
21462     %if %upcase(&EM_ACTION) = TRAIN %then %do;
21463          filename temp catalog 'sashelp.emtsdm.tsesm_train.source';
21464             %include temp;
21465             filename temp;
21466          %EM_TSESM_TRAIN;
21467     %end;
21468     %else
21469     %if %upcase(&EM_ACTION) = SCORE %then %do;
21470             filename temp catalog 'sashelp.emtsdm.tsesm_score.source';
21471             %include temp;
21472             filename temp;
21473           %EM_TSESM_SCORE;
21474     %end;
21475     %else
21476     %if %upcase(&EM_ACTION) = REPORT %then %do;
21477             filename temp catalog 'sashelp.emtsdm.tsesm_report.source';
21478             %include temp;
21479             filename temp;
21480            %EM_TSESM_REPORT;
21481     %end;
21482  %mend EM_TSESM_MAIN;
21483  %EM_TSESM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_MACROS.SOURCE.
21484 +/*----------------------------------------------------------------------------------+
21485 + |
21486 + |   Title :  Time Series data Mining Forcating Macros
21487 + |
21488 + |   SUPPORT: Ruiwen Zhang (Ruiwen.Zhang@sas.com)
21489 + |
21490 + |
21491 + +-----------------------------------------------------------------------------------*/
21494 +%macro EM_TSESM_Forecast(indata=,
21495 +                method=,
21496 +                timeinterval=,
21497 +                timeid= ,
21498 +                target= ,
21499 +                tsidvar=,
21500 +                lead=,
21501 +                back=,
21502 +                startsum=,
21503 +                accumulate=,
21504 +                seasonality=,
21505 +                alpha=,
21506 +                extendedvalue=,
21507 +                outest = ,
21508 +                outdata = ,
21509 +                outfor = ,
21510 +                outstat = ,
21511 +                outsum=
21512 +   );
21515 +   %if &tsidvar eq _SEGMENT_ %then %do;
21516 +       proc sort data=&indata out=_tmpdata;
21517 +            by  &tsidvar %EM_CROSSID &timeid ;
21518 +       run;
21519 +       proc timeseries  data =_tmpdata out=_tmpdata;
21520 +            by  &tsidvar %EM_CROSSID;
21521 +            id &timeid interval=&timeinterval accumulate=&accumulate;
21522 +            var &target / ;
21523 +       run;
21524 +       proc esm data =_tmpdata
21525 +   %end;
21526 +   %else %do;
21527 +       proc sort data= &indata out=_tmpdata;
21528 +            by  &tsidvar %EM_CROSSID &timeid ;
21529 +       run;
21530 +       proc esm data = _tmpdata
21531 +   %end;
21532 +            lead=&lead  back=&back startsum=&startsum
21534 +   %if &seasonality ne DEFAULT %then %do;
21535 +            seasonality = &seasonality
21536 +   %end;
21539 +            out=&outdata
21540 +            outest=&outest
21541 +            outfor =&outfor
21542 +            outstat=&outstat
21543 +            outsum= &outsum
21544 +       ;
21545 +        id &timeid  interval = &timeinterval   accumulate=&accumulate ;
21547 +        %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
21548 +            %if &target ne %then %do;
21549 +            forecast &target   /  model = none alpha=&alpha;
21550 +            %end;
21551 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21552 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /  model = &method alpha=&alpha use=&extendedvalue;
21553 +            %end;
21554 +        %end;
21555 +        %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
21556 +            %if &target ne %then %do;
21557 +            forecast &target /  model =&method alpha=&alpha;
21558 +            %end;
21559 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21560 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
21561 +            %end;
21562 +        %end;
21563 +        %else %do; /* for KLD, FORECAST Cluster , SIMILARITY */
21564 +            forecast &target /*%EM_INTERVAL_INPUT*/ /  model = &method alpha=&alpha use=predict;
21565 +        %end;
21567 +   %if &tsidvar ne %then %do;
21568 +        by &tsidvar %EM_CROSSID ;
21569 +   %end;
21570 +   run;
21571 +%mend EM_TSESM_Forecast;
21574 +%macro EM_TSESM_CreateOutFor(indata=,
21575 +                            target=,
21576 +                            timeid=,
21577 +                            tsidVar=,
21578 +                            percent=,
21579 +                            outdata=);
21581 +  %let lowerBound = L&percent;
21582 +  %let upperBound = U&percent;
21584 +  data ds_fore(rename=(&target=FORECAST)  drop=_TYPE_)
21585 +       ds_resid(rename=(&target=RESIDUAL) drop=_TYPE_)
21586 +       ds_act(rename=(&target=ACTUAL) drop=_TYPE_)
21587 +       ds_lower(rename=(&target=LBOUND)  drop=_TYPE_)
21588 +       ds_upper(rename=(&target=UBOUND) drop=_TYPE_)
21589 +       ds_std(rename=(&target=STD) drop=_TYPE_);
21590 +     set &indata;
21591 +       if _TYPE_="FORECAST" then output ds_fore;
21592 +       if _TYPE_="RESIDUAL" then output ds_resid;
21593 +       if _TYPE_="ACTUAL" then output ds_act;
21594 +       if _TYPE_="&lowerBound" then output ds_lower;
21595 +       if _TYPE_="&upperBound" then output ds_upper;
21596 +       if _TYPE_="STD" then output ds_std;
21597 +  run;
21599 +  data &outdata;
21600 +       merge ds_fore ds_resid ds_act ds_lower ds_upper ds_std;
21601 +       by &tsidVar &timeid;
21602 +       label  FORECAST = "Forecast";
21603 +       label  ACTUAL = "Actual";
21604 +       label  RESIDUAL = "Residual";
21605 +       label  LBOUND = "Lower Bound";
21606 +       label  UBOUND = "Upper Bound";
21607 +       label   STD = "Standard Deviation";
21608 +  run;
21609 +%mend EM_TSESM_CreateOutFor;
21612 +%macro EM_TSESM_CreateOutExpand(indata=,
21613 +                       target=,
21614 +                       timeid=,
21615 +                       tsidVar=,
21616 +                       percent=,
21617 +                       outlower=,
21618 +                       outupper=,
21619 +                       outdata=);
21621 +  %let lowerBound = L&percent;
21622 +  %let upperBound = U&percent;
21624 +  /*proc print data=&indata(obs=200);
21625 +  run;
21626 +  */
21628 +  data ds_fore(drop=&target)
21629 +       ds_lower(drop=&target)
21630 +       ds_upper(drop=&target)
21631 +       ds_act;
21632 +     set &indata;
21633 +       if _TYPE_="FORECAST" and _LEAD_  > 0 then output ds_fore;
21634 +       if _TYPE_="&lowerBound" and  _LEAD_  > 0 then output ds_lower;
21635 +       if _TYPE_="&upperBound" and  _LEAD_  > 0 then output ds_upper;
21636 +       if _TYPE_="ACTUAL" then output ds_act;
21637 +  run;
21639 +  /*
21640 +  proc print data = ds_fore;
21641 +  proc print data=ds_act;
21642 +  run;
21643 +  */
21644 +  data &outdata;
21645 +       merge ds_act ds_fore;
21646 +       by &tsidVar &timeid;
21647 +  run;
21649 +  data &outlower;
21650 +       merge ds_act ds_lower;
21651 +       by &tsidVar &timeid;
21652 +  run;
21654 +  data &outupper;
21655 +       merge ds_act ds_upper;
21656 +       by &tsidVar &timeid;
21657 +  run;
21658 +  /*
21659 +  proc print data=&outdata(obs=300);
21660 +  proc print data=&outlower(obs=300);
21661 +  proc print data=&outupper(obs=300);
21662 +  run;
21663 +  */
21664 +%mend EM_TSESM_CreateOutExpand;
21668 +%macro EM_TSESM_MakeOutClus(indata=,
21669 +                   target=,
21670 +                   timeid=,
21671 +                   tsidVar=,
21672 +                   percent=,
21673 +                   outlower=,
21674 +                   outupper=,
21675 +                   outdata=);
21678 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
21680 +  data &outdata(rename=(_NAME_ =_NAMEID_));
21681 +       set &indata;
21682 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD;
21683 +  run;
21685 +  %let dsid=%sysfunc(open(&outdata));
21686 +  %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
21687 +  %let dsid=%sysfunc(close(&dsid));
21689 +  %if &vn_name > 0 %then %do;
21690 +      data &outdata(drop=_NAMEID_);
21691 +           merge &EM_USER_TSIDMAP &outdata;
21692 +           by _TSID_;
21693 +      run;
21694 +  %end;
21695 +  %else %do;
21696 +      proc sort data= &outdata; by _NAMEID_;
21697 +      run;
21698 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
21699 +      run;
21700 +      data &outdata(drop=_NAMEID_);
21701 +           merge &EM_USER_TSIDMAP &outdata;
21702 +           by _NAMEID_;
21703 +      run;
21704 +  %end;
21706 +%mend EM_TSESM_MakeOutClus;
21709 +%macro EM_TSESM_CreateOutEst(indata=,
21710 +                    target=,
21711 +                    timeid=,
21712 +                    outdata=);
21714 +%mend EM_TSESM_CreateOutEst;
21717 +%macro EM_TSESM_Best_Forecast(indata=,
21718 +                method=,
21719 +                timeinterval=,
21720 +                timeid= ,
21721 +                target= ,
21722 +                tsidvar=,
21723 +                lead=,
21724 +                back=,
21725 +                startsum=,
21726 +                accumulate=,
21727 +                seasonality=,
21728 +                alpha=,
21729 +                criterion=,
21730 +                extendedvalue=,
21731 +                outest = ,
21732 +                outdata = ,
21733 +                outfor = ,
21734 +                outstat = ,
21735 +                outsum=
21736 +   );
21738 +   %let _indata = &indata;
21740 +   %if &tsidvar eq _SEGMENT_ %then %do;
21741 +       proc sort data=&indata out=_tmpdata;
21742 +            by  &tsidvar %EM_CROSSID &timeid ;
21743 +       run;
21744 +       proc timeseries  data =_tmpdata out=_tmpdata;
21745 +            by  &tsidvar %EM_CROSSID ;
21746 +            id &timeid interval=&timeinterval accumulate=&accumulate;
21747 +            var &target / ;
21748 +       run;
21749 +       %let _indata = _tmpdata;
21750 +   %end;
21752 +   %let n_model = 0;
21754 +   %if &EM_PROPERTY_SIMPLE eq Y %then %do;
21756 +       %let n_model = %eval(&n_model+1);
21758 +       %let _ds_out =_out&n_model;
21759 +       %let _ds_outest =_outest&n_model;
21760 +       %let _ds_outfor =_outfor&n_model;
21761 +       %let _ds_outstat =_outstat&n_model;
21762 +       %let _ds_outsum=_outsum&n_model;
21764 +       %EM_TSESM_ESM(method=SIMPLE,
21765 +        timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21766 +        lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21767 +        out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21768 +        );
21770 +   %end;
21771 +   %if &EM_PROPERTY_DOUBLE eq Y %then %do;
21773 +       %let n_model = %eval(&n_model+1);
21775 +       %let _ds_out =_out&n_model;
21776 +       %let _ds_outest =_outest&n_model;
21777 +       %let _ds_outfor =_outfor&n_model;
21778 +       %let _ds_outstat =_outstat&n_model;
21779 +       %let _ds_outsum=_outsum&n_model;
21781 +       %EM_TSESM_ESM(method=DOUBLE,
21782 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21783 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21784 +             out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21785 +       );
21786 +   %end;
21788 +   %if &EM_PROPERTY_LINEAR eq Y %then %do;
21790 +       %let n_model = %eval(&n_model+1);
21791 +       %let _ds_out =_out&n_model;
21792 +       %let _ds_outest =_outest&n_model;
21793 +       %let _ds_outfor =_outfor&n_model;
21794 +       %let _ds_outstat =_outstat&n_model;
21795 +       %let _ds_outsum=_outsum&n_model;
21797 +       %EM_TSESM_ESM(method=LINEAR,
21798 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21799 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21800 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21801 +        );
21802 +   %end;
21804 +   %if &EM_PROPERTY_DAMPTREND eq Y %then %do;
21806 +       %let n_model = %eval(&n_model+1);
21808 +       %let _ds_out =_out&n_model;
21809 +       %let _ds_outest =_outest&n_model;
21810 +       %let _ds_outfor =_outfor&n_model;
21811 +       %let _ds_outstat =_outstat&n_model;
21812 +       %let _ds_outsum=_outsum&n_model;
21814 +       %EM_TSESM_ESM(method=DAMPTREND,
21815 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21816 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21817 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21818 +            );
21819 +   %end;
21820 +   /*------- Seasonal model ------*/
21822 +   %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do;
21824 +   %if (&EM_PROPERTY_WINTERS eq Y) %then %do;
21826 +       %let n_model = %eval(&n_model+1);
21828 +       %let _ds_out =_out&n_model;
21829 +       %let _ds_outest =_outest&n_model;
21830 +       %let _ds_outfor =_outfor&n_model;
21831 +       %let _ds_outstat =_outstat&n_model;
21832 +       %let _ds_outsum=_outsum&n_model;
21834 +       %EM_TSESM_ESM(method=WINTERS,
21835 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21836 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21837 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21838 +        );
21839 +   %end;
21841 +   %if (&EM_PROPERTY_ADDSEASONAL eq Y) %then %do;
21843 +       %let n_model = %eval(&n_model+1);
21845 +       %let _ds_out =_out&n_model;
21846 +       %let _ds_outest =_outest&n_model;
21847 +       %let _ds_outfor =_outfor&n_model;
21848 +       %let _ds_outstat =_outstat&n_model;
21849 +       %let _ds_outsum=_outsum&n_model;
21851 +       %EM_TSESM_ESM(method=ADDSEASONAL,
21852 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21853 +            lead=&lead, back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21854 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21855 +       );
21856 +   %end;
21858 +   %if (&EM_PROPERTY_MULTSEASONAL eq Y) %then %do;
21860 +       %let n_model = %eval(&n_model+1);
21862 +       %let _ds_out =_out&n_model;
21863 +       %let _ds_outest =_outest&n_model;
21864 +       %let _ds_outfor =_outfor&n_model;
21865 +       %let _ds_outstat =_outstat&n_model;
21866 +       %let _ds_outsum=_outsum&n_model;
21868 +       %EM_TSESM_ESM(method=MULTSEASONAL,
21869 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21870 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21871 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21872 +       );
21873 +   %end;
21875 +   %if (&EM_PROPERTY_ADDWINTERS eq Y) %then %do;
21877 +       %let n_model = %eval(&n_model+1);
21879 +       %let _ds_out =_out&n_model;
21880 +       %let _ds_outest =_outest&n_model;
21881 +       %let _ds_outfor =_outfor&n_model;
21882 +       %let _ds_outstat =_outstat&n_model;
21883 +       %let _ds_outsum=_outsum&n_model;
21885 +       %EM_TSESM_ESM(method=ADDWINTERS,
21886 +            timeinterval=&timeinterval, timeid=&timeid, target=&target, tsidvar=&tsidvar,
21887 +            lead=&lead,  back=&back, startsum=&startsum, accumulate=&accumulate, seasonality=&seasonality, alpha=&alpha,
21888 +            out=&_ds_out, outest=&_ds_outest, outfor =&_ds_outfor, outstat=&_ds_outstat, outsum=&_ds_outsum
21889 +            );
21890 +   %end;
21893 +   %end; /* end of %if (&timeinterval ne YEAR ) and ( &timeinterval ne DTYEAR ) %then %do; */
21894 +   /*-------- end of seasonal model  ------------------------------------------------------*/
21896 +   %if &n_model eq 0 %then %do;
21898 +       /*---- %PUT  ERROR:THE NUMBER OF CANDIDATE MODELS IS ZERO;  */
21899 +       %let  EMEXCEPTIONSTRING = exception.server.tsdm.zerocandidatemodel;
21900 +   %end;
21901 +   %else %do;
21902 +         %EM_TSESM_BestModelSel(crit=&criterion,
21903 +                               n_mdl=&n_model,
21904 +                               tsidvar=&tsidvar,
21905 +                               timeid=&timeid,
21906 +                               out=&outdata,
21907 +                               outest=&outest,
21908 +                               outfor =&outfor,
21909 +                               outstat=&outstat,
21910 +                               outsum=&outsum
21911 +                  );
21912 +   %end;
21914 +%mend EM_TSESM_Best_Forecast;
21917 +%macro EM_TSESM_ESM(method= ,
21918 +           timeinterval=,
21919 +           timeid= ,
21920 +           target= ,
21921 +           tsidvar=,
21922 +           lead=,
21923 +           back=,
21924 +           startsum=,
21925 +           accumulate=,
21926 +           seasonality=,
21927 +           alpha=,
21928 +           out= ,
21929 +           outest= ,
21930 +           outfor= ,
21931 +           outstat= ,
21932 +           outsum=
21933 +           );
21935 +       proc sort data= &_indata out=_tmpdata;
21936 +            by  &tsidvar %EM_CROSSID &timeid ;
21937 +       run;
21938 +       proc esm data = _tmpdata  lead=&lead    back=&back  startsum=&startsum
21940 +       %if &seasonality ne DEFAULT %then %do;
21941 +                     seasonality = &seasonality
21942 +       %end;
21943 +            out=&out
21944 +            outest=&outest
21945 +            outfor =&outfor
21946 +            outstat=&outstat
21947 +            outsum= &outsum
21948 +            ;
21949 +       id &timeid  interval = &timeinterval  accumulate=&accumulate  ;
21951 +       %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
21952 +            %if &target ne %then %do;
21953 +            forecast &target   /  model = none alpha=&alpha;
21954 +            %end;
21955 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21956 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha use=&extendedvalue;
21957 +            %end;
21958 +       %end;
21959 +       %else %if &EM_PROPERTY_EXPORTDATA eq DEFAULT %then %do;
21960 +            %if &target ne %then %do;
21961 +            forecast &target /  model =&method alpha=&alpha;
21962 +            %end;
21963 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21964 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = none alpha=&alpha;
21965 +            %end;
21966 +       %end;
21967 +       %else %do;   /*----- CLUSTER INPUT , KLD, SIMILARITY INPUT ------*/
21968 +            %if &target ne %then %do;
21969 +            forecast &target   /  model = &method alpha=&alpha;
21970 +            %end;
21971 +            /*
21972 +            %if %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED ne %then %do;
21973 +            forecast %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/  model = &method alpha=&alpha;
21974 +            %end;
21975 +            */
21976 +       %end;
21978 +       %if &tsidvar ne %then %do;
21979 +        by &tsidvar %EM_CROSSID;
21980 +       %end;
21981 +       run;
21983 +%mend EM_TSESM_ESM;
21987 +%macro EM_TSESM_BestModelSel(crit=,
21988 +                    n_mdl=,
21989 +                    tsidvar=_TSID_,
21990 +                    timeid=MNTH_YR,
21991 +                    out=&_outdata,
21992 +                    outest=&_outest,
21993 +                    outfor =&_outfor,
21994 +                    outstat=&_outstat,
21995 +                    outsum=&_outsum
21996 +    );
21998 +   %let statbls=select *, 1 as mdlID from _outstat1;
21999 +   %let estbls=select *,  1 as mdlID from _outest1;
22000 +   %let fortbls=select *, 1 as mdlID from _outfor1;
22001 +   %let outbls=select *,  1 as mdlID from _out1;
22002 +   %let sumtbls=select *, 1 as mdlID from _outsum1;
22003 +   %do i=2 %to &n_mdl;
22004 +      %let statbls=&statbls union all select *, &i as mdlID from _outstat&i;
22005 +        %let estbls=&estbls union all select *, &i as mdlID from _outest&i;
22006 +        %let fortbls=&fortbls union all select *, &i as mdlID from _outfor&i;
22007 +        %let outbls=&outbls union all select *, &i as mdlID from _out&i;
22008 +        %let sumtbls=&sumtbls union all select *, &i as mdlID from _outsum&i;
22009 +   %end;
22011 +   %let dsid=%sysfunc(open(_out1));
22012 +   %let vn_tsid = 0;
22014 +   %if &dsid > 0 %then %do;
22015 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22016 +         %let dsid = %sysfunc(close(&dsid));
22017 +   %end;
22019 +   %if &vn_tsid <= 0  %then %do;
22020 +       %let tsidvar=_NAME_;
22021 +   %end;
22023 +  /*
22024 +  %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
22025 +     %let tsidvar=_NAME_;
22026 +   %end;
22027 +  */
22029 +   proc sql;
22030 +     create table tsstat as &statbls;
22031 +     create table tsest  as &estbls;
22032 +     create table tsfor  as &fortbls;
22033 +     create table tsout  as &outbls;
22034 +     create table tssum  as &sumtbls;
22035 +   quit;
22037 +    proc sort data=tsstat out=bestmdl;
22038 +        by &tsidvar &crit mdlID;
22039 +    run;
22041 +    * when multiple BEST model found;
22042 +    * use the one with smallest model ID;
22043 +    data bestmdl;
22044 +        set bestmdl;
22045 +        by &tsIDvar;
22046 +        if first.&tsIDVar;
22047 +    run;
22049 +   proc sql;
22050 +      create table bestID as
22051 +        select distinct(tsest.&tsidvar), _model_, &crit, bestmdl.mdlID
22052 +        from bestmdl,tsest
22053 +        where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar;
22055 +      create table &outfor
22056 +        as select tsfor.*, _model_, &crit from tsfor, bestID
22057 +        where tsfor.&tsidvar=bestID.&tsidvar and tsfor.mdlID=bestID.mdlID order by &tsidvar, &timeid;
22059 +        create table &outstat
22060 +        as select tsstat.*, _model_ from tsstat, bestID
22061 +      where tsstat.&tsidvar=bestID.&tsidvar and tsstat.mdlID=bestID.mdlID order by &tsidvar;
22063 +        create table &outest
22064 +        as select tsest.*, &crit from bestmdl, tsest
22065 +      where bestmdl.mdlID=tsest.mdlID and bestmdl.&tsidvar=tsest.&tsidvar order by &tsidvar;
22067 +      create table &outsum
22068 +        as select tssum.*, _model_, &crit from tssum, bestID
22069 +      where tssum.&tsidvar=bestID.&tsidvar and tssum.mdlID=bestID.mdlID order by &tsidvar;
22071 +      /*
22072 +      %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
22073 +        create table &out
22074 +          as select tsout.*, _model_, &crit from tsout, bestID
22075 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
22076 +      %end;
22077 +      */
22079 +      %if &tsidvar eq _TSID_ %then %do;
22081 +         create table &out
22082 +          as select tsout.*, _model_, &crit from tsout, bestID
22083 +        where tsout.&tsidvar=bestID.&tsidvar and tsout.mdlID=bestID.mdlID order by &tsidvar, &timeid;
22085 +      %end;
22086 + run;
22087 +quit;
22089 + /*%if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
22091 + %if &tsidvar = _NAME_ %then %do;
22092 +      data
22093 +            %let i=1;
22094 +            %do i=1 %to &n_mdl;
22095 +               %let _tmpdsname = _tmpds&i;
22096 +                    &_tmpdsname
22097 +            %end;
22098 +        ;
22099 +         set work.Bestmdl;
22100 +            %let i=1;
22101 +            %do i=1 %to &n_mdl;
22102 +               %let _tmpdsname = _tmpds&i;
22103 +                  if mdlID = &i then output &_tmpdsname;
22104 +            %end;
22105 +      run;
22107 +      data &out;
22108 +           set _out1;
22109 +           keep &timeid %EM_TARGET;
22110 +      run;
22111 +      %let i=1;
22112 +      %do i=1 %to &n_mdl;
22113 +          %let _tmpdsname = _tmpds&i;
22114 +          %let _outdsname = _out&i;
22116 +          data &out;
22117 +               set &out;
22118 +               set &_outdsname(keep=
22119 +               %let dsid=%sysfunc(open(&_tmpdsname));
22120 +               %if &dsid > 0 %then %do;
22121 +                  %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
22122 +                  %do %while(^%sysfunc(fetch(&dsid)));
22123 +                     %let _name  = %sysfunc(getvarc(&dsid, &vn_name));
22124 +                          &_name
22125 +                  %end;
22126 +                  %let dsid = %sysfunc(close(&dsid));
22127 +               %end;
22128 +               );
22129 +           run;
22130 +       %end;
22132 +%end;
22134 +data &out;
22135 +     set  &out;
22136 +      drop mdlID _MODEL_ &crit;
22137 +data &outest;
22138 +      set  &outest;
22139 +      drop mdlID &crit;
22140 +data &outfor;
22141 +     set &outfor;
22142 +     drop mdlID &crit;
22143 +data &outstat;
22144 +     set &outstat;
22145 +     drop mdlID;
22146 +data &outsum;
22147 +     set &outsum;
22148 +     drop mdlID &crit;
22149 +run;
22151 +%mend EM_TSESM_BestModelSel;
22155 +%macro EM_TSESM_MakeOutlierIndex(indata=,
22156 +                        target=,
22157 +                        timeid=,
22158 +                        outoutlier=,
22159 +                        outlierds=,
22160 +                        outdata=);
22161 +%let label_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlier, noquote));
22162 +%let str_Actual_Outlier = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actualoutlier, noquote));
22163 +%let str_Actual = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_actual, noquote));
22164 +data &outdata;
22165 +     set &indata;
22166 +     length OutlierIndex 8.;
22167 +     length Outlier  $40;
22168 +     label  OutlierIndex = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_outlierindex, noquote))";
22169 +     label  Outlier = "&label_Outlier";
22170 +   /*  if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&label_Outlier";end;
22171 +       else  do; OutlierIndex=0; outlier =" "; end; */
22172 +     if (ACTUAL ne . ) and ( (ACTUAL > UPPER) or (ACTUAL < LOWER) ) then do; OutlierIndex=1; Outlier="&str_Actual_Outlier";end;
22173 +       else  do; OutlierIndex=0; outlier ="&str_Actual"; end;
22174 +run;
22176 +data  &outoutlier;
22177 +      set  &outdata;
22178 +      keep &timeid _TSID_ _SEGMENT_ _NAME_ _NAMEID_ OUTLIERINDEX OUTLIER PREDICT;
22179 +      if ACTUAL = . then delete;
22180 +run;
22182 +data &outlierds;
22183 +     set &outoutlier;
22184 +     if OUTLIERINDEX = 0 then delete;
22185 +     Drop OUTLIERINDEX;
22186 +run;
22188 +%mend  EM_TSESM_MakeOutlierIndex;
22191 +%macro EM_TSESM_MakeSmoothedOutds(indata=,
22192 +                         inoutlierds=,
22193 +                         target=,
22194 +                         timeid=,
22195 +                         tsidvar=_TSID_,
22196 +                         replace=,
22197 +                         outdata=);
22200 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22203 +%let dsid=%sysfunc(open(&indata));
22204 +%let vn_tsid = 0;
22205 +%if &dsid > 0 %then %do;
22206 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22207 +         %let dsid = %sysfunc(close(&dsid));
22208 +%end;
22210 +%if &vn_tsid <= 0  %then %do;
22211 +    %let tsidvar=_NAME_;
22212 +%end;
22214 +%if &tsidvar = _TSID_ %then %do;
22215 +/* %if &EM_PROPERTY_EXTINPUT eq Y %then %do; */
22216 + /*    data &outdata;
22217 +          merge &indata &inoutlierds;
22218 +          by _TSID_ &timeid;
22219 +          if OutlierIndex > 0 then
22220 +          %if &replace eq PREDICT %then %do;
22221 +             &target = PREDICT;
22222 +          %end;
22223 +          %else %do;
22224 +             &target = .;
22225 +          %end;
22226 +           Drop Predict _NAME_ OutlierIndex;
22227 +     run;     */
22228 +  %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
22229 +     %if &dsid > 0 %then %do;
22230 +         %let vn_nameid =%sysfunc(varnum(&dsid, _VARNAME_));
22231 +         %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22232 +         %let i = 1;
22233 +              %do %while(^%sysfunc(fetch(&dsid)));
22234 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
22235 +                  %let _vartsid= %sysfunc(getvarn(&dsid, &vn_tsid));
22236 +                  %if &i eq 1 %then %do;
22237 +                      data _tmpoutlier;
22238 +                           set &inoutlierds;
22239 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid then output;
22240 +                      run;
22241 +                      data &outdata;
22242 +                           merge &indata _tmpoutlier;
22243 +                           by _TSID_ &timeid ;
22244 +                           if OutlierIndex  > 0 then
22245 +                              %if &replace eq PREDICT %then %do;
22246 +                                &_varname = PREDICT;
22247 +                              %end;
22248 +                              %else %do;
22249 +                                &_varname = .;
22250 +                              %end;
22251 +                            Drop Predict _NAME_  OutlierIndex Outlier;
22252 +                      run;
22253 +                   %end;
22254 +                   %else %do;
22255 +                      data _tmpoutlier;
22256 +                           set &inoutlierds;
22257 +                           if _NAME_ ="&_varname" and _TSID_ = &_vartsid  then output;
22258 +                      run;
22259 +                      data &outdata;
22260 +                           merge &outdata _tmpoutlier;
22261 +                           by _TSID_ &timeid ;
22262 +                           if OutlierIndex  > 0 then
22263 +                              %if &replace eq PREDICT %then %do;
22264 +                                &_varname = PREDICT;
22265 +                              %end;
22266 +                              %else %do;
22267 +                                &_varname = .;
22268 +                              %end;
22269 +                           Drop Predict _NAME_  OutlierIndex Outlier;
22270 +                      run;
22271 +                   %end;
22272 +                   %let i = %eval(&i+1);
22274 +              %end;
22275 +           %let dsid = %sysfunc(close(&dsid));
22276 +      %end;
22277 +%end;
22278 +%else %do;  /*  %if &tsidvar = _NAME_ %then %do; */
22280 +     %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
22281 +     %if &dsid > 0 %then %do;
22282 +         %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
22283 +         %let i = 1;
22284 +              %do %while(^%sysfunc(fetch(&dsid)));
22285 +                  %let _varname= %sysfunc(getvarc(&dsid, &vn_nameid));
22286 +                  %if &i eq 1 %then %do;
22287 +                      data _tmpoutlier;
22288 +                           set &inoutlierds;
22289 +                           if _NAME_ ="&_varname"  then output;
22290 +                      run;
22291 +                      data &outdata;
22292 +                           merge &indata _tmpoutlier;
22293 +                           by &timeid;
22294 +                           if OutlierIndex  > 0 then
22295 +                              %if &replace eq PREDICT %then %do;
22296 +                                &_varname = PREDICT;
22297 +                              %end;
22298 +                              %else %do;
22299 +                                &_varname = .;
22300 +                              %end;
22301 +                            Drop Predict _NAME_ OutlierIndex Outlier;
22302 +                      run;
22303 +                   %end;
22304 +                   %else %do;
22305 +                      data _tmpoutlier;
22306 +                           set &inoutlierds;
22307 +                           if _NAME_ ="&_varname"  then output;
22308 +                      run;
22309 +                      data &outdata;
22310 +                           merge &outdata _tmpoutlier;
22311 +                           by &timeid;
22312 +                           if OutlierIndex  > 0 then
22313 +                              %if &replace eq PREDICT %then %do;
22314 +                                &_varname = PREDICT;
22315 +                              %end;
22316 +                              %else %do;
22317 +                                &_varname = .;
22318 +                              %end;
22319 +                           Drop Predict _NAME_ OutlierIndex Outlier;
22320 +                      run;
22321 +                   %end;
22322 +                   %let i = %eval(&i+1);
22324 +              %end;
22325 +           %let dsid = %sysfunc(close(&dsid));
22326 +      %end;
22327 +      %else %do;
22328 +            /* this block is added 09022011*/
22329 +            /* works for wide table in which each time series has a column */
22331 +            proc transpose data=&indata out=_tmpdata1;
22332 +                by &timeID;
22333 +            run;
22335 +            proc sql;
22336 +                create table _tmpdata2 as
22337 +                    select a.*, b.outlierindex, b.outlier, b.predict
22338 +                        from _tmpdata1 as a left join &inoutlierds as b
22339 +                            on a.&timeID eq b.&timeID and a._name_ eq b._name_
22340 +                        order by a.&timeID, a._name_
22341 +                    ;
22342 +            quit;
22344 +            data _tmpdata2;
22345 +                set _tmpdata2;
22346 +                if outlierindex eq 1 then
22347 +                    if &replace eq PREDICT then col1=predict; else col1=.;
22348 +            run;
22350 +            proc transpose data=_tmpdata2 out=_tmpdata3(drop=_name_ _label_);
22351 +                by &timeID;
22352 +                ID _name_;
22353 +                var col1;
22354 +            proc sort data=&inoutlierds out=_tmpoutlier;
22355 +                by &timeID _name_;
22356 +            proc transpose data=_tmpoutlier out=_tmpdata4(drop=_name_ _label_) prefix=Outlier_;
22357 +                by &timeID;
22358 +                ID _name_;
22359 +                var outlier;
22360 +            run;
22362 +            data &outdata;
22363 +                merge _tmpdata3 _tmpdata4;
22364 +                by &timeID;
22365 +            run;
22366 +      %end;
22367 +%end;
22368 +%mend EM_TSESM_MakeSmoothedOutds;
22370 +%Macro EM_TSESM_MakeOutKLD(indata=&EM_USER_OUTPRED,
22371 +                  insumdata=&EM_USER_OUTSUM,
22372 +                target=&_targetVar,
22373 +                timeid=&_timeidVar,
22374 +                futurepoint=1,
22375 +                outKLD=&EM_USER_OUTKLD
22376 +                );
22378 +%if &futurepoint > 0 %then %do;
22380 +proc sort data=&indata out=_tmptimeid;
22381 +     by &timeid;
22382 +run;
22384 +data _tmptimeid(keep=&timeid);
22385 +      set _tmptimeid; by &timeid;
22386 +      if first.&timeid then output;
22387 +run;
22389 +%let _targetTime =;
22390 +%let dsid=%sysfunc(open(work._tmptimeid));
22391 +%if &dsid > 0 %then %do;
22392 +    %let vn_timeid =%sysfunc(varnum(&dsid, &timeid));
22393 +    %let i = 1;
22394 +    %do %while(^%sysfunc(fetch(&dsid)));
22395 +       %if &i eq &futurepoint %then %do;
22396 +       %let _targetTime  = %sysfunc(getvarn(&dsid, &vn_timeid));
22397 +       %end;
22398 +       %let i = %eval(&i+1);
22399 +    %end;
22400 +    %let dsid = %sysfunc(close(&dsid));
22401 +%end;
22403 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
22404 +   set &indata;
22405 +   if &timeid eq &_targetTime then output;
22406 +run;
22408 +%end;  /* end of %if &futurepoint > 0 %then %do; */
22409 +%else %do;
22412 +data _tmpKLD(keep = _TSID_ _NAME_ PREDICT STD);
22413 +   set &insumdata;
22414 +run;
22417 +%end;
22419 +%EM_TSESM_KLD(indata=work._tmpKLD, outdata=&outKLD);
22421 +/* Merge TSIDMAP  */
22423 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22424 +data &outKLD(rename=(_NAME_ =_NAMEID_));
22425 +       set &outKLD;
22426 +run;
22428 +%let dsid=%sysfunc(open(&outKLD));
22429 +%let vn_name =%sysfunc(varnum(&dsid, _TSID_));
22430 +%let dsid=%sysfunc(close(&dsid));
22432 +%if &vn_name > 0 %then %do;
22433 +      data &outKLD(drop=_NAMEID_);
22434 +           merge &EM_USER_TSIDMAP &outKLD;
22435 +           by _TSID_;
22436 +      run;
22437 +%end;
22438 +%else %do;
22439 +      proc sort data= &outKLD; by _NAMEID_;
22440 +      run;
22441 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
22442 +      run;
22443 +      data &outKLD(drop=_NAMEID_);
22444 +           merge &EM_USER_TSIDMAP &outKLD;
22445 +           by _NAMEID_;
22446 +      run;
22447 +%end;
22449 +/* delete _tmptimeid  _tmpKLD */
22450 +%Mend  EM_TSESM_MakeOutKLD;
22453 +%Macro EM_TSESM_MakeOutPred(indata=&EM_USER_OUTFORCST,
22454 +                 target=&_targetVar,
22455 +                 timeid=&_timeidVar,
22456 +                 outdata=&EM_USER_OUTPRED
22457 +                 );
22459 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
22460 +%let _EndTime = ;
22461 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
22462 +%if &dsid > 0 %then %do;
22463 +    %let vn_end =%sysfunc(varnum(&dsid, END));
22464 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
22465 +    %do %while(^%sysfunc(fetch(&dsid)));
22466 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
22467 +       /*--------------------------------------------------------
22468 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
22469 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
22470 +        ---------------------------------------------------------*/
22471 +    %end;
22472 +    %let dsid = %sysfunc(close(&dsid));
22473 +%end;
22475 +data &outdata(keep= _TSID_ _NAME_  &timeid PREDICT LOWER UPPER STD);
22476 +     set &indata;
22477 +     if &timeid > &_EndTime then output;
22478 +run;
22479 +%Mend  EM_TSESM_MakeOutPred;
22482 +%macro EM_TSESM_KLD(indata=work._tmp, outdata=_out);
22484 +%let std_x = ;
22485 +%let mu_y = ;
22487 +%let dsid=%sysfunc(open(&indata));
22488 +%if &dsid > 0 %then %do;
22489 +    %let vn_pred =%sysfunc(varnum(&dsid, PREDICT));
22490 +    %let vn_std  = %sysfunc(varnum(&dsid, STD));
22491 +    %let i=1;
22492 +    %do %while(^%sysfunc(fetch(&dsid)));
22493 +        %let _pred  = %sysfunc(getvarn(&dsid, &vn_pred));
22494 +        %let _std  = %sysfunc(getvarn(&dsid, &vn_std));
22495 +        %let _tsid = _TSID&i.;
22496 +        /* create new data set */
22497 +            %if &i = 1 %then %do;
22498 +            data _tmpindata;
22499 +                set &indata;
22500 +                  mu_x = &_pred;
22501 +                  std_x = &_std;
22502 +                  rename predict = mu_y;
22503 +                  rename std = std_y;
22504 +            run;
22505 +        data _tmpout;
22506 +                 set _tmpindata;
22507 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
22508 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
22509 +             &_tsid= (KLD1+KLD2)/2;
22510 +             if &_tsid < 0 then &_tsid = 0;
22511 +                   drop KLD1 KLD2;
22512 +         run;
22513 +             %end;
22514 +         %else %do;
22515 +         data _tmpindata;
22516 +                  set _tmpout;
22517 +                  mu_x = &_pred;
22518 +                  std_x = &_std;
22520 +             run;
22521 +         data _tmpout;
22522 +                 set _tmpindata;
22523 +             KLD1=0.5*(log(std_y**2/std_x**2)+std_x**2/std_y**2+(mu_y-mu_x)**2/std_y**2-1);
22524 +             KLD2=0.5*(log(std_x**2/std_y**2)+std_y**2/std_x**2+(mu_x-mu_y)**2/std_x**2-1);
22525 +             &_tsid= (KLD1+KLD2)/2;
22526 +             if &_tsid < 0 then &_tsid = 0;
22527 +                   drop KLD1 KLD2;
22528 +         run;
22530 +         %end;
22531 +             %let i = %eval(&i+1);
22533 +    %end;
22534 +    %let dsid = %sysfunc(close(&dsid));
22535 +    data &outdata;
22536 +         set _tmpout;
22537 +         drop mu_x mu_y std_x std_y;
22538 +    run;
22539 +%end;
22540 +%mend EM_TSESM_KLD;
22543 +%macro EM_TSESM_MakeOutClusInput(indata=,
22544 +                   target=,
22545 +                   timeid=,
22546 +                   tsidVar=,
22547 +                   percent=,
22548 +                   outlower=,
22549 +                   outupper=,
22550 +                   esmmethod=,
22551 +                   criterion=,
22552 +                   outdata=);
22554 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22556 +  data &outdata(rename=(_NAME_ =_NAMEID_));
22557 +       set &indata;
22558 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
22559 +  %if &esmmethod eq BEST %then %do;
22560 +      mdlID _MODEL_ &criterion
22562 +  %end;
22563 +  ;
22564 +  run;
22566 +  %let dsid=%sysfunc(open(&outdata));
22567 +       %let vn_name =%sysfunc(varnum(&dsid, _TSID_));
22568 +  %let dsid=%sysfunc(close(&dsid));
22570 +  %if &vn_name > 0 %then %do;
22571 +      proc sort data= &outdata; by _TSID_;
22572 +      run;
22573 +      proc sort data = &EM_USER_TSIDMAP ;by _TSID_;
22574 +      run;
22576 +      data &outdata(drop=_NAMEID_);
22577 +           merge &EM_USER_TSIDMAP &outdata;
22578 +           by _TSID_;
22579 +      run;
22580 +  %end;
22581 +  %else %do;
22582 +      proc sort data= &outdata; by _NAMEID_;
22583 +      run;
22584 +      proc sort data = &EM_USER_TSIDMAP ;by _NAMEID_;
22585 +      run;
22586 +      data &outdata(drop=_NAMEID_);
22587 +           merge &EM_USER_TSIDMAP &outdata;
22588 +           by _NAMEID_;
22589 +      run;
22590 +  %end;
22592 +%mend EM_TSESM_MakeOutClusInput;
22594 +%macro EM_TSESM_MakeOutSimInput(indata=,
22595 +                   inoutfor=,
22596 +                   target=,
22597 +                   timeid=,
22598 +                   tsidVar=,
22599 +                   esmmethod=,
22600 +                   criterion=,
22601 +                   outdata=);
22604 +  %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22605 +  %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
22607 +   %let _EndTime = ;
22608 +   %let dsid=%sysfunc(open(&EM_USER_TSMETA));
22609 +   %if &dsid > 0 %then %do;
22610 +   %let vn_end =%sysfunc(varnum(&dsid, END));
22611 +   %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
22612 +   %do %while(^%sysfunc(fetch(&dsid)));
22613 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
22614 +   %end;
22615 +   %let dsid = %sysfunc(close(&dsid));
22616 +   %end;
22618 +   %em_varMacro(name=tsesm_crossid, metadata= &EM_DATA_VARIABLESET, key=NAME,
22619 +       where=%nrbquote(ROLE='CROSSID' and USE ne 'N') , nummacro=tsesm_crossidNum);
22621 +   data _out1;
22622 +       set &indata;
22623 +       DROP _STATUS_ NOBS N NMISS MEAN MIN MAX STDDEV PREDICT LOWER UPPER STD
22624 +           %tsesm_crossid
22625 +   %if &esmmethod eq BEST %then %do;
22626 +      mdlID _MODEL_ &criterion
22627 +   %end;
22628 +   ;
22629 +   run;
22631 +    %let dsid=%sysfunc(open(work._out1));
22632 +    %if &dsid > 0 %then %do;
22633 +      %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
22634 +      %let dsid = %sysfunc(close(&dsid));
22635 +    %end;
22637 +    /*
22638 +    proc print data=_out1(obs=10);
22639 +    run;
22640 +    */
22641 +    %let _existtsid = Y;
22642 +    %if (&vn_tsid = 0)  %then %do;
22643 +    %let _existtsid = N;
22644 +    %goto NO_TSID_SIMINPUT;
22645 +    %end;
22647 +    data _out1;
22648 +        set _out1;
22649 +        where _name_ = "&target";
22650 +    run;
22651 +    %let target2 = &target._;
22652 +    proc transpose data=_out1 out=_out2 prefix=&target2;
22653 +            id _TSID_  ;
22654 +    run;
22655 +    /*
22656 +    proc print data=_out2(obs=11);
22657 +    run;
22658 +    */
22659 +    data _out2;
22660 +       length _index 8.;
22661 +       set _out2;
22662 +       _index=_N_;
22663 +       drop _NAME_ _LABEL_;
22664 +    run;
22667 +   data _out3;
22668 +       length _index 8.;
22669 +        set &inoutfor(where=(_TSID_=1 and &timeid > &_EndTime));
22670 +         _index =_N_;
22671 +        keep &timeid _index;
22673 +   run;
22674 +   /*
22675 +   proc print data=_out2(obs=12);
22676 +   proc print data =_out3(obs=13);
22677 +   run;
22678 +   */
22679 +   data &outdata(drop=_index);
22680 +        merge _out3 _out2;by _index;
22681 +        run;
22684 +  proc transpose data=&outdata out=_tout;
22685 +     id &timeid;
22686 +   run;
22687 +   data _tout;
22688 +        length _TSID_ 8.;
22689 +        set _tout;
22690 +        rename _NAME_= _NAMEID_;
22691 +        _TSID_ = _N_;
22692 +        label _NAME_ = "NAMEID";
22693 +        keep _NAME_ _TSID_;
22695 +   run;
22697 +   data &EM_USER_TSIDMAP;
22698 +        merge  _tout  &EM_USER_TSIDMAP; by _TSID_;
22699 +   run;
22700 +   /*
22701 +   proc print data=_tout(obs=14);
22702 +   run;
22703 +   */
22704 +   proc datasets lib=work nolist;
22705 +      delete  _out1 _tmpout1 _out2 _out3 _tout;
22706 +   run;
22709 +   %NO_TSID_SIMINPUT:
22710 +   %if  &_existtsid eq N %then %do;
22711 +   data &outdata;
22712 +        set &inoutfor(where=(&timeid > &_EndTime));
22713 +   run;
22714 +   %end;
22717 +%mend EM_TSESM_MakeOutSimInput;
22720 +%macro EM_TS_CONVERT_LONG_TO_WIDE(indata=, outdata=, wherevar=, nwherevalue=, targetvar=, timeid=);
22721 +%do i=1 %to &nwherevalue;
22722 +     %if &i = 1 %then %do;
22723 +        data &outdata(drop = &wherevar);
22724 +             set &indata;
22725 +               if &wherevar= &i;
22726 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
22727 +               %else %let newname = &wherevar_&i;
22728 +                rename  &targetvar= &newname;
22729 +                   label &targetvar ="&targetvar._&i";
22730 +           run;
22731 +       %end;
22732 +       %else %do;
22733 +        data _tmp_out(drop = &wherevar);
22734 +             set &indata;
22735 +               if &wherevar= &i;
22736 +                   %if &wherevar = _TSID_ %then %let newname = TSID_&i;
22737 +               %else %let newname = &wherevar_&i;
22738 +                rename  &targetvar= &newname;
22739 +                   label &targetvar ="&targetvar._&i";
22740 +           run;
22741 +             data &outdata;
22742 +                  merge &outdata  _tmp_out; by &timeid;
22743 +         run;
22744 +       %end;
22745 +%end;
22747 +%EM_TS_DELETE_DATA(lib=work, data=_tmp_out);
22749 +%mend EM_TS_CONVERT_LONG_TO_WIDE;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
22751 +/*
22752 +       MACRO: TS Utility macros
22754 +       PURPOSE: TS Utility macros
22755 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
22757 +       HISTORY:
22758 +       NOTE:
22760 +*/
22762 +/*
22763 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
22764 +                          timeid=, timeformat=, timeinformat=);
22765 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
22767 +    %do;
22768 +    %let m_data      = &data;
22769 +    %let m_decdata   = &decdata;
22770 +    %let m_decmeta   = &decmeta;
22771 +    %let m_cmeta     = &cmeta;
22772 +    %let m_outfile   = &outfile;
22773 +    %let m_crossid   = &crossid;
22774 +    %let m_timeid    = &timeid;
22775 +    %let m_timeformat    = &timeformat;
22776 +    %let m_timeinformat    = &timeinformat;
22777 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
22778 +  %end;
22779 +%mend EM_TS_CreateTsMetaDs;
22780 +*/
22781 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
22782 +proc sql;
22783 +      create table _tmp_inds
22784 +      as select distinct &timeid from  &indata;
22785 +quit;
22786 +run;
22787 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
22788 +  id &timeid
22789 +%if &timeinterval ne %then %do;
22790 +    %if &timeformattype eq DATE %then %do;
22791 +        interval=&timeinterval
22792 +    %end;
22793 +    %else %if &timeformattype eq DATETIME  %then %do;
22794 +        %let dttimeinterval= DT&timeinterval;
22795 +         interval=&dttimeinterval
22796 +    %end;
22797 +%end;
22798 +;
22799 +run;
22801 +data &outds;
22802 +     set _tmp_tsmeta;
22803 +     format START &timeformat;
22804 +     format END &timeformat;
22805 +     length APPLY_START_END $8;
22806 +     APPLY_START_END ="No";
22807 +     FORMAT = "&timeformat";
22808 +     ROLE ="TIMEID";
22809 +     rename TIMEID = NAME;
22810 +     rename SEASONALITY= LengthOfCycle;
22811 +     rename INTERVAL = TIMEINTERVAL ;
22812 +     rename FORMAT = TIMEFORMAT;
22813 +     output;
22814 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
22815 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
22816 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
22817 +run;
22819 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
22820 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
22822 +%mend EM_TS_CreateTSMetaData;
22826 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
22828 +/* if updated = Y it will pass the TSMETA created by just the previous node */
22830 +%let _tsmetads = ;
22832 +%if &updated = Y %then %do;
22833 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
22834 +%if %sysfunc(exist(&_tsmetads)) %then %do;
22835 +%goto endline;
22836 +%end;
22837 +%end;
22839 +%if &eminfodata eq %then %do;
22840 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
22841 +    data &EM_DATA_EMINFO;
22842 +         set &EM_IMPORT_DATA_EMINFO;
22843 +    run;
22844 +%end;
22845 +%else %do;
22846 +    %let dsid=%sysfunc(open(&eminfodata));
22847 +    data &EM_DATA_EMINFO;
22848 +         set &eminfodata;
22849 +    run;
22850 +%end;
22851 +%if &dsid > 0 %then %do;
22852 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
22853 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
22854 +    %do %while(^ %sysfunc(fetch(&dsid)));
22855 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
22856 +         %if &_key eq TSMETA %then %do;
22857 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
22858 +         %end;
22859 +    %end;
22860 +    %let dsid = %sysfunc(close(&dsid));
22861 +%end; /* the end of %if &dsid > 0 %then %do; */
22863 +%endline:
22865 +%if &_tsmetads ne %then %do;
22866 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
22867 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
22868 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
22869 +         data &EM_USER_TSMETA;
22870 +                   set &_tsmetads;
22871 +         run;
22872 +    %end;
22873 +%end;
22875 +*proc print data=&EM_DATA_EMINFO;
22876 +*proc print data=&EM_IMPORT_DATA_EMINFO;
22877 +*run;
22878 +%MEND EM_TS_GETTSMETA;
22881 +/*
22882 +%macro EM_GETTSMETAVARS(TimeInterval=);
22883 +%global &TimeInterval;
22884 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
22885 +%if &dsid > 0 %then %do;
22886 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
22887 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
22888 +%do %while(^ %sysfunc(fetch(&dsid)));
22889 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22890 +     %if &_role eq TIMEID %then %do;
22891 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
22892 +     %end;
22893 +%end;
22894 +%let dsid = %sysfunc(close(&dsid));
22895 +%end;
22896 +%MEND EM_GETTSMETAVARS;
22897 +*/
22898 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
22899 +%global &TimeInterval;
22900 +%global &TimeId;
22901 +%global &EndTime;
22902 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
22903 +proc print data=&EM_USER_TSMETA;
22904 +run;
22905 +%if &dsid > 0 %then %do;
22906 +%if &TimeInterval ne %then %do;
22907 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
22908 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
22909 +    %do %while(^ %sysfunc(fetch(&dsid)));
22910 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22911 +        %if &_role eq TIMEID %then %do;
22912 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
22913 +        %end;
22914 +     %end;
22915 +%end;
22916 +%if &TimeId ne %then %do;
22917 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
22918 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
22919 +    %do %while(^ %sysfunc(fetch(&dsid)));
22920 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22921 +        %if &_role eq TIMEID %then %do;
22922 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
22923 +        %end;
22924 +    %end;
22925 +%end;
22927 +%if &EndTime ne %then %do;
22928 +    %let vn_end =%sysfunc(varnum(&dsid, END));
22929 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
22930 +    %do %while(^ %sysfunc(fetch(&dsid)));
22931 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
22932 +        %if &_role eq TIMEID %then %do;
22933 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
22934 +        %end;
22935 +     %end;
22936 +%end;
22937 +%let dsid = %sysfunc(close(&dsid));
22938 +%end;
22939 +%MEND EM_TS_GETTSMETAVARS;
22943 +/*------------------------------------------------------------------
22945 +      Macro EM_GETTSIDMAP
22947 +------------------------------------------------------------------+*/
22950 +%macro EM_TS_GETTSIDMAP(updated=);
22952 +%let _tsidmap = ;
22954 +%if &updated = Y %then %do;
22955 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
22956 +%if %sysfunc(exist(&_tsidmap)) %then %do;
22957 +%goto endline;
22958 +%end;
22959 +%end;
22961 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
22962 +%if &dsid > 0 %then %do;
22963 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
22964 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
22965 +%do %while(^ %sysfunc(fetch(&dsid)));
22966 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
22967 +     %if &_key eq TSIDMAP %then %do;
22968 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
22969 +     %end;
22970 +%end;
22972 +%let dsid = %sysfunc(close(&dsid));
22973 +%end;
22975 +%endline:
22977 +%if &_tsidmap ne %then %do;
22979 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
22980 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
22982 +%if %sysfunc(exist(&_tsidmap)) %then %do;
22983 +         data &EM_USER_TSIDMAP;
22984 +               set &_tsidmap;
22985 +         run;
22986 +    %end;
22987 +%end;
22988 +%MEND EM_TS_GETTSIDMAP;
22990 +/*------------------------------------------------------------------*/
22995 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
22996 +%global &value;
22999 +%let dsid = %sysfunc(open(&data));
23000 +%if &dsid > 0 %then %do;
23001 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
23002 +    %if &vn_var < 1 %then %do;
23003 +        %let &value = 0;
23004 +        %let dsid = %sysfunc(close(&dsid));
23005 +        %goto endline;
23006 +    %end;
23007 +%let dsid = %sysfunc(close(&dsid));
23008 +%end;
23010 +%let _tmp=_tmpDS;
23011 +proc means data=&data &stat;
23012 +     var &var;
23013 +     output out=&_tmp;
23014 +run;
23016 +%let dsid = %sysfunc(open(&_tmp));
23017 +%if &dsid > 0 %then %do;
23018 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
23019 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
23020 +     %do %while(^%sysfunc(fetch(&dsid)));
23021 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
23022 +         %if &_stat eq &stat %then %do;
23023 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
23024 +          %end;
23025 +      %end;
23026 +%let dsid = %sysfunc(close(&dsid));
23027 +%end;
23028 +proc datasets lib=work nolist;
23029 + delete &_tmp;
23030 +run;
23031 +%endline:
23032 +%MEND EM_TS_GET_STAT;
23035 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
23036 +%global &format;
23037 +%global &informat;
23038 +%let dsid = %sysfunc(open(&data));
23039 +%if &dsid > 0 %then %do;
23040 +%let vn_var =%sysfunc(varnum(&dsid, &var));
23041 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
23042 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
23043 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
23044 +%end;
23045 +%let dsid = %sysfunc(close(&dsid));
23046 +%end;
23047 +%MEND EM_TS_GET_VAR_FORMAT;
23049 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
23050 +      %if &lib eq %then %let lib=work;
23051 +       proc datasets lib=&lib nolist;
23052 +              delete &dsname;
23053 +       run;
23054 +%Mend  EM_TS_DELETE_DATA;
23057 +%macro EM_TS_GetNObs(inds=, nobs=);
23058 +    %global &nobs;
23059 +    %let &nobs=0;
23060 +    data _null_;
23061 +        set &inds end=eof;
23062 +        if eof then call symput("&nobs", _N_);
23063 +    run;
23064 +    quit;
23066 +    /*
23067 +    %let dsid=%sysfunc(open(&outdata));
23068 +    %if dsid > 0 %then %do;
23069 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
23070 +        %let dsid = %sysfunc(close(&dsid));
23071 +     %end;
23072 +    */
23073 +%mend  EM_TS_GetNObs;
23076 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
23077 +%global &time1;
23078 +%global &time2;
23079 +%if &default = Y %then %do;
23080 +   data _null_;
23081 +        set &data end=eof;
23082 +        if _N_ = 1 then  call symput("&time1", DATE);
23083 +        if eof then call symput("&time2", DATE);
23084 +    run;%end;
23085 +%else %do;
23086 +    %let dsid = %sysfunc(open(&data));
23087 +    %if &dsid > 0 %then %do;
23088 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
23089 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
23090 +        %do %while(^%sysfunc(fetch(&dsid)));
23091 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
23092 +             %if &_index eq 1 %then %do;
23093 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
23094 +             %end;
23095 +             %if &_index eq 2 %then %do;
23096 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
23097 +             %end;
23098 +        %end;
23099 +    %let dsid = %sysfunc(close(&dsid));
23100 +    %end;
23101 +%end;
23103 +%MEND EM_TS_GET_TIME_VALUES;
23105 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
23106 +%global &exist;
23107 + %let &exist = N;
23108 +%let dsid = %sysfunc(open(&data));
23109 +%if &dsid > 0 %then %do;
23110 +%let vn_var =%sysfunc(varnum(&dsid, &var));
23111 +%if &vn_var > 0 %then %do;
23112 +    %let &exist = Y;
23113 +%end;
23114 +%let dsid = %sysfunc(close(&dsid));
23115 +%end;
23116 +%MEND EM_TS_GET_VAR_EXIST;
23119 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
23120 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
23121 +      set &intreedata;
23122 +        LENGTH NodeType $32;
23123 +      if _PARENT_ eq " " then delete;
23124 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
23125 +        else NodeType = "CLUSTER";
23126 +        LinkID = _N_;
23127 +run;
23128 +%Mend EM_TS_MakeConstellPlotData;
23133 +%macro EM_TS_CreateIDMap(
23134 +/*-------------------------------------------------------------------------*/
23135 +/*---   Written by Xiangxiang Meng                                         */
23136 +/*-------------------------------------------------------------------------*/
23137 +inDS          =,      /* imported data set in TS data mining               */
23138 +outIDMap      =,      /* output data set of TS ID map                      */
23139 +outDS         =,      /* output data set of TS and TS ID merged            */
23140 +variableSet   =,      /* EM variable set                                   */
23141 +TSIDbyCrossID =Y,
23142 +inEM          =Y
23143 +/*-------------------------------------------------------------------------*/
23144 +);
23146 +%global EM_TS_ERR;
23147 +%let EM_TS_ERR = 0;
23149 +%if &inEM eq Y %then %do;
23150 +    %let num_crossIDVar = &EM_NUM_CROSSID;
23151 +    proc sql noprint;
23152 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
23153 +    quit;
23154 +%end;
23155 +%else %do;
23156 +    proc sql noprint;
23157 +         select count(*) into :num_crossIDVar from &variableSet
23158 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23159 +         ;
23160 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
23161 +         ;
23162 +    quit;
23163 +    %let num_crossIDVar=&num_crossIDVar;
23164 +%end;
23166 +* see if _TSID_ exists;
23168 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
23169 +run;
23171 +proc sql noprint;
23172 +    select count(*) into :has_TSID
23173 +        from _emtscm_contents
23174 +        where upcase(strip(name)) eq '_TSID_'
23175 +    ;
23176 +quit;
23178 +/*-------------------------------------------------------------------------*/
23179 +* Creating TSID map..;
23180 +/*-------------------------------------------------------------------------*/
23182 +%if (&num_crossIDVar gt 0) %then %do;
23184 +    data _emtscm_tmpIDMap;
23185 +        set &variableSet;
23186 +        where  (upcase(strip(level)) eq 'INTERVAL')
23187 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
23188 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
23189 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
23190 +          );
23191 +        _emts_dummy=1;
23192 +        keep name label role _emts_dummy;
23193 +    run;
23195 +    proc sql noprint;
23196 +        * create a string of crossID variable like A,B,C,D..;
23197 +        select distinct name into :crossIDVar separated by ','
23198 +            from &variableSet
23199 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23200 +            order by name
23201 +        ;
23202 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
23203 +            from &variableSet
23204 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23205 +            order by name
23206 +        ;
23207 +        * create the TSID map data set;
23208 +        create table _emtscm_tmp1 as
23209 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
23210 +        ;
23211 +        * create a level list of cross ID variables and time series variables;
23212 +        create table &outIDMap as
23213 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
23214 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
23215 +            where a._emts_dummy eq b._emts_dummy
23216 +            order by a.name, &crossIDVar
23217 +        ;
23218 +    quit;
23220 +    %if &TSIDbyCrossID = Y %then %do;
23221 +        * create unique TSID only by Cross ID;
23222 +        data &outIDMap;
23223 +            length _TSID_ 8;
23224 +            set &outIDMap;
23225 +            by _NAMEID_;
23226 +            if first._NAMEID_
23227 +                then _TSID_=1;
23228 +                else _TSID_+1;
23229 +        run;
23230 +        %if "&outDS" ne "" %then %do;
23231 +            * merge TSID into &inDS;
23232 +            proc sql noprint;
23233 +                create table &outDS as
23234 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
23235 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
23236 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
23237 +                        where %do i = 1 %to &num_crossIDVar;
23238 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
23239 +                              %end;
23240 +                             b._TSID_ is not missing
23241 +                    order by b._TSID_, a.&timeIDVar
23242 +                ;
23243 +            quit;
23244 +        %end;
23245 +    %end;
23246 +    %else %do;
23247 +        * create unique TSID by Cross ID and _NAMEID_;
23248 +        data &outIDMap;
23249 +            length _TSID_ 8;
23250 +            set &outIDMap;
23251 +            _TSID_=_n_;
23252 +        run;
23253 +        %if "&outDS" ne "" %then %do;
23254 +            *no merge in this output;
23255 +            data &outDS;
23256 +                set &inDS;
23257 +            run;
23258 +        %end;
23259 +    %end;
23261 +    proc sort data=&outIDMap;
23262 +        by _NAMEID_ _TSID_;
23263 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
23264 +        format _TSID_ best12. _NAMEID2_ $40.;
23265 +        set &outIDMap;
23266 +        by _NAMEID_;
23267 +        if first._NAMEID_
23268 +            then _emts_ind=1;
23269 +            else _emts_ind+1;
23270 +        drop _emts_ind;
23271 +        rename _NAMEID_=_VARNAME_;
23272 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
23273 +        if _labelID_ eq ' '
23274 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
23275 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
23276 +    run;
23278 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
23280 +%end;
23281 +%else %do; /* if no crossid's the nameid needs to be created */
23283 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
23284 +        length _TSID_ 8;
23285 +        set &variableSet;
23286 +        where  (upcase(strip(level)) eq 'INTERVAL')
23287 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
23288 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
23289 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
23290 +          );
23291 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
23292 +        rename ROLE = _ROLE_;
23293 +        _NAMEID_=strip(name);
23294 +        _VARNAME_=strip(name);
23295 +        if label eq ' '
23296 +            then _LABELID_ = strip(name);
23297 +            else _LABELID_ = strip(label);
23298 +        _TSID_=_n_;
23299 +    run;
23301 +    %if "&outDS" ne "" %then %do;
23302 +        *no merge in this output;
23303 +        data &outDS;
23304 +            set &inDS;
23305 +        run;
23306 +    %end;
23307 +%end;
23309 +data &outIDMap;
23310 +    set &outIDMap;
23311 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
23312 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
23313 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
23314 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
23315 +run;
23317 +proc datasets lib=work nolist;
23318 +    delete _emtscm_:;
23319 +run; quit;
23321 +%mend EM_TS_createIDMap;
23323 +%macro EM_TS_CreateMetaData(
23324 +/*-------------------------------------------------------------------------*/
23325 +  inDS          =,      /* imported data set in TS data mining             */
23326 +  outDS         =,      /* output data set of TS metadata                  */
23327 +  variableSet   =,      /* EM variable set                                 */
23328 +  timeInterval  =,      /* time interval                                   */
23329 +  rc            =       /* return code                                     */
23330 +/*-------------------------------------------------------------------------*/
23331 +);
23333 +%if %eval(
23334 +      &EM_NUM_BINARY_INPUT   +
23335 +      &EM_NUM_ORDINAL_INPUT  +
23336 +      &EM_NUM_NOMINAL_INPUT  +
23337 +      &EM_NUM_BINARY_REJECTED   +
23338 +      &EM_NUM_ORDINAL_REJECTED  +
23339 +      &EM_NUM_NOMINAL_REJECTED  +
23340 +      &EM_NUM_ORDINAL_TARGET  +
23341 +      &EM_NUM_NOMINAL_TARGET +
23342 +      &EM_NUM_BINARY_TARGET
23343 +      ) > 0
23344 +%then %do;
23345 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
23346 +        %put &em_codebar;
23347 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
23348 +        %put &errormsg;
23349 +        %put &em_codebar;
23350 +        %goto ENDLINE;
23351 +%end;
23353 +%global EM_TS_ERR;
23354 +%let EM_TS_ERR = 0;
23356 +%if &timeInterval eq AUTO
23357 +    %then %let timeInterval  = ;
23358 +    %else %let timeInterval  = %upcase(&timeInterval);
23360 +/*-------------------------------------------------------------------------*/
23361 +* check time ID variable;
23362 +/*-------------------------------------------------------------------------*/
23364 +* number of variables in the Variableset with ROLE=TIMEID;
23365 +proc sql noprint;
23366 +    select count(*) into :num_timeID from &variableset
23367 +        where upcase(role) eq 'TIMEID';
23368 +quit;
23370 +/*-------------------------------------------------------------------------*/
23371 +* process only when there is one Time ID, otherwise exception message;
23372 +/*-------------------------------------------------------------------------*/
23374 +%if &num_timeID eq 0 %then %do;
23376 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
23377 +    %let EM_TS_ERR = 11;
23378 +    %put &em_codebar;
23379 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
23380 +    %put &errormsg;
23381 +    %put &em_codebar;
23382 +    %goto tscm_endline;
23384 +%end;
23385 +%else %if &num_timeID gt 1 %then %do;
23387 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
23388 +    %let EM_TS_ERR = 12;
23389 +    %put &em_codebar;
23390 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
23391 +    %put &errormsg;
23392 +    %put &em_codebar;
23393 +    %goto tscm_endline;
23395 +%end;
23396 +%else %do;
23397 +    *** proceed when there is one Time ID;
23399 +    data _null_;
23400 +        set &variableset(where=(upcase(role)='TIMEID'));
23401 +        call symput('timeIDFormat',     strip(format));
23402 +        call symput('timeID',           strip(upcase(name)      ));
23403 +        call symput('timeIDLevel',      strip(upcase(level))     );
23404 +        call symput('timeIDFormatType', strip(upcase(formattype)));
23405 +    run;
23407 +    *** exception message if the time ID is not an interval variable;
23408 +    %if &timeIDLevel ne INTERVAL %then %do;
23409 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
23410 +        %let EM_TS_ERR = 13;
23411 +        %put &em_codebar;
23412 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
23413 +        %put &errormsg;
23414 +        %put &em_codebar;
23415 +        %goto tscm_endline;
23416 +    %end;
23418 +    %if (&timeIDFormatType ne DATETIME) and
23419 +        (&timeIDFormatType ne DATE) and
23420 +        (&timeIDFormatType ne TIME) and
23421 +        (&timeIDFormatType ne USER)
23422 +    %then %do;
23423 +        *** sequential format-type of time ID;
23425 +        %let timeInterval = DAY;
23426 +        %let timeIDFormatType = SEQ;
23428 +        proc sql noprint;
23429 +            create table _emtscm_inds as
23430 +                 select distinct &timeID from &inDS(keep=&timeID)
23431 +                 where &timeID is not missing;
23432 +            select count(*) into :num_nonInteger from _emtscm_inds
23433 +                where &timeID ne int(&timeID);
23434 +        quit;
23436 +        %if &num_nonInteger gt 0 %then %do;
23437 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
23438 +            %let EM_TS_ERR = 14;
23439 +            %put &em_codebar;
23440 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
23441 +            %put &errormsg;
23442 +            %put &em_codebar;
23443 +            %goto tscm_endline;
23444 +        %end;
23445 +    %end;
23446 +    %else %do;
23447 +        *** date, datetime, time format-type of time ID;
23449 +        *** must have a format;
23450 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
23451 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
23452 +            %let EM_TS_ERR = 15;
23453 +            %put &em_codebar;
23454 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
23455 +            %put &errormsg;
23456 +            %put &em_codebar;
23457 +            %goto tscm_endline;
23458 +        %end;
23460 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
23461 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
23462 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
23463 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
23464 +                %let EM_TS_ERR = 16;
23465 +                %put &em_codebar;
23466 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
23467 +                %put &errormsg;
23468 +                %put &em_codebar;
23469 +                %goto tscm_endline;
23470 +            %end;
23471 +        %end;
23473 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
23474 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
23475 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
23476 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
23477 +                %let EM_TS_ERR = 17;
23478 +                %put &em_codebar;
23479 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
23480 +                %put &errormsg;
23481 +                %put &em_codebar;
23482 +                %goto tscm_endline;
23483 +            %end;
23484 +        %end;
23486 +        *** the AUTO function is currently turned off for TIME timeID variable;
23487 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
23488 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
23489 +            %let EM_TS_ERR = 18;
23490 +            %put &em_codebar;
23491 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
23492 +            %put &errormsg;
23493 +            %put &em_codebar;
23494 +            %goto tscm_endline;
23495 +        %end;
23497 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
23498 +            %then %let timeInterval =DT&timeInterval;
23500 +        proc sql noprint;
23501 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
23502 +                where &timeID is not missing;
23503 +        quit;
23504 +    %end;
23506 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
23507 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
23508 +    run;
23510 +    %let hasValidInterval = 0;
23511 +    %let hasLengthOne     = 0;
23513 +    proc sql noprint;
23514 +        create table _emtscm_label as
23515 +            select name,label
23516 +            from dictionary.columns
23517 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
23518 +        ;
23519 +        create table _emtscm_meta2 as
23520 +            select a.*, b.label
23521 +            from _emtscm_meta as a, _emtscm_label as b
23522 +            where upcase(a.timeID) eq upcase(b.name)
23523 +        ;
23524 +    quit;
23526 +    data &outDS;
23527 +        set _emtscm_meta2;
23528 +        format
23529 +            timeformat      $30.
23530 +            role            $10.
23531 +            start           &timeIDformat
23532 +            end             &timeIDformat
23533 +            apply_start_end $8.
23534 +        ;
23535 +        rename
23536 +            timeID      = name
23537 +            seasonality = lengthOfCycle
23538 +            interval    = timeinterval
23539 +        ;
23540 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
23542 +        role            = "TIMEID";
23543 +        apply_start_end = 'N';
23544 +        timeformat      = symget('timeIDformat');
23545 +        timeformattype  = symget('timeIDformatType');
23547 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
23548 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
23549 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
23550 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
23551 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
23552 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
23553 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
23554 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
23555 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
23556 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
23558 +        if timeformattype eq 'SEQ' then do;
23559 +            timeformat='BEST12.';
23560 +            seasonality=1;
23561 +        end;
23563 +        call symput('_tinterval',interval);
23565 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
23567 +        if upcase(timeformattype) eq 'DATE' and
23568 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
23569 +            then call symput('hasValidInterval',1);
23571 +        if upcase(timeformattype) eq 'DATETIME' and
23572 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
23573 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
23574 +            then call symput('hasValidInterval',1);
23576 +        if upcase(timeformattype) eq 'TIME' and
23577 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
23578 +            then call symput('hasValidInterval',1);
23580 +        if upcase(timeformattype) eq 'SEQ'
23581 +            then call symput('hasValidInterval',1);
23583 +        if upcase(timeformattype) eq 'USER'
23584 +            then call symput('hasValidInterval',1);
23586 +        if start eq end
23587 +            then call symput('hasLengthOne',1);
23588 +    run;
23590 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
23592 +    *** detect any missing time interval after running PROC TIMEID;
23593 +    %if &_tinterval eq %then %do;
23594 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
23595 +        %let EM_TS_ERR = 19;
23596 +        %put &em_codebar;
23597 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
23598 +        %put &errormsg;
23599 +        %put &em_codebar;
23600 +        %goto tscm_endline;
23601 +    %end;
23603 +    *** detect any missing time interval after running PROC TIMEID;
23604 +    %if &hasValidInterval eq 0 %then %do;
23605 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
23606 +        %let EM_TS_ERR = 20;
23607 +        %put &em_codebar;
23608 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
23609 +        %put &errormsg;
23610 +        %put &em_codebar;
23611 +        %goto tscm_endline;
23612 +    %end;
23614 +    %if &hasLengthOne eq 1 %then %do;
23615 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
23616 +        %let EM_TS_ERR = 21;
23617 +        %put &em_codebar;
23618 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
23619 +        %put &errormsg;
23620 +        %put &em_codebar;
23621 +        %goto tscm_endline;
23622 +    %end;
23624 +%end;
23626 +%tscm_endline:;
23628 +%mend EM_TS_CreateMetaData;
23631 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
23633 +data _null_;
23634 +    set &tsmeta;
23635 +    call symput('_timeidFormatType', timeformattype);
23636 +    call symput('_timeid', strip(name));
23637 +    call symput('_seqstartnum',strip(put(start,best12.)));
23638 +run;
23640 +proc contents data=&inDS noprint
23641 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
23642 +run; quit;
23644 +data _null_;
23645 +    set _emts_tmpp1;
23646 +    call symput('_timeIDlabel',label);
23647 +run;
23649 +%if &_timeidFormatType eq SEQ
23650 +%then %do;
23651 +    proc sql noprint;
23652 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
23653 +    quit;
23654 +    %let _dummystarttime=&_dummystarttime;
23656 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
23657 +        set &inDS;
23658 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
23659 +        drop &_timeid;
23660 +        label _tsdp_tmpID = "&_timeIDlabel";
23662 +    run;
23663 +%end;
23665 +%mend;
23667 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
23669 +data _null_;
23670 +    set &tsmeta;
23671 +    call symput('_timeidFormatType', timeformattype);
23672 +    call symput('_timeidFormat', timeformat);
23673 +    call symput('_timeid', strip(name));
23674 +    call symput('_timeinterval',strip(upcase(timeinterval)));
23675 +run;
23677 +/* manually change time ID format to a longer enough time format */
23678 +/* because proc timeid returns time5. for second time interval */
23679 +/* which is not long enough for transpose with time unit as seconds */
23680 +%if &_timeinterval eq SECOND
23681 +%then %do;
23682 +    %let _timeIDformat = %str(time8.);
23683 +%end;
23685 +proc contents data=&inDS noprint
23686 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
23687 +run; quit;
23689 +data _null_;
23690 +    set _emts_tmpp1;
23691 +    call symput('_timeIDlabel',label);
23692 +run;
23694 +%if &_timeidFormatType eq TIME
23695 +%then %do;
23696 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
23697 +        set &inDS;
23698 +        _tsdp_tmpID = timepart(&_timeID);
23699 +        format _tsdp_tmpID &_timeidFormat;
23700 +        label  _tsdp_tmpID = "&_timeIDlabel";
23701 +        drop &_timeid;
23702 +    run;
23703 +%end;
23705 +%mend;
23707 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
23709 + proc sql noprint;
23710 +     create table _tmptimetable as
23711 +         select distinct &timeidvar as DATE from &inDS
23712 +         where &timeIDVar is not missing
23713 +         order by &timeIDVar;
23714 + quit;
23716 +%if &compare eq Y %then %do;
23717 +    * compare with the existing time table;
23718 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
23719 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
23720 +    run;
23722 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
23724 +    %if &_diffobs > 0 %then %do; /* create it again */
23725 +        data &outDS(keep=DATE _INDEX_);
23726 +            set _tmptimetable end = _eof_;
23727 +            if _N_ = 1
23728 +                then _INDEX_ = 1;
23729 +                else _INDEX_ = 0;
23730 +            if _eof_ then _INDEX_= 2;
23731 +        run;
23732 +    %end;
23734 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
23735 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
23736 +%end;
23737 +%else %do;
23738 +    * create a new time table directly;
23739 +    data &outDS(keep=DATE _INDEX_);
23740 +        set _tmptimetable end = _eof_;
23741 +        if _N_ = 1
23742 +            then _INDEX_ = 1;
23743 +            else _INDEX_ = 0;
23744 +        if _eof_ then _INDEX_= 2;
23745 +    run;
23747 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
23748 +%end;
23750 +* assign a defult format BEST12. for sequential time ID;
23752 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
23754 +%let _nodatefmt=N;
23756 +data _null_;
23757 +    set _tmpcontents;
23758 +    where upcase(name) eq 'DATE';
23759 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
23760 +run;
23762 +%if "&_nodatefmt" eq "Y" %then %do;
23763 +    data &outDS;
23764 +        set &outDS;
23765 +        format date best12.;
23766 +    run;
23767 +%end;
23769 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
23771 +%mend;
23775 +%macro EM_TS_Transpose(
23776 +/*-------------------------------------------------------------------------*/
23777 +  inDS          =,      /* imported data set in TS data mining             */
23778 +  inIDMap       =,      /* input TS ID map                                 */
23779 +  variableSet   =,      /* variable set                                    */
23780 +  transposeBy   =,      /* byTSID or byTimeID                              */
23781 +  outDS         =,      /* output transposed data set                      */
23782 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
23783 +  inEM          =Y,
23784 +  timePrefix    =_T
23785 +/*-------------------------------------------------------------------------*/
23786 +);
23788 +%let timePrefix = &timePrefix;
23790 +%if  &EM_NUM_CROSSID > 0 %then %do;
23792 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
23793 +    set &inIDMap;
23794 +    drop _NAMEID_;
23795 +    run;
23796 +%let inIDMap=_emtstp_map0;
23798 +%end;
23800 +proc sql noprint;
23801 +    * number of TS Variables to be transposed;
23802 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
23803 +    ;
23804 +    * number of TS Variables to be transposed;
23805 +    select max(_TSID_) into :num_TSID from &inIDMap
23806 +    ;
23807 +    * name list of TS Variables;
23808 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
23809 +        from &inIDMap
23810 +        order by _NAMEID_
23811 +    ;
23812 +    * total number of time series =max(_TSID_)*&num_TSVar;
23813 +    * and the number of digits of this variable is &num_digits;
23814 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
23815 +        from &inIDMap
23816 +    ;
23817 +      * Time ID variable;
23818 +    select name into:timeIDVar from &variableset
23819 +        where upcase(role) eq 'TIMEID'
23820 +    ;
23821 +quit;
23822 +%let num_digits = &num_digits;
23823 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
23825 +/*-------------------------------------------------------------------------*/
23827 +* get number of cross IDs and also the TIME ID variable name;
23828 +%if &inEM eq Y %then %do;
23829 +    %let num_crossIDVar = &EM_NUM_CROSSID;
23830 +    %let crossIDVar     = %EM_CROSSID;
23831 +%end;
23832 +%else %do;
23833 +    proc sql noprint;
23834 +        * number of cross ID;
23835 +        select count(*) into :num_crossIDVar
23836 +            from &variableSet
23837 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23838 +        ;
23839 +        * create a string of crossID variable like A B C D..;
23840 +        select distinct name into :crossIDVar separated by ' '
23841 +            from &variableSet
23842 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
23843 +            order by name
23844 +        ;
23845 +    quit;
23846 +    %let num_crossIDVar=&num_crossIDVar;
23847 +%end;
23849 +/*-------------------------------------------------------------------------*/
23851 +%if (&num_crossIDVar gt 0) %then %do;
23853 +    data _emtstp_tmpDat;
23854 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
23855 +        _NAMEID_ = cats("_TS_",_TSID_);
23856 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
23857 +    run;
23859 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
23861 +        * update the ID maps;
23862 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
23863 +            by _NAMEID_ _TSID_;
23864 +        data &outIDMap;
23865 +            set _emtstp_tmpmap;
23866 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
23867 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
23868 +        run;
23870 +        * get the names for the new variables;
23871 +        proc sql noprint;
23872 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
23873 +            ;
23874 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
23875 +            ;
23876 +        quit;
23878 +        * data must be sorted before transposed;
23879 +        proc sort data=_emtstp_tmpDat;
23880 +            by &timeIDvar;
23881 +        run;
23883 +        %do i = 1 %to &num_TSVar;
23884 +            %let i = &i;
23885 +            * transpose one cross-type time series data by TSID;
23886 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
23887 +                id _NAMEID_;
23888 +                by &timeIDVar;
23889 +                var &&&TSVar&i;
23890 +            run;
23891 +        %end;
23893 +        * merge all vertical time series, rename and label them;
23894 +        data &outDS;
23895 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
23896 +            by &timeIDVar;
23897 +            rename
23898 +                %do i = 1 %to &num_TSVar;
23899 +                    %do j = 1 %to &num_TSID;
23900 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
23901 +                        /* %put &i &j &num1 &num_TSID; */
23902 +                        _V_&i._TS_&j = &&&tsname&num1
23903 +                    %end;
23904 +                %end;
23905 +            ;
23906 +            label
23907 +                %do i = 1 %to &num_TSVar;
23908 +                    %do j = 1 %to &num_TSID;
23909 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
23910 +                        /* %put &i &j &num1 &num_TSID; */
23911 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
23912 +                    %end;
23913 +                %end;
23914 +            ;
23915 +        run;
23916 +    %end;
23917 +    %else %do;
23919 +        * update the ID maps;
23920 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
23921 +            by _NAMEID_ _TSID_;
23922 +        data &outIDMap;
23923 +            set _emtstp_tmpmap;
23924 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
23925 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
23926 +        run;
23928 +        proc sql noprint;
23929 +            * get the roles for the new variables;
23930 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
23931 +                from &inIDMap
23932 +                order by _NAMEID_
23933 +            ;
23934 +            * get the length of the time series;
23935 +            select count(distinct &timeIDvar) into :num_T
23936 +                from _emtstp_tmpDat
23937 +            ;
23938 +        quit;
23940 +        * data must be sorted before transposed;
23941 +        proc sort data=_emtstp_tmpDat;
23942 +            by _TSID_ &crossIDVar &timeIDvar;
23943 +        run;
23945 +        %do i = 1 %to &num_TSVar;
23946 +            %let i = &i;
23947 +            * transpose one cross-type time series data by TIMEID;
23948 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
23949 +                by _TSID_ &crossIDVar;
23950 +                var &&&TSVar&i;
23951 +            run;
23952 +        %end;
23954 +        * stack all horizontal time series;
23955 +        data &outDS;
23956 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
23957 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
23958 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
23959 +            %do i=1 %to &num_TSVar;
23960 +                if in&i then do;
23961 +                    _NAMEID_ ="&&&TSVar&i";
23962 +                    _ROLE_   ="&&&TSRole&i";
23963 +                end;
23964 +            %end;
23965 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
23966 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
23967 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
23968 +        run;
23969 +    %end;
23970 +%end;
23971 +%else %do;
23973 +    proc sql noprint;
23974 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
23975 +            order by _NAMEID_
23976 +        ;
23977 +    quit;
23979 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
23980 +        * transpose the panel-type time series data by TSID;
23981 +        proc sort data=&inDS out=_emtstp_tmpDat;
23982 +            by &timeIDvar;
23983 +        proc transpose data=_emtstp_tmpDat
23984 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
23985 +            by &timeIDVar;
23986 +            var &panelTSVar;
23987 +        run;
23988 +        proc datasets lib=work nolist;
23989 +            modify _emtstp_tmpDat2;
23990 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
23991 +            run; quit;
23992 +    %end;
23993 +    %else %do;
23994 +        * transpose the panel-type time series data by TIMEID;
23995 +        proc sort data=&inDS out=_emtstp_tmpDat;
23996 +            by &timeIDvar;
23997 +        data _emtstp_tmpDat;
23998 +            set _emtstp_tmpDat;
23999 +            _tmp_ind=_n_;
24000 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
24001 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
24002 +            ID _tmp_ind;
24003 +            var &panelTSVar;
24004 +        run;
24005 +    %end;
24007 +      * merge ID maps to the transpose data set;
24008 +      proc sql noprint;
24009 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
24010 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
24011 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
24012 +          ;
24013 +      quit;
24015 +      * update the TS ID map;
24016 +      data &outIDMap;
24017 +          set &inIDMap;
24018 +      run;
24019 +%end;
24021 +proc datasets lib=work nolist;
24022 +    delete _emtstp:;
24023 +run; quit;
24025 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSESM_REPORT.SOURCE.
24027 +/*----------------------------------------------------------------------------------+
24028 + |
24029 + |   Title :  TS Forecating Node
24030 + |
24031 + |
24032 + |   SUPPORT: Taiyeong Lee (Taiyeong.Lee@sas.com)
24033 + |
24034 + +-----------------------------------------------------------------------------------*/
24036 +%macro EM_TSESM_REPORT;
24038 +    %EM_GETNAME(KEY=OUTEST, TYPE=DATA);
24039 +    %EM_GETNAME(KEY=OUTDATA, TYPE=DATA);
24040 +    %EM_GETNAME(KEY=OUTFOR, TYPE=DATA);
24041 +    %EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
24042 +    %EM_GETNAME(KEY=OUTFORCST, TYPE=DATA);
24043 +    %EM_GETNAME(KEY=OUTSUM, TYPE=DATA);
24044 +    %EM_GETNAME(KEY=OUTSTAT, TYPE=DATA);
24045 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
24046 +    %EM_GETNAME(KEY=OUTCOMPFCST, TYPE=DATA);
24047 +    %EM_GETNAME(KEY=FORCSTPLOTDS, TYPE=DATA);
24048 +    %EM_GETNAME(KEY=OUTLIERDS, TYPE=DATA);
24049 +    %EM_GETNAME(KEY=OUTSUMPLOT, TYPE=DATA);
24051 +    %EM_REPORT(key=OUTEST,    view=1, viewtype=DATA, block=MODEL, autodisplay=N, description=tsparaest ) ;
24052 +    %EM_REPORT(key=OUTSTAT,   view=2, viewtype=DATA, block=MODEL, autodisplay=N, description=tsfitstat) ;
24053 +    %EM_REPORT(key=TSIDMAP,   view=3, viewtype=DATA, block=MODEL, autodisplay=N, description=tsidmaptable) ;
24054 +    %EM_REPORT(key=OUTLIERDS, view=4, viewtype=DATA, block=MODEL, autodisplay=N, description=tsoutliertable) ;
24055 +    %EM_REPORT(key=TSMETA,    view=5, viewtype=DATA, block=MODEL, autodisplay=N, description=tsmetatable) ;
24057 +    %let viewnum=6;
24059 +    %let _num_inputs = %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED);
24061 +    %if %EM_CROSSID eq %then %goto SKIP_HISTOGRAM;  /* panel data */
24063 +    %EM_GETNAME(key=OUTSUMHIST, type=DATA);
24064 +    %EM_GETNAME(key=OUTFCSTHIST, type=DATA);
24066 +    %let _varlist1=LOWER PREDICT UPPER;
24067 +    %let _varlist2=;
24068 +    %do k=1 %to &EM_PROPERTY_FCLEAD;
24069 +         %let _varlist2 = &_varlist2. _LEAD&k._ ;
24070 +    %end;
24071 +    %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24072 +           %let j=1;
24073 +           %do %while(%scan(%EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED, &j) ne );
24074 +               %let _var=%scan(%EM_INTERVAL_INPUT, &j);
24075 +               data _tmp_OUTSUM;
24076 +                    set  &EM_USER_OUTSUM;
24077 +                    if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then output;
24078 +               run;
24079 +               %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=_tmp_OUTSUMHIST, VARS=&_varlist1, NUMBARS=10);
24080 +               %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=_tmp_OUTFCSTHIST, VARS=&_varlist2, NUMBARS=10);
24081 +               %if &j=1 %then %do;
24082 +                   data &EM_USER_OUTSUMHIST;
24083 +                        length _VARNAME_  $32;
24084 +                        set   _tmp_OUTSUMHIST;
24085 +                        _VARNAME_="&_var";
24086 +                        label _VARNAME_ = "Variable Name";
24087 +                   run;
24088 +                   data &EM_USER_OUTFCSTHIST ;
24089 +                        length _VARNAME_  $32;
24090 +                         set _tmp_OUTFCSTHIST;
24091 +                          _VARNAME_="&_var";
24092 +                        label _VARNAME_ = "Variable Name";
24093 +                   run;
24094 +                %end;
24095 +                %else %do;
24096 +                   data  _tmp_OUTSUMHIST;
24097 +                        length _VARNAME_  $32;
24098 +                        set   _tmp_OUTSUMHIST;
24099 +                        _VARNAME_="&_var";
24100 +                        label _VARNAME_ = "Variable Name";
24101 +                   run;
24102 +                   data &EM_USER_OUTSUMHIST;
24103 +                        set &EM_USER_OUTSUMHIST  _tmp_OUTSUMHIST;
24104 +                   run;
24105 +                   data _tmp_OUTFCSTHIST ;
24106 +                        length _VARNAME_  $32;
24107 +                         set _tmp_OUTFCSTHIST;
24108 +                          _VARNAME_="&_var";
24109 +                        label _VARNAME_ = "Variable Name";
24110 +                   run;
24111 +                   data &EM_USER_OUTFCSTHIST ;
24112 +                        set &EM_USER_OUTFCSTHIST _tmp_OUTFCSTHIST ;
24113 +                   run;
24115 +                %end;
24116 +               %let j=%eval(&j+1);
24117 +           %end;
24119 +    %end;
24120 +    %else %do;
24121 +        /* Since we allow only one targt at this version */
24122 +        %let _var=%EM_TARGET;
24123 +        data _tmp_OUTSUM;
24124 +            set  &EM_USER_OUTSUM;
24125 +            if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then output;
24126 +        run;
24127 +        %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=&EM_USER_OUTSUMHIST, VARS=&_varlist1, NUMBARS=10);
24128 +        %VAR_PROFILE(DATA=_tmp_OUTSUM, OUTPUT=&EM_USER_OUTFCSTHIST, VARS=&_varlist2, NUMBARS=10);
24130 +        /*
24131 +        %VAR_PROFILE(DATA=&EM_USER_OUTSUM, OUTPUT=&EM_USER_OUTSUMHIST, VARS=&_varlist1, NUMBARS=10);
24132 +        %VAR_PROFILE(DATA=&EM_USER_OUTSUM, OUTPUT=&EM_USER_OUTFCSTHIST, VARS=&_varlist2, NUMBARS=10);
24133 +        */
24134 +    %end;
24136 +    data &EM_USER_OUTSUMHIST;
24137 +         set &EM_USER_OUTSUMHIST;
24138 +         label value="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_forecastsum, noquote))";
24139 +         label Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_histogram, noquote))";
24140 +         label Percent="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_percent, noquote))";
24141 +         if strip(upcase(Variable)) eq "UPPER" then Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_upper,noquote))";
24142 +         if strip(upcase(Variable)) eq "PREDICT" then Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_predict,noquote))";
24143 +         if strip(upcase(Variable)) eq "LOWER" then Variable="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lower,noquote))";
24144 +         %if &_seriesFormat ^= %then %do;
24145 +            format VALUE &_seriesFormat;
24146 +         %end;
24147 +    run;
24150 +    data &EM_USER_OUTFCSTHIST;
24151 +         set &EM_USER_OUTFCSTHIST;
24152 +         length vlabel $100;
24153 +         %do k=1 %to &EM_PROPERTY_FCLEAD;
24154 +             %let _leadvar = _LEAD&k._ ;
24155 +             if upcase(strip(Variable)) ="&_leadvar" then vlabel= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_stepahead_forecast, noquote, &k))";
24156 +         %end;
24157 +         output;
24158 +         label value="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_forecast, noquote))";
24159 +         label vlabel="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_histogram, noquote))";
24160 +         label Percent="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_percent, noquote))";
24161 +         %if &_seriesFormat ^= %then %do;
24162 +            format VALUE &_seriesFormat;
24163 +         %end;
24164 +    run;
24166 +    %SKIP_HISTOGRAM:
24169 +    %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24171 +        %EM_REPORT(key=OUTSUMHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=N,
24172 +              latticex=Variable, equalizerowy=Y, equalizecoly=Y, byset=_VARNAME_, description=tsfcstsumhist, view=&viewnum);
24173 +        %let viewnum=%eval(&viewnum+1);
24174 +        %EM_REPORT(key=OUTFCSTHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=Y,
24175 +              latticex=vlabel, equalizerowy=Y, equalizecoly=Y,  byset=_VARNAME_, description=tsfcsthist, view=&viewnum);
24176 +        %let viewnum=%eval(&viewnum+1);
24177 +    %end;
24178 +    %else %do;
24179 +        %EM_REPORT(key=OUTSUMHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=N,
24180 +              latticex=Variable, equalizerowy=Y, equalizecoly=Y, description=tsfcstsumhist, view=&viewnum);
24181 +        %let viewnum=%eval(&viewnum+1);
24182 +        %EM_REPORT(key=OUTFCSTHIST, viewtype=Lattice, latticetype=histogram, block=Plot, x=value, discreteX=Y, Freq=Percent, AutoDisplay=Y,
24183 +              latticex=vlabel, equalizerowy=Y, equalizecoly=Y, description=tsfcsthist, view=&viewnum);
24184 +        %let viewnum=%eval(&viewnum+1);
24185 +    %end;
24187 +    %let _EndTime = ;
24188 +    %let dsid=%sysfunc(open(&EM_USER_TSMETA));
24189 +    %if &dsid > 0 %then %do;
24190 +    %let vn_end =%sysfunc(varnum(&dsid, END));
24191 +    %let vn_format  = %sysfunc(varnum(&dsid, TIMEFORMAT));
24192 +    %do %while(^%sysfunc(fetch(&dsid)));
24193 +       %let _EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
24194 +       /*--------------------------------------------------------
24195 +       %let _TimeFormat  = %sysfunc(getvarc(&dsid, &vn_format));
24196 +       %let _EndTime =%sysfunc( putn(&_EndTime, &_TimeFormat));
24197 +        ---------------------------------------------------------*/
24198 +    %end;
24199 +    %let dsid = %sysfunc(close(&dsid));
24200 +    %end;
24202 +    %let _ndisplay = 3;
24203 +    %let _timeidVar = %EM_TIMEID;
24204 +    %let _targetVar = %EM_TARGET;
24205 +    %let _accumulate = &EM_PROPERTY_ACCUMULATE;
24208 +    %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24210 +        %let dsid=%sysfunc(open(&EM_DATA_VARIABLESET(where=(ROLE='INPUT' and LEVEL ='INTERVAL' and USE in ('D', 'Y')))));
24211 +        %let vn_name =%sysfunc(varnum(&dsid, NAME));
24212 +        %let _autodisplay = Y;
24213 +        %let YvarString = ;
24214 +        %let i = 0;
24215 +        %do %while(^%sysfunc(fetch(&dsid)));
24216 +            %let _varname= %sysfunc(getvarc(&dsid, &vn_name));
24217 +            %let i=%eval(&i+1);
24218 +            %let YvarString = &YvarString &_varname ;
24219 +            %if &i >  &_ndisplay %then %let _autodisplay = N;
24221 +            %let vnamefcstplot1 = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_vnamefcstplot, noquote, &_varname ));
24223 +            %if %EM_CROSSID ne %then
24224 +                  %EM_REPORT(key=FORCSTPLOTDS, viewtype=LINEBAND, block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_NAME_ ="&_varname"),  x=&_timeidVar,
24225 +                             LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE, XREF=&_EndTime, group=Outlier,
24226 +                             byset=_TSID_, Description= &vnamefcstplot1, view=&viewnum);
24227 +            %else
24228 +                  %EM_REPORT(key=FORCSTPLOTDS, viewtype=LINEBAND, block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_NAME_ ="&_varname"),  x=&_timeidVar,
24229 +                             LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE, XREF=&_EndTime, group=Outlier,
24230 +                             Description= &vnamefcstplot1, view=&viewnum);
24232 +            %let viewnum=%eval(&viewnum+1);
24233 +        %end;
24234 +        %let dsid = %sysfunc(close(&dsid));
24237 +        data &EM_USER_OUTCOMPFCST;
24238 +             set &EM_USER_OUTDATA;
24239 +             if &_timeidVar > &_EndTime then output;
24240 +             drop %EM_TARGET;    /* EM12 */
24241 +        run;
24243 +        %if %EM_CROSSID ne %then %do;
24245 +            /* &YVarString need to be replaced to aviod the potential length problem */
24247 +            %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, byset=_TSID_, X=&_timeidVar,
24248 +                Y=&YvarString, block=Plot, description=tsfcstcomp, view=&viewnum) ;
24249 +            %let viewnum=%eval(&viewnum+1);
24250 +            %let j=1;
24251 +            %do %while(%scan(&YvarString, &j) ne );
24252 +                %let _yvar=%scan(&YvarString, &j);
24253 +                %if &j = 1 %then
24254 +                    %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, group=_TSID_, X=&_timeidVar,
24255 +                        Y=&_yvar, block=Plot, description=mtsfcstcomp, view=&viewnum);
24256 +                %else
24257 +                    %EM_REPORT(Y=&_yvar, view=&viewnum);
24258 +                %let j=%eval(&j+1);
24260 +            %end;
24261 +            %let viewnum=%eval(&viewnum+1);
24262 +        %end;
24263 +        %else %do;
24264 +            %let j=1;
24265 +            %do %while(%scan(&YvarString, &j) ne );
24266 +                %let _yvar=%scan(&YvarString, &j);
24267 +                %if &j = 1 %then
24268 +                    %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar,
24269 +                        Y=&_yvar, block=Plot, description=tsfcstcomp, view=&viewnum);
24270 +                %else
24271 +                    %EM_REPORT(Y=&_yvar, view=&viewnum);
24272 +                %let j=%eval(&j+1);
24274 +            %end;
24275 +            %let viewnum=%eval(&viewnum+1);
24277 +            %if &j > 2 %then %do;
24278 +                %EM_REPORT(key=OUTCOMPFCST, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar,
24279 +                   Y=&YvarString, block=Plot, description=mtsfcstcomp, view=&viewnum);
24280 +                %let viewnum=%eval(&viewnum+1);
24281 +            %end;
24282 +        %end;
24285 +    %end;   /* the end of  if &EM_PROPERTY_EXTINPUT eq Y */
24286 +    %else %do;
24287 +        /*
24288 +        %let _crossidvars = %EM_CROSSID;
24289 +        %let _lastcrossidvar = %SCAN(&_crossidvars, -1, %STR( ));
24290 +        %if &_lastcrossidvar eq _SEGMENT_ %then %do;
24291 +            %let _tsidVar = _SEGMENT_;
24292 +            %EM_TS_GET_STAT(data=&EM_USER_TSIDMAP, var=_SEGMENT_, stat=MAX, value=n_segments);
24293 +        %end;
24294 +        %else %do;
24295 +            %let _tsidVar = _TSID_;
24296 +        %end;
24297 +        */
24298 +        %let _tsidVar = _TSID_;
24299 +        %if &_tsidVar = _TSID_ %then %do;
24300 +            %let dsid=%sysfunc(open(&EM_USER_FORCSTPLOTDS));
24301 +            %if &dsid > 0 %then %do;
24302 +                %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
24303 +                %let dsid = %sysfunc(close(&dsid));
24304 +            %end;
24305 +            %if &vn_tsid > 0 %then %do;
24306 +                %let dsid=%sysfunc(open(&EM_USER_TSIDMAP(where=(strip(_ROLE_)="TARGET"))));  /* whereclause EM12 */
24307 +                %if &dsid > 0 %then %do;
24308 +                    %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
24309 +                    %do %while(^%sysfunc(fetch(&dsid)));
24310 +                        %let _tsid  = %sysfunc(getvarn(&dsid, &vn_tsid));
24311 +                        %if &_tsid < &_ndisplay %then %let _autodisplay = Y;
24312 +                        %else %let _autodisplay = N;
24313 +                        %let tsidfcstplot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_tsidfcstplot, noquote, &_tsid ));
24314 +                        %EM_REPORT(key=FORCSTPLOTDS, view=&viewnum, viewtype=LINEBAND, Block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_TSID_ = &_tsid ),  x=&_timeidVar,
24315 +                                   LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE, XREF=&_EndTime, group=outlier,
24316 +                                   Description=&tsidfcstplot);
24317 +                        %let viewnum=%eval(&viewnum+1);
24318 +                    %end;
24319 +                    %let dsid = %sysfunc(close(&dsid));
24320 +                %end;
24321 +           %end;
24322 +           %else %do;  /*------ iterate over the target variables -----*/
24323 +                %let dsid=%sysfunc(open(&EM_DATA_VARIABLESET(where=(ROLE='TARGET' and LEVEL ='INTERVAL' and USE in ('D', 'Y')))));
24324 +                %let vn_name =%sysfunc(varnum(&dsid, NAME));
24325 +                %let _autodisplay = Y;
24326 +                %let i = 0;
24327 +                %do %while(^%sysfunc(fetch(&dsid)));
24328 +                    %let i=%eval(&i+1);
24329 +                    %if &i > 5 %then  %let _autodisplay = N;
24330 +                    %let _varname= %sysfunc(getvarc(&dsid, &vn_name));
24331 +                    %let vnamefcstplot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_vnamefcstplot, noquote, &_varname ));
24332 +                    %EM_REPORT(key=FORCSTPLOTDS, view=&viewnum, viewtype=LINEBAND, Block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_NAME_ ="&_varname"),  x=&_timeidVar, LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL,
24332!+YPLOTTYPE=LINE, XREF=&_EndTime,  group=outlier, Description=&vnamefcstplot);
24333 +                    %let viewnum=%eval(&viewnum+1);
24334 +                %end;
24335 +                %let dsid = %sysfunc(close(&dsid));
24336 +           %end;
24337 +        %end; /* end of %if &_tsidVar = _TSID_  */
24338 +        %else %if &_tsidVar = _SEGMENT_ %then %do;
24339 +              %do i=1 %to &n_segments;
24340 +                  %if &i < &_ndisplay %then %let _autodisplay = Y;
24341 +                  %else %let _autodisplay = N;
24342 +                  %let segfcstplot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsesm_segfcstplot, noquote, &i, &_accumulate ));
24343 +                  %EM_REPORT(key=FORCSTPLOTDS, view=&viewnum, viewtype=LINEBAND, Block=FcstPlot,  Autodisplay=&_autodisplay, WHERE=%BQUOTE(_SEGMENT_ = &i),  x=&_timeidVar, LOWERBAND=LOWER, UPPERBAND=UPPER, YLINE=PREDICT, Y=ACTUAL, YPLOTTYPE=LINE,
24343!+XREF=&_EndTime, group=outlier, Description=&segfcstplot);
24344 +                  %let viewnum=%eval(&viewnum+1);
24345 +              %end;
24346 +        %end;
24347 +         /*-------- the end of Forecasting Plot --------------------------------*/
24349 +        data &EM_USER_OUTCOMPFCST;
24350 +             set &EM_USER_OUTDATA;
24351 +            if &_timeidVar > &_EndTime then output;
24352 +            drop %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED;
24353 +        run;
24355 +        %let dsid=%sysfunc(open(&EM_USER_OUTCOMPFCST));
24356 +        %if &dsid > 0 %then %do;
24357 +            %let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
24358 +            %let vn_segment =%sysfunc(varnum(&dsid, _SEGMENT_));
24359 +            %let dsid = %sysfunc(close(&dsid));
24360 +        %end;
24362 +        %if (&vn_tsid > 0) and (&_targetVar ne ) %then %do;
24363 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=&_targetVar,block=Plot,
24364 +                            GROUP=_TSID_, WHERE=%nrbquote(_TSID_ <= 100), description=mtsfcstcomp) ;
24365 +            %let viewnum=%eval(&viewnum+1);
24366 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=&_targetVar,block=Plot,
24367 +                            Byset=_TSID_, WHERE=%nrbquote(_TSID_ <= 100), description=tsfcstcomp) ;
24368 +            %let viewnum=%eval(&viewnum+1);
24369 +        %end;
24370 +        %else %if &vn_segment > 0 and (&_targetVar ne ) %then %do;
24371 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=&_targetVar, block=Plot,
24372 +                            GROUP=_SEGMENT_, WHERE=%nrbquote(_SEGMENT_ <= 100),  description=tsfcstcomp) ;
24373 +            %let viewnum=%eval(&viewnum+1);
24374 +        %end;
24375 +        %else %if &vn_segment > 0 and (&_targetVar eq ) %then %do;
24376 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=%EM_INTERVAL_INPUT , block=Plot,
24377 +                            GROUP=_SEGMENT_, WHERE=%nrbquote(_SEGMENT_ <= 100),  description=tsfcstcomp) ;
24378 +            %let viewnum=%eval(&viewnum+1);
24379 +        %end;
24380 +        %else %do;
24381 +            %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=%EM_TARGET , block=Plot, description=mtsfcstcomp) ;
24382 +            %let viewnum=%eval(&viewnum+1);
24384 +            %if &EM_NUM_TARGET > 1 %then %do;
24385 +                %EM_REPORT(key=OUTCOMPFCST, view=&viewnum, AUTODISPLAY=Y, viewtype=LINEPLOT, X=&_timeidVar, Y=_ANYNUMERIC_, block=Plot, description=tsfcstcomp) ;
24386 +                %let viewnum=%eval(&viewnum+1);
24387 +            %end;
24388 +        %end;
24390 +    %end; /* the end of  if &EM_PROPERTY_EXTINPUT eq N */
24393 +   /*------------------ plot distance map ---------------------------------*/
24395 +   %if (&EM_PROPERTY_EXPORTDATA eq KLD) %then %do;
24397 +       %EM_GETNAME(KEY=OUTKLD, TYPE=DATA);
24398 +       %EM_GETNAME(KEY=MAPDS, TYPE=DATA);
24400 +       data _tmp;
24401 +           set &EM_USER_OUTKLD;
24402 +           KEEP _TSID_ _TSID:;
24403 +       proc sort data =_tmp;
24404 +            by _TSID_;
24405 +       proc transpose data =_tmp out= &EM_USER_MAPDS Prefix=TSID_;
24406 +            by _TSID_;
24407 +       run;
24409 +       data &EM_USER_MAPDS;
24410 +           set &EM_USER_MAPDS;
24411 +           label _TSID_ ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
24412 +           label _NAME_ ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
24413 +           label TSID_1 ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_distmeasure, noquote))";
24414 +           rename _NAME_  =COL_VAR;
24415 +           rename TSID_1 = DISTANCE;
24416 +           ROW_VAR = "_TSID"||strip(_TSID_);
24417 +           label ROW_VAR ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
24418 +       run;
24419 +       %EM_REPORT(key=MAPDS, viewtype=HISTOGRAM, Y=COL_VAR,X=ROW_VAR,
24420 +           FREQ=DISTANCE, autodisplay=Y, block=Plot, description=tssimmap, view=&viewnum);
24421 +       %let viewnum=%eval(&viewnum+1);
24422 +   %end;
24424 +   %let _xvar = ;
24425 +   %EM_TS_GET_VAR_EXIST(data=&EM_USER_OUTSUM, var=_TSID_, exist=_isTSID);
24426 +   %if &_isTSID eq Y %then %do;
24427 +      %let _xvar = _TSID_;
24428 +      /*%EM_TSDP_MergeTSID(inds=&EM_USER_OUTSUM, tsidds=&EM_USER_TSIDMAP, inputtype=&EM_PROPERTY_INPUTDATATYPE, outds=);*/
24429 +   %end;
24430 +   %else %do;
24431 +     %EM_TS_GET_VAR_EXIST(data=&EM_USER_OUTSUM, var=_NAMEID_, exist=_isNAMEID);
24432 +     %if &_isNAMEID eq Y %then %let _xvar = _NAMEID_;
24433 +     %else %do;
24434 +           %EM_TS_GET_VAR_EXIST(data=&EM_USER_OUTSUM, var=_NAME_, exist=_isNAME);
24435 +           %if &_isNAME eq Y %then %let _xvar = _NAME_;
24436 +     %end;
24437 +  %end;
24439 +  %if &_xvar ne %then %do;
24440 +        %let bysetflag = N;
24441 +         %if &EM_PROPERTY_EXTINPUT eq Y %then %do;
24442 +             data &EM_USER_OUTSUMPLOT;
24443 +                  set  &EM_USER_OUTSUM;
24444 +             %let j=1;
24445 +             %do %while(%scan(%EM_TARGET, &j) ne );
24446 +                 %let _var=%scan(%EM_TARGET, &j);
24447 +                 if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then delete;
24448 +                 %let j=%eval(&j+1);
24449 +             %end;
24450 +             run;
24451 +             %if %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED)  > 1 %then %let bysetflag = Y;
24452 +        %end;
24453 +        %else %do;
24454 +             data &EM_USER_OUTSUMPLOT;
24455 +                  set  &EM_USER_OUTSUM;
24456 +                  %let j=1;
24457 +                  %do %while(%scan(%EM_INTERVAL_INPUT, &j) ne );
24458 +                  %let _var=%scan(%EM_INTERVAL_INPUT, &j);
24459 +                  if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then delete;
24460 +                  %let j=%eval(&j+1);
24461 +                  %end;
24462 +                  %let j=1;
24463 +                  %do %while(%scan(%EM_INTERVAL_REJECTED, &j) ne );
24464 +                  %let _var=%scan(%EM_INTERVAL_REJECTED, &j);
24465 +                  if UPCASE(STRIP(_NAME_)) = UPCASE(STRIP("&_var")) then delete;
24466 +                  %let j=%eval(&j+1);
24467 +                  %end;
24468 +            run;
24469 +            %if &EM_NUM_TARGET  > 1 %then %let bysetflag = Y;
24470 +        %end;
24472 +    %if %EM_CROSSID ne %then %do;
24474 +        %if &bysetflag = Y %then
24475 +            %EM_REPORT(key=OUTSUMPLOT,  viewtype=BAR, autodisplay=Y, x=&_xvar, block=Plot,  FREQ=PREDICT,
24476 +                byset = _NAME_, description=tsfcstsum, view=&viewnum) ;
24477 +        %else
24478 +            %EM_REPORT(key=OUTSUMPLOT,  viewtype=BAR, autodisplay=Y, x=&_xvar, block=Plot,  FREQ=PREDICT,
24479 +                description=tsfcstsum, view=&viewnum) ;
24481 +    %end; /* end of %if %EM_CROSSID ne %then %do; */
24482 +    %else %do;
24484 +        %EM_REPORT(key=OUTSUMPLOT,  viewtype=BAR, autodisplay=Y, x=&_xvar, block=Plot,  FREQ=PREDICT,
24485 +            group=_NAME_, description=tsfcstsum, view=&viewnum) ;
24486 +        *%let viewnum=%eval(&viewnum+1);
24487 +    %end;
24489 +     %do k=1 %to &EM_PROPERTY_FCLEAD;
24490 +         %let _freqvarname = _LEAD&k._ ;
24491 +         %EM_REPORT(VIEW=&viewnum, Freq=&_freqvarname);
24492 +     %end;
24493 +     %EM_REPORT(VIEW=&viewnum, Freq=LOWER);
24494 +     %EM_REPORT(VIEW=&viewnum, Freq=UPPER);
24495 +     %EM_REPORT(VIEW=&viewnum, Freq=STD);
24496 +     %EM_REPORT(VIEW=&viewnum, Freq=MIN);
24497 +     %EM_REPORT(VIEW=&viewnum, Freq=MAX);
24498 +     %EM_REPORT(VIEW=&viewnum, Freq=MEAN);
24499 +     %EM_REPORT(VIEW=&viewnum, Freq=STDDEV);
24500 +  %end; /*end of   %if &_xvar ne %then %do; */
24503 +%mend EM_TSESM_REPORT;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 264 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 264 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 396 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 396 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 528 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 528 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 660 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 660 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 792 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 792 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 924 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 924 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1058 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 106 observations read from the data set EMWS5.TSESM4_OUTDATA.
NOTE: The data set EMWS5.TSESM4_OUTCOMPFCST has 6 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1058 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1191 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS5.TSESM4_OUTSUM.
NOTE: The data set EMWS5.TSESM4_OUTSUMPLOT has 1 observations and 20 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1191 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1323 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1323 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1455 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1455 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1587 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1587 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1719 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1719 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1851 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1851 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1983 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1983 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2115 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2115 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2247 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2247 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2379 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 2379 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2511 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 2511 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2643 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 2643 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2775 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2775 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2907 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
24506
24507
24508  *------------------------------------------------------------*;
24509  * End REPORT: TSESM4;
24510  *------------------------------------------------------------*;
 
24511  /* Reset EM Options */
24512  options formchar="|----|+|---+=|-/\<>*";
24513  options nocenter ls=256 ps=10000;
24514  goptions reset=all device=GIF NODISPLAY;
 
24515  proc sort data=WORK.EM_USER_REPORT;
24516  by ID VIEW;
24517  run;
 
NOTE: There were 2907 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2907 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
